<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[波义尔摩尔投票算法（Boyer-Moore Voting Algorithm）]]></title>
    <url>%2F%E6%B3%A2%E4%B9%89%E5%B0%94%E6%91%A9%E5%B0%94%E6%8A%95%E7%A5%A8%E7%AE%97%E6%B3%95%EF%BC%88Boyer-Moore-Voting-Algorithm%EF%BC%89%2F</url>
    <content type="text"><![CDATA[简介 The Boyer–Moore majority vote algorithm is an algorithm for finding the majority of a sequence of elements using linear time and constant space. It is named after Robert S. Boyer and J Strother Moore, who published it in 1981,[1] and is a prototypical example of a streaming algorithm. 波义尔摩尔投票算法是一种使用线性时间复杂度和常数空间复杂度来找到数组的主要元素（出现超过一半次数的元素）。 题目: 169. Majority Element。找出数组中出现超过一半的元素。 Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times. You may assume that the array is non-empty and the majority element always exist in the array. 《剑指Offer》中的解释 遍历数组的时候保存两个值：一个是数组中的数字，另一个是次数。当我们遍历到下一个数字的时候，如果下一个数字和我们之前保存的数字相同，则次数加1；如果下一个数字和我们之前保存的数字不同，则次数减1。如果次数为零，那么需要保存下一个数字，并把次数设为1.由于我们要找的数字出现的次数比其他所有数字出现的次数之和还要多，那么要找的数字肯定是最后一次把次数设为1时的对应数字。 整个过程想象成一次投票选举投票规则：大屏幕上只允许出现一位候选人。如果选举人投的票不是当前候选人，那么让当前候选人票-1，如果是，则+1。OK，我们现在把所有数组的元素当成是选举人举出的号牌。我们先考虑最极端的情况：最后的winner以一票之差险胜。也就是元素出现的次数为n//2+1。这种情况是如何出现的呢，假设数组是这样的： 1[7, 7, 7, 7, 1, 2, 3] 没有投7的选举人假设在一开始知道了最有潜力的winner即7号，那么他们‘同仇敌忾’，将-1的票都投在了7号上，这种情况7号一直处于大屏幕中，没有更换过候选人。但是最后也没能打败7号，因为7号最后还保留一票。 另外一种非极端的情况，没有投7的选举人产生了‘内讧’： 1[7, 1, | 2, 3, | 7, 7, 7] 首先7号得到一票，然后被1号干掉，接着2号称为候选人，被3号干掉。3号的票浪费在了‘自己人’身上，即‘我们中出了一个叛徒’。就算团结起来都干不过7号，所以winner还是7号。 最后附上LeetCode上的Python代码： 1234567891011class Solution: def majorityElement(self, nums): count = 0 candidate = None for num in nums: if count == 0: candidate = num count += (1 if num == candidate else -1) return candidate 参考： 维基百科 LeetCode]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode算法题整理（sql篇）sql]]></title>
    <url>%2FLeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88sql%E7%AF%87%EF%BC%89sql%2F</url>
    <content type="text"><![CDATA[595. Big Countries查询’大城市’。原题 使用where OR 123select name, population, area from World where area &gt; 3000000 or population &gt; 25000000; 使用UNION 12345678select name, population, area from World where area &gt; 3000000unionselect name, population, areafrom Worldwhere population &gt; 25000000; 补充说明：Solution中解释道，使用UNION会比OR快上一丢丢。 Suppose we are searching population and area, Given that MySQL usually uses one one index per table in a given query, so when it uses the 1st index rather than 2nd index, it would still have to do a table-scan to find rows that fit the 2nd index. 因为前者查询的时候只用到第一个索引，对第二个条件查询时，也就是population，使用的是全表扫描，于是浪费了一些时间。但是想想背后的代价，想必是以空间来换时间。 627. Swap Salary转换性别。原题 使用if 123UPDATE salarySET sex=IF(sex='m', 'f', 'm'); 使用CASE 1234567update salaryset sex = CASE sex when 'm' Then 'f' else 'm' END; 使用XOR 123update salaryset sex = CHAR(ASCII('f') ^ ASCII('m') ^ ASCII(sex)); 620. Not Boring Movies使用MOD替代%。原题12345select *from cinemawhere mod(id, 2) = 1 and description != 'boring'order by rating DESC; 182. Duplicate Emails查询多余的重复值。原题思考：开始陷入了误区，以为要将重复的id也查出来。 1234SELECT emailFROM PersonGROUP BY emailHAVING Count(*) &gt; 1; 175. Combine Two Tables左链接。过于简单。原题123456SELECT p.FirstName, p.LastName, ad.City, ad.StateFROM Person p LEFT JOIN Address ad ON p.PersonId = ad.PersonId; 181. Employees Earning More Than Their Managers自链接。原题123456select e.name Employeefrom Employee e inner join Employee m on e.ManagerId = m.Idwhere e.Salary &gt; m.Salary; 183. Customers Who Never Order没有订单的顾客。原题123456select c.name Customersfrom Customers c left join Orders o on c.id = o.CustomerIdwhere o.CustomerId is Null; 123456select customers.name as 'Customers'from customerswhere customers.id not in( select customerid from orders); 596. Classes More Than 5 Students超过5个学生的班级。原题12345select classfrom coursesgroup by classhaving count(distinct student) &gt;= 5; 197. Rising Temperature这个挺有意思，开始天真地想用id作为条件，测试用例教做人。原题 我的答案 123456SELECT today.IdFROM Weather yest INNER JOIN Weather today ON today.RecordDate = DATE_ADD(yest.RecordDate, INTERVAL 1 day)WHERE today.Temperature &gt; yest.Temperature; 标准答案 12345678SELECT weather.id AS 'Id'FROM weather JOIN weather w ON DATEDIFF(weather.date, w.date) = 1 AND weather.Temperature &gt; w.Temperature; 查看Mysql文档： DATEDIFF(expr1,expr2) DATEDIFF() returns expr1 − expr2 expressed as a value in days from one date to the other. expr1 and expr2 are date or date-and-time expressions. Only the date parts of the values are used in the calculation. 1234mysql&gt; SELECT DATEDIFF('2007-12-31 23:59:59','2007-12-30'); -&gt; 1mysql&gt; SELECT DATEDIFF('2010-11-30 23:59:59','2010-12-31'); -&gt; -31 196. Delete Duplicate Emails删除重复的邮件。原题1234delete p1 from Person p1, Person p2where p1.email=p2.email and p1.Id &gt; p2.Id; 176. Second Highest Salary返回第二高的salary。原题PS：奇怪的题，没有记录非要人返回Null，只能再套一层查询或者使用IFNULL也可以。 12345678SELECT (SELECT DISTINCT Salary FROM Employee ORDER BY Salary DESC LIMIT 1 OFFSET 1) AS SecondHighestSalary; 626. Exchange Seats交换相邻两行的值。原题开始理解错了，以为要update。 CASE 123456789101112SELECT ( CASE WHEN MOD(id, 2) != 0 AND counts != id THEN id + 1 WHEN MOD(id, 2) != 0 AND counts = id THEN id ELSE id - 1 end ) AS id, studentFROM seat, (SELECT Count(*) AS counts FROM seat) AS seat_countsORDER BY id ASC;; COALESCE() 第一步：使用XOR，但是不能直接使用排序因为id为5的被换成了6。 1SELECT id, (id+1)^1-1, student FROM seat; 123456789+------+------+----------+------------+---------+| id | id+1 | (id+1)^1 | (id+1)^1-1 | student |+------+------+----------+------------+---------+| 1 | 2 | 3 | 2 | Abbot || 2 | 3 | 2 | 1 | Doris || 3 | 4 | 5 | 4 | Emerson || 4 | 5 | 4 | 3 | Green || 5 | 6 | 7 | 6 | Jeame |+------+------+----------+------------+---------+ 第二步：使用LEFT JOIN链接。 12345SELECT *FROM seat s1 LEFT JOIN seat s2 ON ( s1.id + 1 )^1 - 1 = s2.idORDER BY s1.id; 123456789+------+---------+------+---------+| id | student | id | student |+------+---------+------+---------+| 1 | Abbot | 2 | Doris || 2 | Doris | 1 | Abbot || 3 | Emerson | 4 | Green || 4 | Green | 3 | Emerson || 5 | Jeame | NULL | NULL |+------+---------+------+---------+ 第三步：使用COALESCE() 1234567SELECT s1.id, Coalesce(s2.student, s1.student) as studentFROM seat s1 LEFT JOIN seat s2 ON ( s1.id + 1 )^1 - 1 = s2.idORDER BY s1.id; 参考：Mysql文档 Returns the first non-NULL value in the list, or NULL if there are no non-NULL values.The return type of COALESCE() is the aggregated type of the argument types. 178. Rank Scores]]></content>
      <categories>
        <category>sql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode算法题整理（位运算篇）Bit Manipulation]]></title>
    <url>%2FLeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AF%87%EF%BC%89Bit-Manipulation%2F</url>
    <content type="text"><![CDATA[191. Number of 1 Bits计算数字的二进制中有多少个1。原题123Input: 11Output: 3Explanation: Integer 11 has binary representation 00000000000000000000000000001011 方法一：常规解法，使用1与n作与运算，如果不是0说明，含有一个1。 1234567def hamming_weight(n): bits, mask = 0, 1 for _ in range(32): if n&amp;mask != 0: bits += 1 mask &lt;&lt;= 1 return bits 方法二：关键点是，一个数n和n-1的与运算操作，相当于去掉了最右面的1。 123456def hamming_weigth(n): bits = 0 while n: bits += 1 n = (n-1) &amp; n return bits]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
        <tag>algorithm</tag>
        <tag>Bit Manipulation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode算法题整理（二分法篇）Binary Search]]></title>
    <url>%2FLeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E4%BA%8C%E5%88%86%E6%B3%95%E7%AF%87%EF%BC%89Binary-Search%2F</url>
    <content type="text"><![CDATA[704. Binary Search二分法在有序数组中查找元素。原题123Input: nums = [-1,0,3,5,9,12], target = 9Output: 4Explanation: 9 exists in nums and its index is 4 1234567891011def binary_search(nums, target): l, r = 0, len(nums)-1 while l &lt;= r: mid = (l+r) // 2 if nums[mid] &gt; target: r = mid - 1 elif nums[mid] &lt; target: l = mid + 1 else: return mid return -1 35. Search Insert Position给定一个target，插入到一个有序数组中，假定数组中无重复元素。原题12Input: [1,3,5,6], 5Output: 2 1234567891011def binary_insert(nums, target): l, r = 0, len(nums)-1 while l &lt;= r: mid = (l+r) // 2 if nums[mid] &gt; target: r = mid - 1 elif nums[mid] &lt; target: l = mid + 1 else: return mid return l 153. Find Minimum in Rotated Sorted Array通过一个排序数组旋转后的结果，找出最小元素。原题12Input: [3,4,5,1,2] Output: 1 思路：通过二分法不断缩小范围，由于mid是整除，最后l==mid，并且nums[mid] &gt; nums[r]的。 123456789101112def find_min(nums): l, r = 0, len(nums)-1 if nums[l] &lt; nums[r]: return nums[l] while l &lt;= r: mid = (l+r) // 2 if nums[mid] &gt; nums[l]: l = mid elif nums[mid] &lt; nums[r]: r = mid else: return nums[r]]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary Search</tag>
        <tag>Python</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer]]></title>
    <url>%2F%E5%89%91%E6%8C%87Offer%2F</url>
    <content type="text"><![CDATA[2. 实现Singleton模式使用__new__控制实例创建过程12345678class Singleton: def __new__(cls, *args, **kw): if not hasattr(cls, '_instance'): cls._instance = super(Singleton, cls).__new__(cls, **args, **kw) return cls._instanceclass Myclass(Singleton): pass 使用decorator12345678910111213from functools import wrapsdef singleton(cls): instances = &#123;&#125; @wraps(cls) def get_instance(*args, **kw): if cls not in instances: instances[cls] = cls(*args, **kw) return instances[cls] return get_instance@singletonclass Myclass: pass 使用元类12 4. 二维数组中的查找1234567891011def find(target, array): row = 0 col = len(array[0]) - 1 while col &gt;= 0 and row &lt;= len(array)-1: if array[row][col] &gt; target: col -= 1 elif array[row][col] &lt; target: row += 1 else: return True return False 5.替换空格123456def replaceSpace(self, s): chars = list(s) for i, char in enumerate(chars): if char == ' ': chars[i] = '%20' return ''.join(chars) 6.从尾到头打印链表123456def printListFromTailToHead(self, listNode): stack = [] while listNode: stack.append(listNode.val) listNode = listNode.next return stack[::-1] 7.重建二叉树说明：根据前序遍历和中序遍历重建二叉树，假设遍历结果中不包含重复的数字。105. Construct Binary Tree from Preorder and Inorder Traversal 9.用两个栈实现队列232. Implement Queue using Stacks 9.1用两个队列实现栈225. Implement Stack using Queues 10.斐波那契数列说明：爬楼梯问题的抽象70. Climbing Stairs 11.旋转数组的最小数字说明：通过一个递增数组旋转后的数组，找出最小元素。153. Find Minimum in Rotated Sorted Array 12.矩阵中的路径说明：回溯法。这道题在牛客网上做的，参考了排行前几的答案，却发现了问题，前几的答案中，find方法中的循环都在条件中直接return，这样依赖于整个条件判断的顺序，奇怪的是这样居然可以通过测试用例，可见牛客网的权威性还是不如LeetCode。例如输入matrix = &#39;ABEESFCSADME&#39;, rows=3, cols=4, path=&#39;SEE&#39;返回了False，实际应该返回True。正确的做法不应直接return，而是保存结果用or判断，判断中也不应该使用elif。 12345678910111213141516171819202122232425# -*- coding:utf-8 -*-class Solution: def hasPath(self, matrix, rows, cols, path): # write code here for i in range(rows): for j in range(cols): if matrix[i*cols + j] == path[0]: if self.spread(list(matrix), rows, cols, path[1:], i, j): return True return False def spread(self, matrix, rows, cols, path, i, j): if not path: return True matrix[i*cols + j] = '-' up, down, left, right = False, False, False, False if j + 1 &lt; cols and matrix[i * cols + j + 1] == path[0]: down = self.spread(matrix, rows, cols, path[1:], i, j + 1) if j - 1 &gt;= 0 and matrix[i * cols + j - 1] == path[0]: left = self.spread(matrix, rows, cols, path[1:], i, j - 1) if i + 1 &lt; rows and matrix[(i + 1) * cols + j] == path[0]: right = self.spread(matrix, rows, cols, path[1:], i + 1, j) if i - 1 &gt;= 0 and matrix[(i - 1) * cols + j] == path[0]: up = self.spread(matrix, rows, cols, path[1:], i - 1, j) return up or down or left or right 13. 机器人的运动范围12345678910111213141516171819202122232425# -*- coding:utf-8 -*-class Solution: def movingCount(self, threshold, rows, cols): # write code here self.visited = [False] * rows * cols self.movingCountCore(threshold, rows, cols, 0, 0) return sum(self.visited) def movingCountCore(self, threshold, rows, cols, i, j): if self.get_double_sum(i, j) &lt;= threshold: self.visited[i*cols + j] = True if i-1&gt;=0 and not self.visited[(i-1)*cols+j]: self.movingCountCore(threshold, rows, cols, i-1, j) if i+1&lt;rows and not self.visited[(i+1)*cols+j]: self.movingCountCore(threshold, rows, cols, i+1, j) if j-1&gt;=0 and not self.visited[i*cols+j-1]: self.movingCountCore(threshold, rows, cols, i, j-1) if j+1&lt;cols and not self.visited[i*cols+j+1]: self.movingCountCore(threshold, rows, cols, i, j+1) def get_digit_sum(self, num): return sum(map(int, str(num))) def get_double_sum(self, i, j): return self.get_digit_sum(i) + self.get_digit_sum(j) 14.剪绳子说明：数学思想，当n&gt;=5时，2(n-2)&gt;n并且3(n-3)&gt;n，而且3(n-3) &gt;= 2(n-2)，所以尽可能多剪长度为3的绳子。如果长度为4的时候，2*2&gt;3*1，所以4的时候就剪成2*2的两段。 12345678910111213def cut_rope(length): if length &lt; 2: return 0 if length == 2: return 1 if length == 3: return 2 timesOf3 = length // 3 if length-timesOf3*3 == 1: timeOf3 -= 1 timesOf2 = (length-timesOf3*3) // 2 return (3**timesOf3) * (2**timesOf2) 15.二进制中1的个数191. Number of 1 Bits 16.数值的整数次方50. Pow(x, n) 18.删除链表中的节点237. Delete Node in a Linked List 19.正则表达式10. Regular Expression Matching 先考虑没有*的情况，通过一个递归逐个字符判断 1234def match(text, pattern): if not pattern: return not text first_match = bool(text) and pattern[0] in &#123;text[0], '.'&#125; return first_match and match(text[1:], pattern[1:]) 当*出现时，一定会在前面跟一个其他字符，所以一定会出现在pattern[1]的位置。一种情况是我们忽略这对pattern，因为可以出现0次；另一种情况是匹配上这个字符，用递归的方式匹配下一个。 12345678def match(text, pattern): if not pattern: return not text first_match = bool(text) and pattern[0] in &#123;text[0], '.'&#125; if len(pattern) &gt;= 2 and pattern[1] == '*': return match(text, pattern[2:]) or \ (first_match and match(text[1:], pattern) else: return first_match and match(text[1:], pattern[1:]) 20. 表示数值的字符串65. Valid Number此处留坑，排名第一的python答案暂时没有理解。 21.调整数组顺序使奇数位于偶数前面 时间：O(n), 空间O(1) 123456789def reOrderArray(self, array): # write code here l, r = 0, len(array)-1 while l &lt; r: while l &lt; r and array[l]&amp;1 == 1: l += 1 while l &lt; r and array[r]&amp;1 == 0: r -= 1 array[l], array[r] = array[r], array[l] 看了一下没有通过牛客网的测试用例，因为题目有些不同，牛客网要求奇数和奇数，偶数和偶数之前的相对位置不变。 12def reOrderArray(array): return sorted(array, key=lambda x:x&amp;1==0) 不使用sort 1234567891011def reOrderArray(self, array): # write code here from collections import deque q = deque() n = len(array) for i in range(n): if array[n-1-i] &amp; 1 == 1: # 从后找奇数 q.appendleft(array[n-1-i]) if array[i] &amp; 1 == 0: #从前找偶数 q.append(array[i]) return q 22.链表中倒数第k个节点思路：两个指针，快指针先走k-1步，然后两个一起走，快指针走到尾节点时，慢指针在倒数第k个节点。需考虑k=0时和fast已经走到尾节点的情况。 12345678910111213141516def FindKthToTail(self, head, k): # write code here if k == 0: return None fast = slow = head for _ in range(k-1): if fast and fast.next: fast = fast.next else: return None while fast.next: slow = slow.next fast = fast.next return slow 23.链表中环的入口节点142. Linked List Cycle II 24.反转链表206. Reverse Linked List 25.合并两个有序链表21. Merge Two Sorted Lists 26.树的子结构572. Subtree of Another Tree 27.二叉树的镜像123456def Mirror(self, root): # write code here if root: root.left, root.right = root.right, root.left self.Mirror(root.left) self.Mirror(root.right) 28.对称的二叉树101. Symmetric Tree 29.顺时针打印矩阵说明：书中的方法过于繁琐，这里参考了一个LeetCode大神的解法。主要思想是每次取出数组的第一行，然后将整个数组逆时针旋转90°。 54. Spiral Matrix 30.包含min函数的栈155. Min Stack 31.栈的压入、弹出序列思路：如果下一个弹出的数字是栈顶数字，直接弹出；如果下一个弹出的数字不在栈顶，则把没有入栈的数字压入栈，如果入栈序列为空，则返回False 123456789101112131415class Solution: def IsPopOrder(self, pushV, popV): # write code here stack = [] for i in range(len(popV)): while True: if stack and popV[i]==stack[-1]: stack.pop() break else: if pushV: stack.append(pushV.pop(0)) else: return False return True 32.从上到下打印二叉树 双端队列 123456789101112def PrintFromTopToBottom(self, root): # write code here from collections import deque queue = deque([root]) res = [] while len(queue) != 0: cur = queue.popleft() if cur: res.append(cur.val) queue.append(cur.left) queue.append(cur.right) return res 分层思想，主要为了下一题 12345678910def PrintFromTopToBottom(self, root): # write code here res, level = [], [root] while root and level: res.extend([node.val for node in level]) temp = [] for node in level: temp.extend([node.left, node.right]) level = [leaf for leaf in temp if leaf] return res 32.1分层从上到下打印二叉树102. Binary Tree Level Order Traversal 32.2之字形打印二叉树103. Binary Tree Zigzag Level Order Traversal 33.二叉树的后序遍历145. Binary Tree Postorder Traversal 34.二叉树和为某一值的路径113. Path Sum II 35.复杂链表的复制138. Copy List with Random Pointer 36.二叉搜索树与双向链表此题留坑。 37.序列化二叉树297. Serialize and Deserialize Binary Tree 38.字符串的排列46. Permutations II 使用itertools 123456def Permutation(self, ss): # write code here from itertools import permutations if not ss: return [] return sorted(list(set([''.join(x) for x in permutations(ss)]))) 这里注意几点： 为什么要判断if not ss，是因为如果ss=&#39;&#39;的时时候，返回了[&#39;&#39;]而不是[]。因为这里返回了一个空的tuple，所以在列表推导式中是有一个元素的。 12&gt;&gt;&gt; list(permutations('', 0))[()] 为什么使用set去重，因为当ss=&#39;aa&#39;的时候，牛客网的测试用例要求返回一个元素，即[&#39;aa&#39;]。 排序也是为了满足测试用例。 自己实现。这里拆成两个方法的原因还是因为ss=&#39;&#39;的时候会影响递归循环。 1234567891011def Permutation(self, ss): # write code here if not ss: return [] return self.permute(ss)def permute(self, ss): return sorted(list(set([h + p for i, h in enumerate(ss) for p in self.permute(ss[:i]+ss[i+1:]) ]))) or [""]]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>algorithm</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python排序算法]]></title>
    <url>%2FPython%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[快速排序 12345678910111213def quick_sorted(nums): if nums &lt; 2: return nums pivot = nums[0] small, medium, large = [], [], [] for num in nums: if num &lt; pivot: small.append(num) elif num &gt; pivot: large.append(num) else: medium.append(num) return quick_sorted(small) + medium + quick_sorted(large) 冒泡排序123456789101112def bubble_sorted(nums): res = list(nums) n = len(res) for i in range(n-1, 0, -1): flag = True for j in range(0, i): if res[j] &gt; res[j+1]: res[j], res[j+1] = res[j+1], res[j] flag = False if flag: return res return res 选择排序12345678910def select_sorted(nums): res = list(nums) n = len(res) for i in range(n-1): min_i = i for j in range(i+1, n): if res[min_i] &gt; res[j]: min_i = j res[min_i], res[i] = res[i], res[min_i] return res 插入排序 1234567891011121314def inset_sorted(nums): res = list(nums) n = len(res) for i in range(1, n): val = res[i] # 待插入值 index = i # 待插入下标 for j in range(i-1, -1, -1): if res[j] &gt; val: res[j+1] = res[j] index = j else: break res[index] = val return res 希尔排序一直觉得网上的希尔排序方式不够pythonic，这里写了一个调用插入排序的方法。 123456789def shell_sorted(nums): res = list(nums) n = len(res) step = round(n/2) while step &gt; 0: for i in range(step): res[i:n:step] = insert_sorted(res[i:n:step]) step = round(step/2) return res]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>algorithm</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode算法题整理（设计篇）Design]]></title>
    <url>%2FLeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E8%AE%BE%E8%AE%A1%E7%AF%87%EF%BC%89Design%2F</url>
    <content type="text"><![CDATA[155. Min Stack设计一个栈，要求在常数时间复杂度取出最小值。原题 12345678MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin(); --&gt; Returns -3.minStack.pop();minStack.top(); --&gt; Returns 0.minStack.getMin(); --&gt; Returns -2. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class MinStack: def __init__(self): """ initialize your data structure here. """ self._stack = [] def push(self, x): """ :type x: int :rtype: void """ prev = self.getMin() if prev is None or x &lt; prev: prev = x self._stack.append((x, prev)) def pop(self): """ :rtype: void """ self._stack.pop() def top(self): """ :rtype: int """ if len(self._stack) == 0: return None return self._stack[-1][0] def getMin(self): """ :rtype: int """ if len(self._stack) == 0: return None return self._stack[-1][1] # Your MinStack object will be instantiated and called as such:# obj = MinStack()# obj.push(x)# obj.pop()# param_3 = obj.top()# param_4 = obj.getMin() 232. Implement Queue using Stacks使用两个栈实现一个队列。原题1234567MyStack stack = new MyStack();stack.push(1);stack.push(2); stack.top(); // returns 2stack.pop(); // returns 2stack.empty(); // returns false 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class MyQueue: def __init__(self): """ Initialize your data structure here. """ self.in_stack, self.out_stack = [], [] def push(self, x): """ Push element x to the back of queue. :type x: int :rtype: void """ self.in_stack.append(x) def pop(self): """ Removes the element from in front of queue and returns that element. :rtype: int """ self.move() return self.out_stack.pop() def peek(self): """ Get the front element. :rtype: int """ self.move() return self.out_stack[-1] def empty(self): """ Returns whether the queue is empty. :rtype: bool """ return self.in_stack == self.out_stack == [] def move(self): """ move the element from in_stack to out_stack """ if self.out_stack == []: while self.in_stack: self.out_stack.append(self.in_stack.pop()) 225. Implement Stack using Queues使用队列实现栈。原题方法一：两个队列，push-O(1), pop/top O(n) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748from collections import dequeclass MyStack: def __init__(self): """ Initialize your data structure here. """ self.q1, self.q2 = deque(), deque() def push(self, x): """ Push element x onto stack. :type x: int :rtype: void """ self.q1.append(x) def pop(self): """ Removes the element on top of the stack and returns that element. :rtype: int """ while len(self.q1) != 1: self.q2.append(self.q1.popleft()) pop_val = self.q1.popleft() self.q1, self.q2 = self.q2, self.q1 return pop_val def top(self): """ Get the top element. :rtype: int """ while len(self.q1) != 1: self.q2.append(self.q1.popleft()) pop_val = self.q1[0] self.q2.append(self.q1.popleft()) self.q1, self.q2 = self.q2, self.q1 return pop_val def empty(self): """ Returns whether the stack is empty. :rtype: bool """ return len(self.q1) == 0 方法二：两个队列，push-O(n), pop/top-O(1) 1234567891011121314151617181920212223242526272829303132333435363738394041from collections import dequeclass MyStack: def __init__(self): """ Initialize your data structure here. """ self.q1, self.q2 = deque(), deque() def push(self, x): """ Push element x onto stack. :type x: int :rtype: void """ self.q2.append(x) while self.q1: self.q2.append(self.q1.popleft()) self.q1, self.q2 = self.q2, self.q1 def pop(self): """ Removes the element on top of the stack and returns that element. :rtype: int """ return self.q1.popleft() def top(self): """ Get the top element. :rtype: int """ return self.q1[0] def empty(self): """ Returns whether the stack is empty. :rtype: bool """ return len(self.q1) == 0 方法三：一个队列旋转 12345678910111213141516171819202122232425262728293031323334353637383940from collections import dequeclass MyStack: def __init__(self): """ Initialize your data structure here. """ self.queue = deque() def push(self, x): """ Push element x onto stack. :type x: int :rtype: void """ self.queue.append(x) for _ in range(len(self.queue)-1): self.queue.append(self.queue.popleft()) def pop(self): """ Removes the element on top of the stack and returns that element. :rtype: int """ return self.queue.popleft() def top(self): """ Get the top element. :rtype: int """ return self.queue[0] def empty(self): """ Returns whether the stack is empty. :rtype: bool """ return len(self.queue) == 0]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
        <tag>algorithm</tag>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode算法题整理（二叉树篇）Tree]]></title>
    <url>%2FLeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AF%87%EF%BC%89Tree%2F</url>
    <content type="text"><![CDATA[树的定义12345class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None 144. Binary Tree Preorder Traversal二叉树前序遍历12345678Input: [1,null,2,3] 1 \ 2 / 3Output: [1,2,3] 方法一：iteratively 12345678910def preorder_traversal(root): nodes = [root] res = [] while nodes: cur_node = nodes.pop() if cur_node: res.append(cur_node.val) nodes.append(cur_node.right) nodes.append(cur_node.left) return res 方法二：recursively 12345def preorder_traversal(root): if not root: return [] return [root.val] + self.preorderTraversal(root.left) \ + self.preorderTraversal(root.right) 94. Binary Tree Inorder Traversal中序遍历二叉树12345678Input: [1,null,2,3] 1 \ 2 / 3Output: [1,3,2] 123456789101112def inorder_traversal(root): stack = [] res = [] while True: while root: stack.append(root) root = root.left if stack == []: return res cur = stack.pop() res.append(cur.val) root = cur.right 145. Binary Tree Postorder Traversal后序遍历二叉树12345678Input: [1,null,2,3] 1 \ 2 / 3Output: [3,2,1] 12345678910def postorder_traversal(root): stack = [root] res = [] while stack: node = stack.pop() if node: res.append(node.val) stack.append(node.left) stack.append(node.right) return res[::-1] 100. Same Tree判断相同的二叉树。原题1234567Input: 1 1 / \ / \ 2 3 2 3 [1,2,3], [1,2,3]Output: true 方法一：recursively 12345def is_same_tree(p, q): if p and q: return p.val == q.val and is_same_tree(p.left, q.left) and is_same_tree(p.right, q.right) else: return p is q 方法二：recursively, tuple 12345def is_same_tree(p, q): def t(n): return n and (n.val, t(n.left), t(n.right) return t(p) == t(q) 101. Symmetric Tree判断二叉树是否对称。原题12345 1 / \ 2 2 / \ / \3 4 4 3 12345678910def is_symmetric(root): if not root: return True return is_pair(root.left, root.right) def is_pair(l1, l2): if l1 and l2: return l1.val == l2.val and is_pair(l1.left, l2.right) and is_pair(l2.left, l1.right) else: return l1 is l2 104. Maximum Depth of Binary Tree二叉树最大深度。原题123456 3 / \ 9 20 / \ 15 7return 3 1234def max_depth(root): if not root: return 0 return max(max_depth(root.left), max_depth(root.right)) + 1 105. Construct Binary Tree from Preorder and Inorder Traversal根据前序遍历和中序遍历重建二叉树。原题12preorder = [3,9,20,15,7]inorder = [9,3,15,20,7] 123456789def buildTree(preorder, inorder): if preorder == []: return None root_val = preorder[0] root = TreeNode(root_val) cut = inorder.index(root_val) root.left = buildTree(preorder[1:cut+1], inorder[:cut]) root.right = buildTree(preorder[cut+1:], inorder[cut+1:]) return root 572. Subtree of Another Tree判断是否是树的子结构。原题思路：这道题是遍历加判断相同树的结合。这里采用前序遍历和递归判断相同树。 12345678910111213141516def isSubtree(self, s, t): stack = [s] while stack: root = stack.pop() if root: if self.is_same(root, t): return True stack.append(root.right) stack.append(root.left) return False def is_same(self, s, t): if s and t: return s.val==t.val and self.is_same(s.left, t.left) and self.is_same(s.right, t.right) else: return s is t 102. Binary Tree Level Order Traversal分层遍历二叉树。原题注意：循环条件要加上root，以防止root is None 123456def levelOrder(self, root): res, level = [], [root] while root and level: res.append([n.val for n in level]) level = [kid for n in level for kid in (n.left, n.right) if kid] return res 103. Binary Tree Zigzag Level Order Traversal之字形打印二叉树。原题1234567def zigzagLevelOrder(self, root): res, level, order = [], [root], 1 while root and level: res.append([n for n in level][::order]) order *= -1 level = [kid for n in level for kid in (n.left, n.right) if kid] return res 257. Binary Tree Paths打印二叉树从根节点到叶子节点全部路径。原题1234567891011Input: 1 / \2 3 \ 5Output: [&quot;1-&gt;2-&gt;5&quot;, &quot;1-&gt;3&quot;]Explanation: All root-to-leaf paths are: 1-&gt;2-&gt;5, 1-&gt;3 iteratively。思路：采用前序遍历二叉树，使用tuple保存节点当前路径，如果是叶子节点，则添加到结果中。开始老是想着用&#39;-&gt;&#39;.join()，这样反而麻烦，直接使用字符串保存就好。 1234567891011121314151617181920212223def binaryTreePaths(self, root): # iteratively if not root: return [] stack = [(root, str(root.val))] res = [] while stack: cur, path = stack.pop() if self.is_leaf(cur): res.append(path) else: if cur.right: stack.append((cur.right, path+'-&gt;'+str(cur.right.val))) if cur.left: stack.append((cur.left, path+'-&gt;'+str(cur.left.val))) return res def is_leaf(self, node): if node.left is None and node.right is None: return True else: return False recursively。参考了StefanPochmann大神的方法。最开始想到一半，中间那层循环想到了，但没想到用递归。 1234567def binaryTreePaths(self, root): # recursively if not root: return [] return [str(root.val) + '-&gt;' + path for kid in (root.left, root.right) if kid for path in self.binaryTreePaths(kid)] or [str(root.val)] 112. Path Sum判断是否具有从根节点到叶子节点上的值和为sum。原题 recursively 12345678def hasPathSum(self, root, sum): if not root: return False elif root.val == sum and root.left is None and root.right is None: return True else: return self.hasPathSum(root.left, sum-root.val) or \ self.hasPathSum(root.right, sum-root.val) iteratively 1234567891011121314151617181920def hasPathSum(self, root, sum): # iteratively if not root: return False stack = [(root, sum)] while stack: cur, sum = stack.pop() if self.is_leaf(cur) and cur.val==sum: return True if cur.right: stack.append((cur.right, sum-cur.val)) if cur.left: stack.append((cur.left, sum-cur.val)) return False def is_leaf(self, node): if node.left is None and node.right is None: return True else: return False 113. Path Sum II上题的升级版，要求二维数组返回所有路径。原题123456789sum = 22 5 / \ 4 8 / / \ 11 13 4 / \ / \7 2 5 1 1234[ [5,4,11,2], [5,8,4,5]] iteratively. 举一反三。 123456789101112131415161718192021def pathSum(self, root, sum): # iteratively if not root: return [] res, stack = [], [(root, [root.val], sum)] while stack: cur, path, sum = stack.pop() if self.is_leaf(cur) and cur.val==sum: res.append(path) if cur.right: stack.append((cur.right, path+[cur.right.val], sum-cur.val)) if cur.left: stack.append((cur.left, path+[cur.left.val], sum-cur.val)) return res def is_leaf(self, node): if node.left is None and node.right is None: return True else: return False recursively. 先找出所有路径，再过滤，实际上和257题一样。不过这并没有把这道题的特性涵盖进去。 1234567891011def pathSum(self, root, sum_val): paths = self.all_paths(root) return [path for path in paths if sum(path)==sum_val] def all_paths(self, root): if not root: return [] return [[root.val]+path for kid in (root.left, root.right) if kid for path in self.all_paths(kid)] or [[root.val]] recursively. 123456789def pathSum(self, root, sum): if not root: return [] val, *kids = root.val, root.left, root.right if any(kids): return [[val] + path for kid in kids if kid for path in self.pathSum(kid, sum-val)] return [[val]] if val==sum else [] 297. Serialize and Deserialize Binary Tree序列化反序列化二叉树。原题1234567891011121314151617181920class Codec: def serialize(self, root): if not root: return '$' else: return str(root.val) + ',' + self.serialize(root.left) + ',' + self.serialize(root.right) def deserialize(self, data): nodes_val = data.split(',') return self.deserialize_tree(nodes_val) def deserialize_tree(self, vals): val = vals.pop(0) if val == '$': return None cur = TreeNode(val) cur.left = self.deserialize_tree(vals) cur.right = self.deserialize_tree(vals) return cur 一开始的时候反序列化是这样写的，然后调试的时候发现这样写不对，因为这样写的话左子树和右子树变成一样了。CSDN上找到了一个答案。剑指offer：序列化二叉树（Python)。于是将其修改为上面部分。 123456789def deserialize(self, data): nodes_val = data.split(',') cur_val = nodes_val.pop(0) if cur_val == '$': return None cur = TreeNode(cur_val) cur.left = self.deserialize(','.join(nodes_val)) cur.right = self.deserialize(','.join(nodes_val)) return cur]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
        <tag>algorithm</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode算法题整理（动态规划篇）Danymic Programming]]></title>
    <url>%2FLeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AF%87%EF%BC%89Danymic-Programming%2F</url>
    <content type="text"><![CDATA[70. Climbing Stairs爬楼梯，一次可以爬一阶或两阶楼梯，爬上n阶楼梯有多少种方法？原题 斐波那契问题 12345def fibonacci(n): a = b = 1 for _ in range(n-1): a, b = b, a+b return b 121. Best Time to Buy and Sell Stock买入卖出最大收益。原题1234Input: [7,1,5,3,6,4]Output: 5Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5. Not 7-1 = 6, as selling price needs to be larger than buying price. 123456789101112def max_profit(prices): if not prices: return 0 max_profit = 0 n = len(prices) min_buy = prices[0] for i in range(1, n): cur_profit = prices[i] - min_buy max_profit = max(cur_profit, max_profit) if prices[i] &lt; min_buy: min_buy = prices[i] return max_profit 122. Best Time to Buy and Sell Stock II买入卖出，允许多次交易。原题1234Input: [7,1,5,3,6,4]Output: 7Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4. Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3. 思路：比较每两天的价格，如果是涨价了，那就把收益计算进去，否则不出手交易。 123456def max_profit(prices): profit = 0 for i in range(1, len(prices)): if prices[i] &gt; prices[i-1]: profit += prices[i] - prices[i-1] return profit]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
        <tag>algorithm</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode算法题整理（字符串篇）String]]></title>
    <url>%2FLeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AF%87%EF%BC%89String%2F</url>
    <content type="text"><![CDATA[14. Longest Common Prefix返回最长公共前缀字符串。原题 12Input: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]Output: &quot;fl&quot; 123456def longest_common_prefix(strs): if not strs: return '' from itertools import takewhile max_pre_len = len(list(takewhile(lambda x: len(set(x))==1, zip(*strs)))) return strs[0][:max_pre_len] 20. Valid Parentheses判断括号是否成对出现，并且嵌套正确。原题 1234Input: &quot;()[]&#123;&#125;&quot;Output: trueInput: &quot;&#123;[]&#125;&quot;Output: true 12345678910111213def is_valid(s): pairs = &#123;')': '(', '&#125;': '&#123;', ']': '['&#125; stack = [] for paren in s: if paren in pairs.values(): stack.append(paren) elif paren in pairs.keys(): if stack == [] or stack.pop() != pairs[paren]: return False else: return False return stack == [] 28. Implement strStr()实现index。原题12Input: haystack = &quot;hello&quot;, needle = &quot;ll&quot;Output: 2 12345678def str_index(haystack, needle): h = len(haystack) n = len(needle) for i in range(h-n+1): if haystack[i:i+n] == needle: return i else: return -1 38. Count and Say原题123451. 12. 113. 214. 12115. 111221 12345678910def count_and_say(n): from itertools import groupby result = '1' for _ in range(n-1): v = '' for digit, group in groupby(result): count = len(list(group)) v += '&#123;:d&#125;&#123;:s&#125;'.format(count, digit) result = v return result 125. Valid Palindrome验证回文字符串，只判断字母数字，忽略大小写。原题12Input: &quot;A man, a plan, a canal: Panama&quot;Output: true 方法一：切片 123def is_palindrome(s): s_filtered = ''.join(filter(str.isalnum, s.lower())) return s_filtered == s_filtered[::-1] 方法二：双指针 123456789101112def is_palindrome(s): l, r = 0, len(s)-1 while l &lt; r: while l &lt; r and not s[l].isalnum(): l += 1 while l &lt; r and not s[r].isalnum(): r -= 1 if s[l].lower() != s[r].lower(): return False l += 1 r -= 1 return True 151. Reverse Words in a String倒置一句话中的单词。原题12Input: &quot;the sky is blue&quot;,Output: &quot;blue is sky the&quot;. 12def reverse_words(s): return ' '.join(s.split()[::-1]) 344. Reverse String倒置字符串。原题12Input: &quot;A man, a plan, a canal: Panama&quot;Output: &quot;amanaP :lanac a ,nalp a ,nam A&quot; 123456def reverse_str(s): n = len(s) res = list(s) for i in range(n//2): res[i], res[n-i-1] = res[n-i-1], res[i] return ''.join(res) 242. Valid Anagram验证回文构词法，即两个字符串由同样个数的字符组成。原题12Input: s = &quot;anagram&quot;, t = &quot;nagaram&quot;Output: true 方法一： sort 12def is_anagram(s, t): return sorted(s) == sorted(t) 方法二：Counter 12345def is_anagram(s, t): from collections import Counter c1 = Counter(s) c2 = Counter(t) return c1 == c2]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
        <tag>algorithm</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode算法题整理（数学篇）Math]]></title>
    <url>%2FLeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E6%95%B0%E5%AD%A6%E7%AF%87%EF%BC%89Math%2F</url>
    <content type="text"><![CDATA[7. Reverse Integer倒置一个整数， 此答案忽略了原题中的范围判断。原题12Input: -123Output: -321 方法一：str 12345def reverse_int(x): if x &gt;= 0: return int(str(x)[::-1]) else: return -int(str(x)[:0:-1]) 方法二：math 1234567891011def reverse_int(x): if x &gt;= 0: fill_symbol = 1 else: fill_symbol = -1 result = 0 tail = abs(x) while tail: result = result*10 + tail%10 tail //= 10 return result * fill_symbol 9. Palindrome Number判断一个数是否是回文数，这里把负数认为是不符合条件的。原题方法一：str 12def is_palindrome(x): return str(x) == str(x)[::-1] 方法二：math 123456def is_palindrome(x): l, r = x, 0 while l &gt; 0: r = r*10 + l%10 l //= 10 return r == x 13. Roman to Integer罗马数字转换整型。原题12345678910def roman_to_int(s): roman = &#123;'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000&#125; total = 0 for i in range(len(s)): if i == len(s)-1 or roman[s[i]] &gt;= roman[s[i+1]] total += roman[s[i]] else: total -= roman[s[i]] return total 69. Sqrt(x)实现开方，返回整数部分。原题1234Input: 8Output: 2Explanation: The square root of 8 is 2.82842..., and since the decimal part is truncated, 2 is returned. 牛顿迭代法 12345def my_sqrt(x): r = x while r**2 &gt; x: r = (r+x/r) // 2 return r 136. Single Number找出数组中不重复的元素。原题12Input: [4,1,2,1,2]Output: 4 123def single_num(nums): from itertools import reduce return reduce(lambda x, y: x ^ y, nums) 171. Excel Sheet Column Numberexcel表格列表数字转换，二十六进制。原题1234567A -&gt; 1B -&gt; 2C -&gt; 3...Z -&gt; 26AA -&gt; 27AB -&gt; 28 A -&gt; 1 12def title2number(s): return sum([(ord(x)-64) * 26 ** i for i, x in enumerate(s[::-1])]) 172. Factorial Trailing Zeroes求n的阶乘末尾有几个0。原题123Input: 5Output: 1Explanation: 5! = 120, one trailing zero. 思路：每一对2和5可以产生一个0，在n的阶乘中，5比2多，所以问题变成求5的个数，而25这种数有两个5，所以递归求解 12def trailing_zeroes(n): return 0 if n == 0 else n//5 + trailing_zeroes(n//5) 204. Count Primes求小于n的整数中，有多少个质数。原题123456def countPrimes(self, n): is_prime = [False]*2 + [True]*(n-2) for i in range(2, int(n ** 0.5)+1): if is_prime[i]: is_prime[i*i:n:i] = [False] * len(is_prime[i*i:n:i]) return sum(is_prime) 50. Pow(x, n)实现pow函数。原题12345Input: 2.00000, 10Output: 1024.00000Input: 2.00000, -2Output: 0.25000 . 说明：常规方法在Leetcode 上内存会爆掉。 123456789101112131415161718192021class Solution(object): def myPow(self, x, n): if n &lt; 0: return 1 / self.pow_with_unsigned(x, -n) else: return self.pow_with_unsigned(x, n) def pow_with_unsigned(self, x, n): if n == 1: return x if n == 0: return 1 res = self.pow_with_unsigned(x, n &gt;&gt; 1) res *= res if n &amp; 1 == 1: res *= x return res]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
        <tag>algorithm</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode算法题整理（数组篇）Array]]></title>
    <url>%2FLeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E6%95%B0%E7%BB%84%E7%AF%87%EF%BC%89Array%2F</url>
    <content type="text"><![CDATA[1. Two Sum给定一个数组，找出数组两个元素相加为目标值，假定只有唯一解。原题123Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. 1234567def two_sum(nums, target): buff_dict = &#123;&#125; for i, num in enumerate(nums): if num not in buff_dict: buff_dict[target-num] = i else: return [buff_dict[num], i] 26. Remove Duplicates from Sorted Array删除排序数组中重复的元素, 使用build-in在原数组上操作，返回一个长度，标识前n个元素为目标数组。原题12345Given nums = [0,0,1,1,1,2,2,3,3,4],Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.It doesn&apos;t matter what values are set beyond the returned length. 1234567def remove_duplicates(nums): index = 1 for i in range(len(nums)-1): if nums[i] != nums[i+1] nums[index] = nums[i+1] index += 1 return index 66. Plus One给数组加一，元素为非负整数，不以0开头。原题123Input: [4,3,2,1]Output: [4,3,2,2]Explanation: The array represents the integer 4321. 方法一：转成字符串再转成数字 1234def plus_one(digits): str_digits = ''.join(map(str, digits)) plused = int(str_digits) + 1 return [int(x) for x in str(plused)] 方法二：Math 进位 123456789101112def plus_one(digits): d = digits[:] plused = [] carry = 1 while d or carry: if d: v = d.pop() else: v = 0 carry, val = divmod(carry+v, 10) plused.append(val) return plused[::-1] 88. Merge Sorted Array合并两个有序数组，在nums1上修改。原题12345Input:nums1 = [1,2,3,0,0,0], m = 3nums2 = [2,5,6], n = 3Output: [1,2,2,3,5,6] 12345678910def merge(self, nums1, m, nums2, n): while m&gt;0 and n&gt;0: if nums1[m-1] &gt; nums2[n-1]: nums1[n+m-1] = nums1[m-1] m -= 1 else: nums1[n+m-1] = nums2[n-1] n -= 1 if n &gt; 0: nums1[:n] = nums2[:n] 118. Pascal’s Triangle杨辉三角。原题123456789Input: 5Output:[ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1]] 方法一 12345def pascal(num): res = [[1]] for _ in range(1, num): res += [list(map(lambda x, y: x+y, res[-1]+[0], [0]+res[-1]))] return res[:num] 方法二 123456789def generate(num): triangle = [] inner = [1] for _ in range(num): triangle.append(list(inner)) inner.append(0) right = [inner[i]+inner[i+1] for i in range(len(inner)-1)] inner = [1] + right return triangle 169. Majority Element找出数组中出现次数超过一半的元素。原题方法一：排序. Time-O(nlogn), Space-O(n) 12def majority_element(nums): return sorted(nums)[len(nums)//2] 方法二：Counter Time-O(n), Space-O(n) 12345def majority_element(nums): from collections import Counter c = Counter(nums) # return max(c.keys(), key=c.get) return c.most_common(1)[0][0] 方法三：Boyer-Moore Voting Algorithm. 书中的算法说的就是这个，这里附上自己的见解。 波义尔摩尔投票算法 12345678def majorityElement(self, nums): count = 0 candidate = None for num in nums: if count == 0: candidate = num count += (1 if num == candidate else -1) return candidate 189. Rotate Array旋转数组。原题123456Input: [1,2,3,4,5,6,7] and k = 3Output: [5,6,7,1,2,3,4]Explanation:rotate 1 steps to the right: [7,1,2,3,4,5,6]rotate 2 steps to the right: [6,7,1,2,3,4,5]rotate 3 steps to the right: [5,6,7,1,2,3,4] 方法一：slicing 123def rotate(nums, k): k = k % len(nums) nums[:] = nums[-k:] + nums[:-k] 方法二：stack 123def rotate(nums, k): for _ in range(k): nums.insert(0, nums.pop()) 217. Contains Duplicate数组中是否包含重复元素。原题12Input: [1,2,3,1]Output: true 方法一：set 12def contains_duplicate(nums): return len(set(nums)) &lt; len(nums) 方法二：hash 12345678def contains_duplicate(nums): existed = &#123;&#125; for num in nums: if num in existed: return True else: existed[num] = None return False 219. Contains Duplicate II数组中是否包含重复元素，且元素下标差小于等于k。原题1234Input: nums = [1,2,3,1], k = 3Output: trueInput: nums = [1,0,1,1], k = 1Output: true 思路：开始想用set作切片来判断，同上题方法一，但是效率太低。故使用字典。 123456789def containsNearbyDuplicate(self, nums, k): n = len(nums) existed = &#123;&#125; for i, num in enumerate(nums): if num in existed: if i-existed[num] &lt;= k: return True existed[num] = i return False 283. Move Zeroes将数组0元素移动到末尾。原题12Input: [0,1,0,3,12]Output: [1,3,12,0,0] 方法一：two pointers 12345678def move_zero(nums): l, r = 0, len(nums)-1 while l &lt; r: if nums[l] == 0: nums[:] = nums[:l] + nums[l+1:] + [0] r -= 1 else: l += 1 方法二： slicing 12def move_zero(nums): nums[:] = [x for x in nums if x != 0] + [x for x in nums if x == 0] 54. Spiral Matrix螺旋矩阵，顺时针打印矩阵。原题这里注意一点matrix.pop(0)需要转成list，因为zip函数中的每个元素是一个tuple，如果不转变成了一个tuple+list，会抛出异常。 ps: 此题解法为LeetCode一位大神，经常能看到此人的答案，不过这个是我认为最pythonic的一个，没有为了强行one-line而one-line。brilliant! 1TypeError: can only concatenate tuple (not &quot;list&quot;) to tuple 12def spiralOrder(self, matrix): return matrix and list(matrix.pop(0))+self.spiralOrder(list(zip(*matrix))[::-1]) 46. Permutations数组全排列。原题12345678910Input: [1,2,3]Output:[ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]] recursively. 思想为拿出一个数字作为头部，剩下的递归。 1234def permute(self, nums): return [[n] + p for i, n in enumerate(nums) for p in self.permute(nums[:i]+nums[i+1:])] or [[]] iteratively. 思想为拿出一个数字插入到现有排序中的各个位置。 1234567def permute(self, nums): ans = [[]] for n in nums: ans = [l[:i] + [n] + l[i:] for l in ans for i in range(len(l)+1)] return ans 47. Permutations II全排列并去重。原题思路：当然可以使用set来去重，或者考虑一种迭代的方式。 展开。拿着每个数字向上一个结果中插入到每一个位置。 123456789101112131415def permuteUnique(self, nums): ans = [[]] for j, n in enumerate(nums): new_ans = [] for l in ans: for i in range(len(l)+1): new_ans.append(l[:i]+[n]+l[i:]) print('\t j &#123;0&#125; - &#123;3&#125; + [&#123;2&#125;] + &#123;4&#125;'.format(j, i, n, l[:i], l[i:])) # if i&lt;len(l) and l[i]==n: break #handles duplication if i&lt;len(l) and l[i]==n: print('\t \t l[&#123;&#125;] == &#123;&#125;'.format(i, n)) break #handles duplication ans = new_ans print('j &#123;&#125; afer inner ans &#123;&#125;'.format(j, ans)) return ans 输入nums=[1, 2, 3] 123456789101112 j 0 - [] + [1] + []j 0 afer inner ans [[1]] j 1 - [] + [2] + [1] j 1 - [1] + [2] + []j 1 afer inner ans [[2, 1], [1, 2]] j 2 - [] + [3] + [2, 1] j 2 - [2] + [3] + [1] j 2 - [2, 1] + [3] + [] j 2 - [] + [3] + [1, 2] j 2 - [1] + [3] + [2] j 2 - [1, 2] + [3] + []j 2 afer inner ans [[3, 2, 1], [2, 3, 1], [2, 1, 3], [3, 1, 2], [1, 3, 2], [1, 2, 3]] 理解一下是如何去重的，我们输入nums=[1, 2, 1] 123456789101112 j 0 - [] + [1] + []j 0 afer inner ans [[1]] j 1 - [] + [2] + [1] j 1 - [1] + [2] + []j 1 afer inner ans [[2, 1], [1, 2]] j 2 - [] + [1] + [2, 1] j 2 - [2] + [1] + [1] l[1] == 1 j 2 - [] + [1] + [1, 2] l[0] == 1j 2 afer inner ans [[1, 2, 1], [2, 1, 1], [1, 1, 2]][[1, 2, 1], [2, 1, 1], [1, 1, 2]] 列表生成式整合。Stefan大神的写法。使用index来找非重复的临界值。 1234567def permuteUnique(self, nums): ans = [[]] for n in nums: ans = [l[:i]+[n]+l[i:] for l in ans for i in range((l+[n]).index(n)+1)] return ans]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
        <tag>algorithm</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode算法题整理（链表篇）LinkedList]]></title>
    <url>%2FLeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E9%93%BE%E8%A1%A8%E7%AF%87%EF%BC%89LinkedList%2F</url>
    <content type="text"><![CDATA[链表的定义1234class ListNode: def __init__(self, x): self.val = x self.next = None 2. Add Two Numbers两个链表相加123Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8Explanation: 342 + 465 = 807. 123456789101112131415def addTwoNumbers(l1, l2): l = head = ListNode(0) carry = 0 while l1 or l2 or carry: v1 = v2 = 0 if l1: v1 = l1.val l1 = l1.next if l2: v2 = l2.val l2 = l2.next carry, val = divmod(sum(v1+v2+carry), 10) l.next = ListNode(val) l = l.next return head.next 21. Merge Two Sorted Lists合并两个有序链表。原题12Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 方法1：iteratively 迭代 123456789101112def mergeTwoLists(l1, l2): l = head = ListNode(0) while l1 and l2: if l1.val &lt;= l2.val: l.next = l1 l1 = l1.next else: l.next = l2 l2= l2.next l = l.next l.next = l1 or l2 return head.next 方法2：recursively 递归 12345678910def mergeTwoLists(l1, l2): # 判断是否存在None if not l1 or not l2: return l1 or l2 if l1.val &lt; l2.val: l1.next = mergeTwoLists(l1.next, l2) return l1 else: l2.next = mergeTwoLists(l1, l2.next) return l2 237. Delete Node in a Linked List在链表中删除节点。给定的节点不是尾节点。原题12Input: head = [4,5,1,9], node = 5Output: [4,1,9] 开始看到这题的思路是，要是能拿到父节点就好了，然后这道题需要别的思路，其关键在于复制 123def deleteNode(self, node): node.val = node.next.val # 4-&gt;1-&gt;1-&gt;9 node.next = nede.next.next # 4-&gt;1-&gt;9 141. Linked List Cycle判断一个链表是否有环。原题经典的一道题，看成两个人在赛跑，如果有环，快的人会和慢的人相遇 12345678def hasCycle(self, head): slow = fast = head: while fast and fast.next: fast = fast.next.next slow = slow.next if fast is slow: return True return False 206. Reverse Linked List倒置一个链表。原题12Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULLOutput: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 方法一： iteratively12345678def reverseList(head): prev = None while head: cur = head head = head.next cur.next = prev prev = cur return prev 方法二：使用一行赋值 12345def reverseList(self, head): prev = None while head: head.next, prev, head = prev, head, head.next return prev 这个方法有些不明白的地方，后续会更新一篇文章研究它。 160. Intersection of Two Linked Lists两个链表求相交。原题1234567def getIntersectionNode(self, headA, headB): p1 = headA p2 = headB while p1 is not p2: p1 = p1.next if p1 else headB p2 = p2.next if p2 else headA return p1 83. Remove Duplicates from Sorted List删除有序链表中重复的节点。原题12345678def delete_duplicates(head): root = head while head and head.next: if head.val == head.next.val: head.next = head.next.next else: head = head.next return root 142. Linked List Cycle II求链表中环的入口节点。原题 首先判断此链表是否有环。 然后在相交点和头结点一起走，一定会在入口相遇。 Consider the following linked list, where E is the cylce entry and X, the crossing point of fast and slow. H: distance from head to cycle entry E D: distance from E to X L: cycle length _____ / \ head_____H______E \ \ / X_____/ If fast and slow both start at head, when fast catches slow, slow has traveled H+D and fast 2(H+D). Assume fast has traveled n loops in the cycle, we have: 2H + 2D = H + D + L --&gt; H + D = nL --&gt; H = nL - D Thus if two pointers start from head and X, respectively, one first reaches E, the other also reaches E. In my solution, since fast starts at head.next, we need to move slow one step forward in the beginning of part 2 1234567891011121314151617class Solution(object): def detectCycle(self, head): fast = slow = head # 检测是否有环 while fast and fast.next: slow = slow.next fast = fast.next.next if slow is fast: break else: return None # 找出入口节点 while head is not slow: head = head.next slow = slow.next return head 138. Copy List with Random Pointer深拷贝一个复杂链表，链表多包含了一个随机指针。原题 Time-O(2n), Memory-O(n). 12345678910111213def copyRandomList(self, head): cp_map = &#123;&#125; m = n = head while m: cp_map[m] = RandomListNode(m.label) m = m.next while n: cp_map[n].next = cp_map.get(n.next) cp_map[n].random = cp_map.get(n.random) n = n.next return cp_map.get(head) Time-O(n), Memory-O(n). 这种方式是相当于把第一次迭代的过程委托给了defaultdict，通过创建一个默认的对象，再去修改它的label值。 1234567891011def copyRandomList(self, head): from collections import defaultdict cp = defaultdict(lambda: RandomListNode(0)) cp[None] = None n = head while n: cp[n].label = n.label cp[n].next = cp[n.next] cp[n].random = cp[n.random] n = n.next return cp[head]]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
        <tag>algorithm</tag>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo搭建遇到的问题及优化]]></title>
    <url>%2Fhexo%E6%90%AD%E5%BB%BA%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[前言终于有了一个整理自己学习笔记的地方了，之前用过印象笔记，觉得它的markdown格式处理得不是很完美，复制粘贴出来总是格式不对。后来又用过jupyter_nootboke，但是不方便在其它客户端查看。折腾了半天终于弄好了期间遇到过不少坑，发现hexo有时候同一样的问题总是对应着几种不同的解决方法，在此整理一下以便之后遇到问题。 关于问题NexT这里使用了next主题，这个主题特别简洁，还有很多易用性的扩展，尤其侧边栏的快速定位，让我爱不释手。 头像不显示开始按照_config.yml中所说把avatar.gif放到blog-site/source/下，没有任何的作用。后来发现是主题的原因，放到themes/next/source/images/下就好了，默认的头像是正方形的，这里修改了一下代码把它改成圆形，文件位置在themes/next/source/css_common_components/sidebar/sidebar-author.styl 1234567891011121314.site-author-image &#123; display: block; margin: 0 auto; max-width: 96px; height: auto; border: 2px solid #333; padding: 2px; /* start*/ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px; box-shadow: inset 0 -1px 0 #333sf; /* end */&#125; 网页图标favicon.ico不显示这里也是因为Next的原因，把favicon.ico放到themes/next/source/images/下，然后修改_config.yml中favicon: /images/favicon.ico解决了问题。这里介绍一个很方便转换ico的网站favicon在线制作。 没有建立资源文件夹 设置post_asset_foler: true之后执行hexo new post_name后没有建立资源文件夹。搜索没有查到相关记录，后来想到之前next主题设置时，把配置文件拆分了出来，这样每次执行hexo clean/generate的时候在后面加了参数--config指定了配置文件。但是这样修改的文件对于hexo new post_name来说是没有修过的，所以要在source/_config.yml修改这项参数。 之后没有选择官方的标签插件是因为，在编辑markdown时无法看到预览效果所以安装npm install https://github.com/CodeFalling/hexo-asset-image --save，在文章中使用markdown语法引用![logo](&lt;title_name&gt;/a.png)使用。 选择官方的标签插件引用图片。 关于优化在右上角或者左上角实现fork me on github在这里选择喜欢的样式。这里选择的是 1&lt;a href="https://your-url" class="github-corner" aria-label="View source on Github"&gt;&lt;svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"&gt;&lt;path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"&gt;&lt;/path&gt;&lt;path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"&gt;&lt;/path&gt;&lt;path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;&lt;style&gt;.github-corner:hover .octo-arm&#123;animation:octocat-wave 560ms ease-in-out&#125;@keyframes octocat-wave&#123;0%,100%&#123;transform:rotate(0)&#125;20%,60%&#123;transform:rotate(-25deg)&#125;40%,80%&#123;transform:rotate(10deg)&#125;&#125;@media (max-width:500px)&#123;.github-corner:hover .octo-arm&#123;animation:none&#125;.github-corner .octo-arm&#123;animation:octocat-wave 560ms ease-in-out&#125;&#125;&lt;/style&gt; 将其粘贴到themes/next/layout/_layout.swig中，放在div class=&quot;headhand&quot;&gt;&lt;/div&gt;下面。 修改文章底部的那个带#号的标签修改模板/themes/next/layout/_macro/post.swig，搜索rel=&quot;tag&quot;&gt;#，将#换成&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt; 侧边栏社交小图标设置在配置文件搜索social_icons，把值换成喜欢的图标名字，这里列出了图标库 在网站底部加上访问量打开/themes/next/layout/_partials/footer.swig文件添加红框内的代码 1&lt;script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"&gt;&lt;/script&gt; 添加统计代码如下位置 12345&lt;div class="powered-by"&gt;&lt;i class="fa fa-user-md"&gt;&lt;/i&gt;&lt;span id="busuanzi_container_site_uv"&gt; 本站访客数:&lt;span id="busuanzi_value_site_uv"&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt; 网站底部字数统计根目录安装npm install hexo-wordcount --save然后再/themes/next/layout/_partials/footer.swig文件最后加上 1234&lt;div class=&quot;theme-info&quot;&gt; &lt;div class=&quot;powered-by&quot;&gt;&lt;/div&gt; &lt;span class=&quot;post-count&quot;&gt;博客全站共&#123;&#123; totalcount(site) &#125;&#125;字&lt;/span&gt;&lt;/div&gt; 添加顶部加载条_config.yml设置中pace:true 在文章底部增加版权信息在目录themes/next/layout/_macro/下添加my-copyright.swig: 123456789101112131415161718192021222324252627282930&#123;% if page.copyright %&#125;&lt;div class="my_post_copyright"&gt; &lt;script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"&gt;&lt;/script&gt; &lt;!-- JS库 sweetalert 可修改路径 --&gt; &lt;script src="https://cdn.bootcss.com/jquery/2.0.0/jquery.min.js"&gt;&lt;/script&gt; &lt;script src="https://unpkg.com/sweetalert/dist/sweetalert.min.js"&gt;&lt;/script&gt; &lt;p&gt;&lt;span&gt;本文标题:&lt;/span&gt;&lt;a href="&#123;&#123; url_for(page.path) &#125;&#125;"&gt;&#123;&#123; page.title &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;文章作者:&lt;/span&gt;&lt;a href="/" title="访问 &#123;&#123; theme.author &#125;&#125; 的个人博客"&gt;&#123;&#123; theme.author &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;发布时间:&lt;/span&gt;&#123;&#123; page.date.format("YYYY年MM月DD日 - HH:MM") &#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;span&gt;最后更新:&lt;/span&gt;&#123;&#123; page.updated.format("YYYY年MM月DD日 - HH:MM") &#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;span&gt;原始链接:&lt;/span&gt;&lt;a href="&#123;&#123; url_for(page.path) &#125;&#125;" title="&#123;&#123; page.title &#125;&#125;"&gt;&#123;&#123; page.permalink &#125;&#125;&lt;/a&gt; &lt;span class="copy-path" title="点击复制文章链接"&gt;&lt;i class="fa fa-clipboard" data-clipboard-text="&#123;&#123; page.permalink &#125;&#125;" aria-label="复制成功！"&gt;&lt;/i&gt;&lt;/span&gt; &lt;/p&gt; &lt;p&gt;&lt;span&gt;许可协议:&lt;/span&gt;&lt;i class="fa fa-creative-commons"&gt;&lt;/i&gt; &lt;a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)"&gt;署名-非商业性使用-禁止演绎 4.0 国际&lt;/a&gt; 转载请保留原文链接及作者。&lt;/p&gt; &lt;/div&gt;&lt;script&gt; var clipboard = new Clipboard('.fa-clipboard'); $(".fa-clipboard").click(function()&#123; clipboard.on('success', function()&#123; swal(&#123; title: "", text: '复制成功', icon: "success", showConfirmButton: true &#125;); &#125;); &#125;); &lt;/script&gt;&#123;% endif %&#125; 在目录themes/next/source/css/_common/components/post/下添加my-post-copyright.styl: 123456789101112131415161718192021222324252627282930313233343536373839404142434445.my_post_copyright &#123; width: 85%; max-width: 45em; margin: 2.8em auto 0; padding: 0.5em 1.0em; border: 1px solid #d3d3d3; font-size: 0.93rem; line-height: 1.6em; word-break: break-all; background: rgba(255,255,255,0.4);&#125;.my_post_copyright p&#123;margin:0;&#125;.my_post_copyright span &#123; display: inline-block; width: 5.2em; color: #b5b5b5; font-weight: bold;&#125;.my_post_copyright .raw &#123; margin-left: 1em; width: 5em;&#125;.my_post_copyright a &#123; color: #808080; border-bottom:0;&#125;.my_post_copyright a:hover &#123; color: #a3d2a3; text-decoration: underline;&#125;.my_post_copyright:hover .fa-clipboard &#123; color: #000;&#125;.my_post_copyright .post-url:hover &#123; font-weight: normal;&#125;.my_post_copyright .copy-path &#123; margin-left: 1em; width: 1em; +mobile()&#123;display:none;&#125;&#125;.my_post_copyright .copy-path:hover &#123; color: #808080; cursor: pointer;&#125; 修改/themes/next/layout/_macro/post.swig在如下位置 添加代码：(注意和之前的教程不一样，这里可能是next的更新了，所以要把代码放到外面，否则在wechat_subscriber未开启时会导致失效。) 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'my-copyright.swig' %&#125; &#123;% endif %&#125;&lt;/div&gt; 修改themes/next/source/css/_common/components/post/post.styl末尾增加一行1@import &quot;my-post-copyright&quot; 博文置顶替换node_modules/hexo-generator-index/lib/generator.js所有的代码为： 12345678910111213141516171819202122232425262728'use strict';var pagination = require('hexo-pagination');module.exports = function(locals)&#123; var config = this.config; var posts = locals.posts; posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义 if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排 else return b.top - a.top; // 否则按照top值降序排 &#125; else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233） return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; // 都没定义按照文章日期降序排 &#125;); var paginationDir = config.pagination_dir || 'page'; return pagination('', posts, &#123; perPage: config.index_generator.per_page, layout: ['index', 'archive'], format: paginationDir + '/%d/', data: &#123; __index: true &#125; &#125;);&#125;; 使用：在头部添加top 12345678---title: date: 2017-05-22 22:45:48tags: 技巧categories: 技巧copyright: truetop: 100--- 修改字体大小/themes/next/source/css/_variables/base.styl搜索font-size-base 设置阅读次数添加阅读量统计 添加搜索12local_search: enable: true SEO优化两个搜索引擎入口： 谷歌搜索引擎验证 百度搜索引擎验证 这里选择用下载文件的方式，将文件放到source/目录下，注意一点应该在文件前添加两行代码，防止hexo将其格式化 12layout: false--- 生成站点地图 sitemap 站点地图是一种文件，您可以通过该文件列出您网站上的网页，从而将您网站内容的组织架构告知Google和其他搜索引擎。Googlebot等搜索引擎网页抓取工具会读取此文件，以便更加智能地抓取您的网站。 12npm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save 更改配置 12345# 自动生成sitemapsitemap: path: sitemap.xmlbaidusitemap: path: baidusitemap.xml 使搜索引擎收录我们的博客 谷歌比较简单向谷歌站长工具提交sitemap 百度。参考Hexo插件之百度主动提交链接 网站自身优化给出站链接添加 “nofollow” 标签/themes/next/layout/_partials/footer.swig找到下面两行，分别在a标签中添加rel=&quot;texternal nofollow&quot;属性 同样在/themes/next/layout/_macor/sidebar.swig中添加这个属性 设置更改属性seo: true 缩短文章链接编辑配置文件permalink: :title.html 添加文章更新时间参考了hexo添加文章更新时间 首先找到/themes/next/layout/_macro/post.swig文件，在&lt;span class=&quot;post-time&quot;&gt;...&lt;/span&gt;后添加： 12345678&#123;%if post.updated and post.updated &gt; post.date%&#125; &lt;span class="post-updated"&gt; &amp;nbsp; | &amp;nbsp; &#123;&#123; __('Updated on') &#125;&#125; &lt;time itemprop="dateUpdated" datetime="&#123;&#123; moment(post.updated).format() &#125;&#125;" content="&#123;&#123; date(post.updated, config.date_format) &#125;&#125;"&gt; &#123;&#123; date(post.updated, config.date_format) &#125;&#125; &lt;/time&gt; &lt;/span&gt;&#123;% endif %&#125; 博主这里改了一下显式的文本，后面的语言配置没有配，如果想手动更改文章更新时间在文章前加上： 1updated: 2018-01-01 12:00:00 默认使用md的修改时间。 文章添加阴影效果找到文件themes/next/source/css/_custom/custom.styl，添加如下代码。 12345678// 主页文章添加阴影效果.post &#123; margin-top: 0px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5);&#125;]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
