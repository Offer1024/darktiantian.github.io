<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python排序算法]]></title>
    <url>%2FPython%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[快速排序 12345678910111213def quick_sorted(nums): if nums &lt; 2: return nums pivot = nums[0] small, medium, large = [], [], [] for num in nums: if num &lt; pivot: small.append(num) elif num &gt; pivot: large.append(num) else: medium.append(num) return quick_sort(small) + medium + quick_sort(large) 冒泡排序123456789101112def bubble_sorted(nums): res = list(nums) n = len(res) for i in range(n-1, 0, -1): flag = True for j in range(0, i): if res[j] &gt; res[j+1]: res[j], res[j+1] = res[j+1], res[j] flag = False if flag: return res return res 选择排序12345678910def select_sorted(nums): res = list(nums) n = len(res) for i in range(n-1): min_i = i for j in range(i+1, n): if res[min_i] &gt; res[j]: min_i = j res[min_i], res[i] = res[i], res[min_i] return res 插入排序 1234567891011121314def inset_sorted(nums): res = list(nums) n = len(res) for i in range(1, n): val = res[i] # 待插入值 index = i # 待插入下标 for j in range(i-1, -1, -1): if res[j] &gt; val: res[j+1] = res[j] index = j else: break res[index] = val return res 希尔排序一直觉得网上的希尔排序方式不够pythonic，这里写了一个调用插入排序的方法。 123456789def shell_sorted(nums): res = list(nums) n = len(res) step = round(n/2) while step &gt; 0: for i in range(step): res[i:n:step] = insert_sorted(res[i:n:step]) step = round(step/2) return res]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>algorithm</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode算法题整理（设计篇）Design]]></title>
    <url>%2FLeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E8%AE%BE%E8%AE%A1%E7%AF%87%EF%BC%89Design%2F</url>
    <content type="text"><![CDATA[155. Min Stack设计一个栈，要求在常数时间复杂度取出最小值。原题 12345678MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin(); --&gt; Returns -3.minStack.pop();minStack.top(); --&gt; Returns 0.minStack.getMin(); --&gt; Returns -2. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class MinStack: def __init__(self): """ initialize your data structure here. """ self._stack = [] def push(self, x): """ :type x: int :rtype: void """ prev = self.getMin() if prev is None or x &lt; prev: prev = x self._stack.append((x, prev)) def pop(self): """ :rtype: void """ self._stack.pop() def top(self): """ :rtype: int """ if len(self._stack) == 0: return None return self._stack[-1][0] def getMin(self): """ :rtype: int """ if len(self._stack) == 0: return None return self._stack[-1][1] # Your MinStack object will be instantiated and called as such:# obj = MinStack()# obj.push(x)# obj.pop()# param_3 = obj.top()# param_4 = obj.getMin()]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
        <tag>algorithm</tag>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode算法题整理（二叉树篇）Tree]]></title>
    <url>%2FLeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AF%87%EF%BC%89Tree%2F</url>
    <content type="text"><![CDATA[树的定义12345class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None 144. Binary Tree Preorder Traversal二叉树前序遍历12345678Input: [1,null,2,3] 1 \ 2 / 3Output: [1,2,3] 方法一：iteratively 123456789def preorder_traversal(root): nodes = [root] res = [] while nodes: cur_node = nodes.pop(0) if cur_node: res.append(cur_node.val) nodes = [cur_node.left, cur_node.right] + nodes return res 方法二：recursively 12345def preorder_traversal(root): if not root: return [] return [root.val] + self.preorderTraversal(root.left) \ + self.preorderTraversal(root.right) 94. Binary Tree Inorder Traversal中序遍历二叉树12345678Input: [1,null,2,3] 1 \ 2 / 3Output: [1,3,2] 123456789101112def inorder_traversal(root): stack = [] res = [] while True: while root: stack.append(root) root = root.left if stack == []: return res cur = stack.pop() res.append(cur.val) root = cur.right 145. Binary Tree Postorder Traversal后序遍历二叉树12345678Input: [1,null,2,3] 1 \ 2 / 3Output: [3,2,1] 12345678910def postorder_traversal(root): stack = [root] res = [] while stack: node = stack.pop() if node: res.append(node.val) stack.append(node.left) stack.append(node.right) return res[::-1] 100. Same Tree判断相同的二叉树。原题1234567Input: 1 1 / \ / \ 2 3 2 3 [1,2,3], [1,2,3]Output: true 方法一：recursively 12345def is_same_tree(p, q): if p and q: return p.val == q.val and is_same_tree(p.left, q.left) and is_same_tree(p.right, q.right) else: return p is q 方法二：recursively, tuple 12345def is_same_tree(p, q): def t(n): return n and (n.val, t(n.left), t(n.right) return t(p) == t(q) 101. Symmetric Tree判断二叉树是否对称。原题12345 1 / \ 2 2 / \ / \3 4 4 3 12345678910def is_symmetric(root): if not root: return True return is_pair(root.left, root.right) def is_pair(l1, l2): if l1 and l2: return l1.val == l2.val and is_pair(l1.left, l2.right) and is_pair(l2.left, l1.right) else: return l1 is l2 104. Maximum Depth of Binary Tree二叉树最大深度。原题123456 3 / \ 9 20 / \ 15 7return 3 1234def max_depth(root): if not root: return 0 return max(max_depth(root.left), max_depth(root.right)) + 1]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Tree</tag>
        <tag>LeetCode</tag>
        <tag>Python</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode算法题整理（动态规划篇）Danymic Programming]]></title>
    <url>%2FLeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AF%87%EF%BC%89Danymic-Programming%2F</url>
    <content type="text"><![CDATA[70. Climbing Stairs爬楼梯，一次可以爬一阶或两阶楼梯，爬上n阶楼梯有多少种方法？原题 斐波那契问题12345def fibonacci(n): a = b = 1 for _ in range(n-1): a, b = b, a+b return b 121. Best Time to Buy and Sell Stock买入卖出最大收益。原题1234Input: [7,1,5,3,6,4]Output: 5Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5. Not 7-1 = 6, as selling price needs to be larger than buying price. 123456789101112def max_profit(prices): if not prices: return 0 max_profit = 0 n = len(prices) min_buy = prices[0] for i in range(1, n): cur_profit = prices[i] - min_buy max_profit = max(cur_profit, max_profit) if prices[i] &lt; min_buy: min_buy = prices[i] return max_profit 122. Best Time to Buy and Sell Stock II买入卖出，允许多次交易。原题1234Input: [7,1,5,3,6,4]Output: 7Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4. Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3. 思路：比较每两天的价格，如果是涨价了，那就把收益计算进去，否则不出手交易。 123456def max_profit(prices): profit = 0 for i in range(1, len(prices)): if prices[i] &gt; prices[i-1]: profit += prices[i] - prices[i-1] return profit]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
        <tag>algorithm</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode算法题整理（字符串篇）String]]></title>
    <url>%2FLeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AF%87%EF%BC%89String%2F</url>
    <content type="text"><![CDATA[14. Longest Common Prefix返回最长公共前缀字符串。原题 12Input: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]Output: &quot;fl&quot; 123456def longest_common_prefix(strs): if not strs: return '' from itertools import takewhile max_pre_len = len(list(takewhile(lambda x: len(set(x))==1, zip(*strs)))) return strs[0][:max_pre_len] 20. Valid Parentheses判断括号是否成对出现，并且嵌套正确。原题 1234Input: &quot;()[]&#123;&#125;&quot;Output: trueInput: &quot;&#123;[]&#125;&quot;Output: true 12345678910111213def is_valid(s): pairs = &#123;')': '(', '&#125;': '&#123;', ']': '['&#125; stack = [] for paren in s: if paren in pairs.values(): stack.append(paren) elif paren in pairs.keys(): if stack == [] or stack.pop() != pairs[paren]: return False else: return False return stack == [] 28. Implement strStr()实现index。原题12Input: haystack = &quot;hello&quot;, needle = &quot;ll&quot;Output: 2 12345678def str_index(haystack, needle): h = len(haystack) n = len(needle) for i in range(h-n+1): if haystack[i:i+n] == needle: return i else: return -1 38. Count and Say原题123451. 12. 113. 214. 12115. 111221 12345678910def count_and_say(n): from itertools import groupby result = '1' for _ in range(n-1): v = '' for digit, group in groupby(result): count = len(list(group)) v += '&#123;:d&#125;&#123;:s&#125;'.format(count, digit) result = v return result 125. Valid Palindrome验证回文字符串，只判断字母数字，忽略大小写。原题12Input: &quot;A man, a plan, a canal: Panama&quot;Output: true 方法一：切片 123def is_palindrome(s): s_filtered = ''.join(filter(str.isalnum, s.lower())) return s_filtered == s_filtered[::-1] 方法二：双指针 123456789101112def is_palindrome(s): l, r = 0, len(s)-1 while l &lt; r: while l &lt; r and not s[l].isalnum(): l += 1 while l &lt; r and not s[r].isalnum(): r -= 1 if s[l].lower() != s[r].lower(): return False l += 1 r -= 1 return True 151. Reverse Words in a String倒置一句话中的单词。原题12Input: &quot;the sky is blue&quot;,Output: &quot;blue is sky the&quot;. 12def reverse_words(s): return ' '.join(s.split()[::-1]) 344. Reverse String倒置字符串。原题12Input: &quot;A man, a plan, a canal: Panama&quot;Output: &quot;amanaP :lanac a ,nalp a ,nam A&quot; 123456def reverse_str(s): n = len(s) res = list(s) for i in range(n//2): res[i], res[n-i-1] = res[n-i-1], res[i] return ''.join(res) 242. Valid Anagram验证回文构词法，即两个字符串由同样个数的字符组成。原题12Input: s = &quot;anagram&quot;, t = &quot;nagaram&quot;Output: true 方法一： sort 12def is_anagram(s, t): return sorted(s) == sorted(t) 方法二：Counter 12345def is_anagram(s, t): from collections import Counter c1 = Counter(s) c2 = Counter(t) return c1 == c2]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
        <tag>algorithm</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode算法题整理（数学篇）Math]]></title>
    <url>%2FLeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E6%95%B0%E5%AD%A6%E7%AF%87%EF%BC%89Math%2F</url>
    <content type="text"><![CDATA[7. Reverse Integer倒置一个整数， 此答案忽略了原题中的范围判断。原题12Input: -123Output: -321 方法一：str 12345def reverse_int(x): if x &gt;= 0: return int(str(x)[::-1]) else: return -int(str(x)[:0:-1]) 方法二：math 1234567891011def reverse_int(x): if x &gt;= 0: fill_symbol = 1 else: fill_symbol = -1 result = 0 tail = abs(x) while tail: result = result*10 + tail%10 tail //= 10 return result * fill_symbol 9. Palindrome Number判断一个数是否是回文数，这里把负数认为是不符合条件的。原题方法一：str 12def is_palindrome(x): return str(x) == str(x)[::-1] 方法二：math 123456def is_palindrome(x): l, r = x, 0 while l &gt; 0: r = r*10 + l%10 l //= 10 return r == x 13. Roman to Integer罗马数字转换整型。原题12345678910def roman_to_int(s): roman = &#123;'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000&#125; total = 0 for i in range(len(s)): if i == len(s)-1 or roman[s[i]] &gt;= roman[s[i+1]] total += roman[s[i]] else: total -= roman[s[i]] return total 69. Sqrt(x)实现开方，返回整数部分。原题1234Input: 8Output: 2Explanation: The square root of 8 is 2.82842..., and since the decimal part is truncated, 2 is returned. 牛顿迭代法 12345def my_sqrt(x): r = x while r**2 &gt; x: r = (r+x/r) // 2 return r 136. Single Number找出数组中不重复的元素。原题12Input: [4,1,2,1,2]Output: 4 123def single_num(nums): from itertools import reduce return reduce(lambda x, y: x ^ y, nums) 171. Excel Sheet Column Numberexcel表格列表数字转换，二十六进制。原题1234567A -&gt; 1B -&gt; 2C -&gt; 3...Z -&gt; 26AA -&gt; 27AB -&gt; 28 A -&gt; 1 12def title2number(s): return sum([(ord(x)-64) * 26 ** i for i, x in enumerate(s[::-1])]) 704. Binary Search二分法在有序数组中查找元素。原题123Input: nums = [-1,0,3,5,9,12], target = 9Output: 4Explanation: 9 exists in nums and its index is 4 1234567891011def binary_search(nums, target): l, r = 0, len(nums)-1 while l &lt;= r: mid = (l+r) // 2 if nums[mid] &gt; target: r = mid - 1 elif nums[mid] &lt; target: l = mid + 1 else: return mid return -1 172. Factorial Trailing Zeroes求n的阶乘末尾有几个0。原题123Input: 5Output: 1Explanation: 5! = 120, one trailing zero. 思路：每一对2和5可以产生一个0，在n的阶乘中，5比2多，所以问题变成求5的个数，而25这种数有两个5，所以递归求解 12def trailing_zeroes(n): return 0 if n == 0 else n//5 + trailing_zeroes(n//5)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
        <tag>algorithm</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode算法题整理（数组篇）Array]]></title>
    <url>%2FLeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E6%95%B0%E7%BB%84%E7%AF%87%EF%BC%89Array%2F</url>
    <content type="text"><![CDATA[1. Two Sum给定一个数组，找出数组两个元素相加为目标值，假定只有唯一解。原题123Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. 1234567def two_sum(nums, target): buff_dict = &#123;&#125; for i, num in enumerate(nums): if num not in buff_dict: buff_dict[target-num] = i else: return [buff_dict[num], i] 26. Remove Duplicates from Sorted Array删除排序数组中重复的元素, 使用build-in在原数组上操作，返回一个长度，标识前n个元素为目标数组。原题12345Given nums = [0,0,1,1,1,2,2,3,3,4],Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.It doesn&apos;t matter what values are set beyond the returned length. 1234567def remove_duplicates(nums): index = 1 for i in range(len(nums)-1): if nums[i] != nums[i+1] nums[index] = nums[i+1] index += 1 return index 35. Search Insert Position给定一个target，插入到一个有序数组中，假定数组中无重复元素。原题12Input: [1,3,5,6], 5Output: 2 1234567891011def binary_insert(nums, target): l, r = 0, len(nums)-1 while l &lt;= r: mid = (l+r) // 2 if nums[mid] &gt; target: r = mid - 1 elif nums[mid] &lt; target: l = mid + 1 else: return mid return l 66. Plus One给数组加一，元素为非负整数，不以0开头。原题123Input: [4,3,2,1]Output: [4,3,2,2]Explanation: The array represents the integer 4321. 方法一：转成字符串再转成数字 1234def plus_one(digits): str_digits = ''.join(map(str, digits)) plused = int(str_digits) + 1 return [int(x) for x in str(plused)] 方法二：Math 进位 123456789101112def plus_one(digits): d = digits[:] plused = [] carry = 1 while d or carry: if d: v = d.pop() else: v = 0 carry, val = divmod(carry+v, 10) plused.append(val) return plused[::-1] 88. Merge Sorted Array合并两个有序数组，在nums1上修改。原题12345Input:nums1 = [1,2,3,0,0,0], m = 3nums2 = [2,5,6], n = 3Output: [1,2,2,3,5,6] 12345678910def merge(self, nums1, m, nums2, n): while m&gt;0 and n&gt;0: if nums1[m-1] &gt; nums2[n-1]: nums1[n+m-1] = nums1[m-1] m -= 1 else: nums1[n+m-1] = nums2[n-1] n -= 1 if n &gt; 0: nums1[:n] = nums2[:n] 118. Pascal’s Triangle杨辉三角。原题123456789Input: 5Output:[ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1]] 方法一 12345def pascal(num): res = [[1]] for _ in range(1, num): res += [list(map(lambda x, y: x+y, res[-1]+[0], [0]+res[-1]))] return res[:num] 方法二 123456789def generate(num): triangle = [] inner = [1] for _ in range(num): triangle.append(list(inner)) inner.append(0) right = [inner[i]+inner[i+1] for i in range(len(inner)-1)] inner = [1] + right return triangle 169. Majority Element找出数组中出现次数超过一半的元素。原题方法一：排序 12def majority_element(nums): return sorted(nums)[len(nums)//2] 方法二：Counter 1234def majority_element(nums): from collections import Counter c = Counter(nums) return c.most_common(1)[0][0] 189. Rotate Array旋转数组。原题123456Input: [1,2,3,4,5,6,7] and k = 3Output: [5,6,7,1,2,3,4]Explanation:rotate 1 steps to the right: [7,1,2,3,4,5,6]rotate 2 steps to the right: [6,7,1,2,3,4,5]rotate 3 steps to the right: [5,6,7,1,2,3,4] 方法一：slicing 123def rotate(nums, k): k = k % len(nums) nums[:] = nums[-k:] + nums[:-k] 方法二：stack 123def rotate(nums, k): for _ in range(k): nums.insert(0, nums.pop()) 217. Contains Duplicate数组中是否包含重复元素。原题12Input: [1,2,3,1]Output: true 方法一：set 12def contains_duplicate(nums): return len(set(nums)) &lt; len(nums) 方法二：hash 12345678def contains_duplicate(nums): existed = &#123;&#125; for num in nums: if num in existed: return True else: existed[num] = None return False 283. Move Zeroes将数组0元素移动到末尾。原题12Input: [0,1,0,3,12]Output: [1,3,12,0,0] 方法一：two pointers 12345678def move_zero(nums): l, r = 0, len(nums)-1 while l &lt; r: if nums[l] == 0: nums[:] = nums[:l] + nums[l+1:] + [0] r -= 1 else: l += 1 方法二： slicing 12def move_zero(nums): nums[:] = [x for x in nums if x != 0] + [x for x in nums if x == 0]]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
        <tag>algorithm</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode算法题整理（链表篇）LinkedList]]></title>
    <url>%2FLeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E9%93%BE%E8%A1%A8%E7%AF%87%EF%BC%89LinkedList%2F</url>
    <content type="text"><![CDATA[链表的定义1234class ListNode: def __init__(self, x): self.val = x self.next = None 2. Add Two Numbers两个链表相加123Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8Explanation: 342 + 465 = 807. 123456789101112131415def addTwoNumbers(l1, l2): l = head = ListNode(0) carry = 0 while l1 or l2 or carry: v1 = v2 = 0 if l1: v1 = l1.val l1 = l1.next if l2: v2 = l2.val l2 = l2.next carry, val = divmod(sum(v1+v2+carry), 10) l.next = ListNode(val) l = l.next return head.next 21. Merge Two Sorted Lists合并两个有序链表。原题12Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 方法1：iteratively 迭代 123456789101112def mergeTwoLists(l1, l2): l = head = ListNode(0) while l1 and l2: if l1.val &lt;= l2.val: l.next = l1 l1 = l1.next else: l.next = l2 l2= l2.next l = l.next l.next = l1 or l2 return head.next 方法2：recursively 递归 12345678910def mergeTwoLists(l1, l2): # 判断是否存在None if not l1 or not l2: return l1 or l2 if l1.val &lt; l2.val: l1.next = mergeTwoLists(l1.next, l2) return l1 else: l2.next = mergeTwoLists(l1, l2.next) return l2 237. Delete Node in a Linked List在链表中删除节点。给定的节点不是尾节点。原题12Input: head = [4,5,1,9], node = 5Output: [4,1,9] 开始看到这题的思路是，要是能拿到父节点就好了，然后这道题需要别的思路，其关键在于复制 123def deleteNode(self, node): node.val = node.next.val # 4-&gt;1-&gt;1-&gt;9 node.next = nede.next.next # 4-&gt;1-&gt;9 141. Linked List Cycle判断一个链表是否有环。原题经典的一道题，看成两个人在赛跑，如果有环，快的人会和慢的人相遇 12345678def hasCycle(self, head): slow = fast = head: while fast and fast.next: fast = fast.next.next slow = slow.next if fast is slow: return True return False 206. Reverse Linked List倒置一个链表。原题12Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULLOutput: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 方法一： iteratively12345678def reverseList(head): prev = None while head: cur = head head = head.next cur.next = prev prev = cur return prev 方法二：使用一行赋值 12345def reverseList(self, head): prev = None while head: head.next, prev, head = prev, head, head.next return prev 这个方法有些不明白的地方，后续会更新一篇文章研究它。 160. Intersection of Two Linked Lists两个链表求相交。原题1234567def getIntersectionNode(self, headA, headB): p1 = headA p2 = headB while p1 is not p2: p1 = p1.next if p1 else headB p2 = p2.next if p2 else headA return p1]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
        <tag>algorithm</tag>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo搭建遇到的问题及优化]]></title>
    <url>%2Fhexo%E6%90%AD%E5%BB%BA%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[前言终于有了一个整理自己学习笔记的地方了，之前用过印象笔记，觉得它的markdown格式处理得不是很完美，复制粘贴出来总是格式不对。后来又用过jupyter_nootboke，但是不方便在其它客户端查看。折腾了半天终于弄好了期间遇到过不少坑，发现hexo有时候同一样的问题总是对应着几种不同的解决方法，在此整理一下以便之后遇到问题。 关于问题NexT这里使用了next主题，这个主题特别简洁，还有很多易用性的扩展，尤其侧边栏的快速定位，让我爱不释手。 头像不显示开始按照_config.yml中所说把avatar.gif放到blog-site/source/下，没有任何的作用。后来发现是主题的原因，放到themes/next/source/images/下就好了，默认的头像是正方形的，这里修改了一下代码把它改成圆形，文件位置在themes/next/source/css_common_components/sidebar/sidebar-author.styl 1234567891011121314.site-author-image &#123; display: block; margin: 0 auto; max-width: 96px; height: auto; border: 2px solid #333; padding: 2px; /* start*/ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px; box-shadow: inset 0 -1px 0 #333sf; /* end */&#125; 网页图标favicon.ico不显示这里也是因为Next的原因，把favicon.ico放到themes/next/source/images/下，然后修改_config.yml中favicon: /images/favicon.ico解决了问题。这里介绍一个很方便转换ico的网站favicon在线制作。 没有建立资源文件夹 设置post_asset_foler: true之后执行hexo new post_name后没有建立资源文件夹。搜索没有查到相关记录，后来想到之前next主题设置时，把配置文件拆分了出来，这样每次执行hexo clean/generate的时候在后面加了参数--config指定了配置文件。但是这样修改的文件对于hexo new post_name来说是没有修过的，所以要在source/_config.yml修改这项参数。 之后没有选择官方的标签插件是因为，在编辑markdown时无法看到预览效果所以安装npm install https://github.com/CodeFalling/hexo-asset-image --save，在文章中使用markdown语法引用![logo](&lt;title_name&gt;/a.png)使用。 选择官方的标签插件引用图片。 关于优化在右上角或者左上角实现fork me on github在这里选择喜欢的样式。这里选择的是 1&lt;a href=&quot;https://your-url&quot; class=&quot;github-corner&quot; aria-label=&quot;View source on Github&quot;&gt;&lt;svg width=&quot;80&quot; height=&quot;80&quot; viewBox=&quot;0 0 250 250&quot; style=&quot;fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;&quot; aria-hidden=&quot;true&quot;&gt;&lt;path d=&quot;M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2&quot; fill=&quot;currentColor&quot; style=&quot;transform-origin: 130px 106px;&quot; class=&quot;octo-arm&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z&quot; fill=&quot;currentColor&quot; class=&quot;octo-body&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;&lt;style&gt;.github-corner:hover .octo-arm&#123;animation:octocat-wave 560ms ease-in-out&#125;@keyframes octocat-wave&#123;0%,100%&#123;transform:rotate(0)&#125;20%,60%&#123;transform:rotate(-25deg)&#125;40%,80%&#123;transform:rotate(10deg)&#125;&#125;@media (max-width:500px)&#123;.github-corner:hover .octo-arm&#123;animation:none&#125;.github-corner .octo-arm&#123;animation:octocat-wave 560ms ease-in-out&#125;&#125;&lt;/style&gt; 将其粘贴到themes/next/layout/_layout.swig中，放在div class=&quot;headhand&quot;&gt;&lt;/div&gt;下面。 修改文章底部的那个带#号的标签修改模板/themes/next/layout/_macro/post.swig，搜索rel=&quot;tag&quot;&gt;#，将#换成&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt; 侧边栏社交小图标设置在配置文件搜索social_icons，把值换成喜欢的图标名字，这里列出了图标库 在网站底部加上访问量打开/themes/next/layout/_partials/footer.swig文件添加红框内的代码 1&lt;script async src=&quot;https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; 添加统计代码如下位置12345&lt;div class=&quot;powered-by&quot;&gt;&lt;i class=&quot;fa fa-user-md&quot;&gt;&lt;/i&gt;&lt;span id=&quot;busuanzi_container_site_uv&quot;&gt; 本站访客数:&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt; 网站底部字数统计根目录安装npm install hexo-wordcount --save然后再/themes/next/layout/_partials/footer.swig文件最后加上 1234&lt;div class=&quot;theme-info&quot;&gt; &lt;div class=&quot;powered-by&quot;&gt;&lt;/div&gt; &lt;span class=&quot;post-count&quot;&gt;博客全站共&#123;&#123; totalcount(site) &#125;&#125;字&lt;/span&gt;&lt;/div&gt; 添加顶部加载条_config.yml设置中pace:true 在文章底部增加版权信息在目录themes/next/layout/_macro/下添加my-copyright.swig: 123456789101112131415161718192021222324252627282930&#123;% if page.copyright %&#125;&lt;div class=&quot;my_post_copyright&quot;&gt; &lt;script src=&quot;//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js&quot;&gt;&lt;/script&gt; &lt;!-- JS库 sweetalert 可修改路径 --&gt; &lt;script src=&quot;https://cdn.bootcss.com/jquery/2.0.0/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/sweetalert/dist/sweetalert.min.js&quot;&gt;&lt;/script&gt; &lt;p&gt;&lt;span&gt;本文标题:&lt;/span&gt;&lt;a href=&quot;&#123;&#123; url_for(page.path) &#125;&#125;&quot;&gt;&#123;&#123; page.title &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;文章作者:&lt;/span&gt;&lt;a href=&quot;/&quot; title=&quot;访问 &#123;&#123; theme.author &#125;&#125; 的个人博客&quot;&gt;&#123;&#123; theme.author &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;发布时间:&lt;/span&gt;&#123;&#123; page.date.format(&quot;YYYY年MM月DD日 - HH:MM&quot;) &#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;span&gt;最后更新:&lt;/span&gt;&#123;&#123; page.updated.format(&quot;YYYY年MM月DD日 - HH:MM&quot;) &#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;span&gt;原始链接:&lt;/span&gt;&lt;a href=&quot;&#123;&#123; url_for(page.path) &#125;&#125;&quot; title=&quot;&#123;&#123; page.title &#125;&#125;&quot;&gt;&#123;&#123; page.permalink &#125;&#125;&lt;/a&gt; &lt;span class=&quot;copy-path&quot; title=&quot;点击复制文章链接&quot;&gt;&lt;i class=&quot;fa fa-clipboard&quot; data-clipboard-text=&quot;&#123;&#123; page.permalink &#125;&#125;&quot; aria-label=&quot;复制成功！&quot;&gt;&lt;/i&gt;&lt;/span&gt; &lt;/p&gt; &lt;p&gt;&lt;span&gt;许可协议:&lt;/span&gt;&lt;i class=&quot;fa fa-creative-commons&quot;&gt;&lt;/i&gt; &lt;a rel=&quot;license&quot; href=&quot;https://creativecommons.org/licenses/by-nc-nd/4.0/&quot; target=&quot;_blank&quot; title=&quot;Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)&quot;&gt;署名-非商业性使用-禁止演绎 4.0 国际&lt;/a&gt; 转载请保留原文链接及作者。&lt;/p&gt; &lt;/div&gt;&lt;script&gt; var clipboard = new Clipboard(&apos;.fa-clipboard&apos;); $(&quot;.fa-clipboard&quot;).click(function()&#123; clipboard.on(&apos;success&apos;, function()&#123; swal(&#123; title: &quot;&quot;, text: &apos;复制成功&apos;, icon: &quot;success&quot;, showConfirmButton: true &#125;); &#125;); &#125;); &lt;/script&gt;&#123;% endif %&#125; 在目录themes/next/source/css/_common/components/post/下添加my-post-copyright.styl: 123456789101112131415161718192021222324252627282930313233343536373839404142434445.my_post_copyright &#123; width: 85%; max-width: 45em; margin: 2.8em auto 0; padding: 0.5em 1.0em; border: 1px solid #d3d3d3; font-size: 0.93rem; line-height: 1.6em; word-break: break-all; background: rgba(255,255,255,0.4);&#125;.my_post_copyright p&#123;margin:0;&#125;.my_post_copyright span &#123; display: inline-block; width: 5.2em; color: #b5b5b5; font-weight: bold;&#125;.my_post_copyright .raw &#123; margin-left: 1em; width: 5em;&#125;.my_post_copyright a &#123; color: #808080; border-bottom:0;&#125;.my_post_copyright a:hover &#123; color: #a3d2a3; text-decoration: underline;&#125;.my_post_copyright:hover .fa-clipboard &#123; color: #000;&#125;.my_post_copyright .post-url:hover &#123; font-weight: normal;&#125;.my_post_copyright .copy-path &#123; margin-left: 1em; width: 1em; +mobile()&#123;display:none;&#125;&#125;.my_post_copyright .copy-path:hover &#123; color: #808080; cursor: pointer;&#125; 修改/themes/next/layout/_macro/post.swig在如下位置 添加代码：(注意和之前的教程不一样，这里可能是next的更新了，所以要把代码放到外面，否则在wechat_subscriber未开启时会导致失效。) 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include &apos;my-copyright.swig&apos; %&#125; &#123;% endif %&#125;&lt;/div&gt; 修改themes/next/source/css/_common/components/post/post.styl末尾增加一行1@import &quot;my-post-copyright&quot; 博文置顶替换node_modules/hexo-generator-index/lib/generator.js所有的代码为： 12345678910111213141516171819202122232425262728&apos;use strict&apos;;var pagination = require(&apos;hexo-pagination&apos;);module.exports = function(locals)&#123; var config = this.config; var posts = locals.posts; posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义 if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排 else return b.top - a.top; // 否则按照top值降序排 &#125; else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233） return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; // 都没定义按照文章日期降序排 &#125;); var paginationDir = config.pagination_dir || &apos;page&apos;; return pagination(&apos;&apos;, posts, &#123; perPage: config.index_generator.per_page, layout: [&apos;index&apos;, &apos;archive&apos;], format: paginationDir + &apos;/%d/&apos;, data: &#123; __index: true &#125; &#125;);&#125;; 使用：在头部添加top 12345678---title: date: 2017-05-22 22:45:48tags: 技巧categories: 技巧copyright: truetop: 100--- 修改字体大小/themes/next/source/css/_variables/base.styl搜索font-size-base 设置阅读次数添加阅读量统计 添加搜索12local_search: enable: true SEO优化两个搜索引擎入口： 谷歌搜索引擎验证 百度搜索引擎验证 这里选择用下载文件的方式，将文件放到source/目录下，注意一点应该在文件前添加两行代码，防止hexo将其格式化 12layout: false--- 生成站点地图 sitemap 站点地图是一种文件，您可以通过该文件列出您网站上的网页，从而将您网站内容的组织架构告知Google和其他搜索引擎。Googlebot等搜索引擎网页抓取工具会读取此文件，以便更加智能地抓取您的网站。 12npm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save 更改配置 12345# 自动生成sitemapsitemap: path: sitemap.xmlbaidusitemap: path: baidusitemap.xml 使搜索引擎收录我们的博客 谷歌比较简单向谷歌站长工具提交sitemap 百度。参考Hexo插件之百度主动提交链接 网站自身优化给出站链接添加 “nofollow” 标签/themes/next/layout/_partials/footer.swig找到下面两行，分别在a标签中添加rel=&quot;texternal nofollow&quot;属性 同样在/themes/next/layout/_macor/sidebar.swig中添加这个属性 设置更改属性seo: true 缩短文章链接编辑配置文件permalink: :title.html]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
