<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LeetCode算法题整理（回溯篇）BackTracking]]></title>
    <url>%2FLeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E5%9B%9E%E6%BA%AF%E7%AF%87%EF%BC%89BackTracking%2F</url>
    <content type="text"><![CDATA[93. Restore IP Addresses恢复IP地址。原题12Input: &quot;25525511135&quot;Output: [&quot;255.255.11.135&quot;, &quot;255.255.111.35&quot;] 方法一：需要注意0的情况。 12345678910111213141516171819202122def restoreIpAddresses(self, s: str) -&gt; List[str]: def backtrack(ip, remain, part): if part &lt; 0: return if not remain and part==0: ans.append(ip) else: ip += '.' * bool(ip) n = len(remain) if n &gt;= 1: backtrack(ip+remain[:1], remain[1:], part-1) if n &gt;= 2 and remain[0]!='0': backtrack(ip+remain[:2], remain[2:], part-1) if n &gt;= 3: if 99 &lt; int(remain[:3]) &lt; 256: backtrack(ip+remain[:3], remain[3:], part-1) ans = [] if s: backtrack('', s, 4) return list(ans) 131. Palindrome Partitioning回文串切分。原题123456Input: &quot;aab&quot;Output:[ [&quot;aa&quot;,&quot;b&quot;], [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;]] 方法一：原始回溯。 12345678910111213def partition(self, s: str) -&gt; List[List[str]]: def backtrack(s, remain): if not remain: ans.append(s) else: for i in range(1, len(remain)+1): # 这里是n+1，因为整个字符串也有可能。 if remain[:i] == remain[:i][::-1]: backtrack(s+[remain[:i]], remain[i:]) ans = [] if s: backtrack([], s) return ans 方法二：使用列表生成式。 1234def partition(self, s: str) -&gt; List[List[str]]: return s and [[s[:i]] + suffix for i in range(1, len(s)+1) if s[:i]==s[i-1::-1] for suffix in self.partition(s[i:])] or [[]] 77. Combinations实现组合。原题12345678910Input: n = 4, k = 2Output:[ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4],] 方法一：回溯。700ms, 比Solution中的慢了100ms. 123456789101112def combine(self, n: int, k: int) -&gt; List[List[int]]: def backtrack(a, k, rest): if k == 1: ans.extend(a+[num] for num in rest) else: for i, h in enumerate(rest): backtrack(a+[h], k-1, rest[i+1:]) ans = [] backtrack([], k, list(range(1, n+1))) return ans 方法二：Solution中的递归。 1234567891011121314def combine(self, n: int, k: int) -&gt; List[List[int]]: def backtrack(first=1, cur=[]): if len(cur) == k: ans.append(cur[:]) else: for i in range(first, n+1): cur.append(i) backtrack(i+1, cur) cur.pop() ans = [] backtrack() return ans 方法三：列表生成式写法，递归。 12345def combine(self, n: int, k: int) -&gt; List[List[int]]: if k == 0: return [[]] return [pre+[i] for i in range(k, n+1) for pre in self.combine(i-1, k-1)] 39. Combination Sum和77类似，找出和为指定数值的组合，候选数字可以重复使用。原题1234567Input: candidates = [2,3,5], target = 8,A solution set is:[ [2,2,2,2], [2,3,3], [3,5]] 方法一：将候选组排序，并记录当前的索引值。 123456789101112131415def combinationSum(self, candidates: List[int], target: int) -&gt; List[List[int]]: def backtrack(g, i, target): if target == 0: ans.append(g) elif target &lt; candidates[i]: return for j in range(i, n): backtrack(g+[candidates[j]], j, target-candidates[j]) ans = [] n = len(candidates) candidates.sort() backtrack([], 0, target) return ans 40. Combination Sum II组合求和，和39类似，区别在于候选数字中可能有重复数字，但每个数字只能使用一次。原题麻烦的地方在于如何保证结果是非重复的。 12345678910111213141516171819def combinationSum2(self, candidates: List[int], target: int) -&gt; List[List[int]]: def backtrack(g, i, target): if target == 0: ans.append(g) return for j in range(i, n): # avoid duplicate result if j != i and candidates[j]==candidates[j-1]: continue if candidates[j] &gt; target: break backtrack(g+[candidates[j]], j+1, target-candidates[j]) ans = [] n = len(candidates) candidates.sort() backtrack([], 0, target) return ans 216. Combination Sum III组合求和，从1~9选出k个不重复的数，和为n。原题12Input: k = 3, n = 9Output: [[1,2,6], [1,3,5], [2,3,4]] 123456789101112def combinationSum3(self, k: int, n: int) -&gt; List[List[int]]: def backtrack(g, i, target, k): if k==0 and target==0: ans.append(g) if k &lt; 0 or target &lt; 0: return for j in range(i, 10): backtrack(g+[j], j+1, target-j, k-1) ans = [] backtrack([], 1, n, k) return ans 方法二：递归，使用last作为上限。 123456789def combinationSum3(self, k: int, n: int) -&gt; List[List[int]]: def combs(k, n, cap): if not k: return [[]] * (not n) return [comb + [last] for last in range(1, cap) for comb in combs(k-1, n-last, last)] return combs(k, n, 10) 78. Subsets输出给定无重复集合的子集组合。原题123456789101112Input: nums = [1,2,3]Output:[ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], []] 方法一：常规写法。 123456789101112def subsets(self, nums: List[int]) -&gt; List[List[int]]: def backtrack(g, i, n): if not n: ans.append(g) for j in range(i, len(nums)): backtrack(g+[nums[j]], j+1, n-1) ans = [] for n in range(len(nums)+1): backtrack([], 0, n) return ans 方法二：做一个递增就好了。 12345def subsets(self, nums: List[int]) -&gt; List[List[int]]: ans = [[]] for num in nums: ans += [pre+[num] for pre in ans] return ans 90. Subsets II和78类似，区别在于给定的数组有重复元素。原题方法一：用到了40题中解法去重的代码。 123456789101112131415def subsetsWithDup(self, nums: List[int]) -&gt; List[List[int]]: def backtrack(g, i, n): if not n: ans.append(g) for j in range(i, len(nums)): if j!=i and nums[j]==nums[j-1]: continue backtrack(g+[nums[j]], j+1, n-1) ans = [] nums.sort() for n in range(len(nums)+1): backtrack([], 0, n) return ans 79. Word Search矩阵中的路径。原题12345678910board =[ [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;E&apos;], [&apos;S&apos;,&apos;F&apos;,&apos;C&apos;,&apos;S&apos;], [&apos;A&apos;,&apos;D&apos;,&apos;E&apos;,&apos;E&apos;]]Given word = &quot;ABCCED&quot;, return true.Given word = &quot;SEE&quot;, return true.Given word = &quot;ABCB&quot;, return false. 123456789101112131415161718192021def exist(self, g: List[List[str]], word: str) -&gt; bool: R, C = len(g), len(g[0]) def spread(i, j, w): if not w: return True original, g[i][j] = g[i][j], '-' spreaded = False for x, y in ((i-1, j), (i+1, j), (i, j-1), (i, j+1)): if (0&lt;=x&lt;R and 0&lt;=y&lt;C and w[0]==g[x][y] and spread(x, y, w[1:])): spreaded = True break g[i][j] = original return spreaded for i in range(R): for j in range(C): if g[i][j] == word[0] and spread(i, j, word[1:]): return True return False 200. Number of Islands小岛的个数。原题1234567Input:11110110101100000000Output: 1 方法一：常规写法。 1234567891011121314151617181920def numIslands(self, grid: List[List[str]]) -&gt; int: if not grid: return 0 R, C = len(grid), len(grid[0]) seen = set() count = 0 def spread(i, j): seen.add((i, j)) for x, y in ((i-1, j), (i+1, j), (i, j-1), (i, j+1)): if (0&lt;=x&lt;R and 0&lt;=y&lt;C and (x, y) not in seen and grid[x][y]=='1'): spread(x, y) for i in range(R): for j in range(C): if (i, j) not in seen and grid[i][j]=='1': count += 1 spread(i, j) return count 方法二：当登录一座岛屿时，使这座岛屿下沉，变为’0’。不明白为什么比上个方法慢了20ms。 123456789def numIslands(self, grid: List[List[str]]) -&gt; int: def sink(i, j): if 0&lt;=i&lt;len(grid) and 0&lt;=j&lt;len(grid[i]) and grid[i][j]=='1': grid[i][j] = '0' list(map(sink, (i-1, i+1, i, i), (j, j, j-1, j+1))) # important, return generator without list return 1 return 0 return sum(sink(i, j) for i in range(len(grid)) for j in range(len(grid[i]))) 130. Surrounded Regions将四周被包围的O翻转成X，边缘不算包围。原题方法一：传统的方法在延伸的时候判断不出是否到达边界。所以这里先得到边界的点，然后从边界往里延伸，将所有的O变为S，第二次遍历时，将S恢复成O，其他设为X。 123456789101112def solve(self, board: List[List[str]]) -&gt; None: if not board: return R, C = len(board), len(board[0]) bounds = [(i, j) for k in range(R+C) for i, j in ((0, k), (R-1, k), (k, 0), (k, C-1)) if i &lt; R and j &lt; C] while bounds: x, y = bounds.pop() if 0&lt;=x&lt;R and 0&lt;=y&lt;C and board[x][y]=='O': board[x][y] = 'S' bounds += (x-1, y), (x+1, y), (x, y-1), (x, y+1) board[:] = [['XO'[c=='S'] for c in row] for row in board] 417. Pacific Atlantic Water Flow太平洋大西洋水流向，假设陆地上可以沿着高度不高于的地方流淌，求能同时流入两个海洋的陆地坐标。原题1234567891011121314151617Given the following 5x5 matrix: Pacific ~ ~ ~ ~ ~ ~ 1 2 2 3 (5) * ~ 3 2 3 (4) (4) * ~ 2 4 (5) 3 1 * ~ (6) (7) 1 4 5 * ~ (5) 1 1 2 4 * * * * * * AtlanticReturn:[[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (positions with parentheses in above matrix). Pacific ~ ~ ~ ~ 1 2 (3) * ~ (8) (9) (4) * ~ (7) (6) (5) * * * * * Atlantic 方法一：一开始我以为从左上的点只能往右或下方向找陆地，事实上还是要寻找四个方向。这应该是最暴力的解法了。但是看了几个高票答案都没我这个快。 1234567891011121314151617181920def pacificAtlantic(self, matrix: List[List[int]]) -&gt; List[List[int]]: if not matrix: return [] p_land = set() a_land = set() R, C = len(matrix), len(matrix[0]) def spread(i, j, land): land.add((i, j)) for x, y in ((i+1, j), (i, j+1), (i-1, j), (i, j-1)): if (0&lt;=x&lt;R and 0&lt;=y&lt;C and matrix[x][y] &gt;= matrix[i][j] and (x, y) not in land): spread(x, y, land) for i in range(R): spread(i, 0, p_land) spread(i, C-1, a_land) for j in range(C): spread(0, j, p_land) spread(R-1, j, a_land) return list(p_land &amp; a_land) 526. Beautiful Arrangement完美安排，给定1~N的数字，生成一种排列，是第i位的数字能被i整除，或者i能被第i位的数字整除，索引从1开始。原题123456789101112131415Input: 2Output: 2Explanation: The first beautiful arrangement is [1, 2]:Number at the 1st position (i=1) is 1, and 1 is divisible by i (i=1).Number at the 2nd position (i=2) is 2, and 2 is divisible by i (i=2).The second beautiful arrangement is [2, 1]:Number at the 1st position (i=1) is 2, and 2 is divisible by i (i=1).Number at the 2nd position (i=2) is 1, and i (i=2) is divisible by 1. 方法一：常规写法，1300ms，beats50%. 12345678910111213141516def countArrangement(self, N: int) -&gt; int: def backtrack(g, rest): nonlocal count if not rest: count += 1 index = len(g) + 1 for i, num in enumerate(rest): if num % index == 0 or index % num == 0: # print(g, i, num, index, rest) g.append(num) backtrack(g, rest[:i]+rest[i+1:]) g.pop() count = 0 backtrack([], list(range(1, N+1))) return count 方法二：去掉了方法一中一些无用的空间和操作。1000ms, beats 67%. 123456789101112131415161718def countArrangement(self, N: int) -&gt; int: def backtrack(g): nonlocal count if not rest: count += 1 index = len(g) + 1 for num in rest: if num % index == 0 or index % num == 0: g.append(num) rest.remove(num) backtrack(g) g.pop() rest.add(num) count = 0 rest = set(range(1, N+1)) backtrack([]) return count 方法三：这里从后往前构建，最后构造1，因为1的位置放任何数字都可以。152ms 123456789def countArrangement(self, N: int) -&gt; int: def backtrack(i, rest): if i == 1: return 1 return sum(backtrack(i-1, rest-&#123;x&#125;) for x in rest if x % i == 0 or i % x == 0) return backtrack(N, set(range(1, N+1))) 方法四：在3的基础上优化，每次调用方法时可以利用之前的结果。52ms 1234567891011121314151617cache = &#123;&#125;class Solution: def countArrangement(self, N: int) -&gt; int: def backtrack(i, rest): if i == 1: return 1 key = i, rest if key in cache: return cache[key] ans = sum(backtrack(i-1, rest[:j]+rest[j+1:]) for j, x in enumerate(rest) if x % i == 0 or i % x == 0) # print(ans, i, rest) cache[key] = ans return ans return backtrack(N, tuple(range(1, N+1))) 22. Generate Parentheses生成n对合法的括号。原题1234567[ &quot;((()))&quot;, &quot;(()())&quot;, &quot;(())()&quot;, &quot;()(())&quot;, &quot;()()()&quot;] 方法一：常规写法。 123456789101112def generateParenthesis(self, n: int) -&gt; List[str]: def backtrack(p, l, r): if len(p) == n*2: ans.append(p) if l &lt; n: backtrack(p+'(', l+1, r) if r &lt; l: backtrack(p+')', l, r+1) ans = [] backtrack('', 0, 0) return ans 方法二：生成器写法。 123456789def generateParenthesis(self, n: int) -&gt; List[str]: def gen_parens(p, l, r): if r &gt;= l &gt;= 0: if not r: yield p yield from gen_parens(p+'(', l-1, r) yield from gen_parens(p+')', l, r-1) return list(gen_parens('', n, n))]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
        <tag>Algorithm</tag>
        <tag>BackTracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[矩阵中单词的路径，很多人都错了]]></title>
    <url>%2F%E7%9F%A9%E9%98%B5%E4%B8%AD%E5%8D%95%E8%AF%8D%E7%9A%84%E8%B7%AF%E5%BE%84%EF%BC%8C%E5%BE%88%E5%A4%9A%E4%BA%BA%E9%83%BD%E9%94%99%E4%BA%86%2F</url>
    <content type="text"><![CDATA[刷过《剑指Offer》的同学，想必都会对这道题有印象，但是如果你之前是在牛客网或者AcWing其他的网站做这道题，那么即便AC通过了所有的测试，你的答案也可能是错误的。我自己之前也是被这个答案误导过，下面我来详细地解释一下自己曾经写过的错误代码，以免以后再次犯同样的错误。 请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则之后不能再次进入这个格子。 例如 a b c e s f c s a d e e 这样的3 X 4 矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。 LeetCode传送门 牛客网传送门 我从Python的排行榜中复制出来了一个比较“流行”的写法。代码如下，这个代码有两处错误。 12345678910111213141516171819202122def hasPath(self, matrix, rows, cols, path): # write code here for i in range(rows): for j in range(cols): if matrix[i*cols+j]==path[0]: if self.find(list(matrix),rows,cols,path[1:],i,j): return True return Falsedef find(self,matrix,rows,cols,path,i,j): if not path: return True matrix[i*cols+j]='-' if j+1&lt;cols and matrix[i*cols+(j+1)]==path[0]: return self.find(matrix,rows,cols,path[1:],i,j+1) elif j-1&gt;=0 and matrix[i*cols+(j-1)]==path[0]: return self.find(matrix,rows,cols,path[1:],i,j-1) elif i+1&lt;rows and matrix[(i+1)*cols+j]==path[0]: return self.find(matrix,rows,cols,path[1:],i+1,j) elif i-1&gt;=0 and matrix[(i-1)*cols+j]==path[0]: return self.find(matrix,rows,cols,path[1:],i-1,j) else: return False 其中一处错误很明显。在函数find中，他选择了右左下上的顺序，那么如果右边开始匹配，并且右边匹配上了一个字符，那么会继续递归，最后结果如果返回了False，那么接下来的左下上就会被跳过，错误地返回了False。我们来举个栗子🌰。 如果矩阵如上图中那样，并且开始寻找字符转SEE。根据上述算法，当找到S时，先选择往下走，找到了一个E，然后返回了False，忽略了上面的SEE。 于是我将find方法改成了下面这样。 1234567891011121314def find(matrix, rows, cols, path, i, j): if not path: return True matrix[i*cols + j] = '-' up, down, left, right = False, False, False, False if j + 1 &lt; cols and matrix[i * cols + j + 1] == path[0]: down = spread(matrix, rows, cols, path[1:], i, j + 1) if j - 1 &gt;= 0 and matrix[i * cols + j - 1] == path[0]: left = spread(matrix, rows, cols, path[1:], i, j - 1) if i + 1 &lt; rows and matrix[(i + 1) * cols + j] == path[0]: right = spread(matrix, rows, cols, path[1:], i + 1, j) if i - 1 &gt;= 0 and matrix[(i - 1) * cols + j] == path[0]: up = spread(matrix, rows, cols, path[1:], i - 1, j) return up or down or left or right 这之后的很长一段时间，我一直以为这个写法是正确的。直到我在LeetCode上发现这道原题，自信满满地提交自己认为正确的答案，被这个TestCase教做人。我当时提交的完整答案是这样的。这个输入参数有一些不一样的地方，LeetCode输入的是二维数组，牛客是一个字符串，这里写的是LeetCode的写法。这里因为是二维数组，所以要做深拷贝。 1234567891011121314151617181920212223def exist(self, g: List[List[str]], word: str) -&gt; bool: from copy import deepcopy R, C = len(g), len(g[0]) def spread(g, i, j, w): if not w: return True g[i][j] = '-' spreaded = False print('cur -&gt; (&#123;&#125;, &#123;&#125;) &#123;&#125;, &#123;&#125;'.format(i, j, w, g)) for x, y in ((i-1, j), (i+1, j), (i, j-1), (i, j+1)): if 0&lt;=x&lt;R and 0&lt;=y&lt;C and w[0]==g[x][y]: if spread(g, x, y, w[1:]): spreaded = True print('spreaded &#123;&#125;, recover (&#123;&#125;, &#123;&#125;), after &#123;&#125;'.format(spreaded, i, j, g)) return spreaded for i in range(R): for j in range(C): if g[i][j] == word[0]: if spread(deepcopy(g), i, j, word[1:]): return True return False 未通过的TestCase为：目标字符串为ABCESEEEFS。 为了方便观察问题，我加了两行输出。 123456789101112131415161718cur -&gt; (0, 0) BCESEEEFS, [[&apos;-&apos;, &apos;B&apos;, &apos;C&apos;, &apos;E&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;E&apos;, &apos;S&apos;], [&apos;A&apos;, &apos;D&apos;, &apos;E&apos;, &apos;E&apos;]]cur -&gt; (0, 1) CESEEEFS, [[&apos;-&apos;, &apos;-&apos;, &apos;C&apos;, &apos;E&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;E&apos;, &apos;S&apos;], [&apos;A&apos;, &apos;D&apos;, &apos;E&apos;, &apos;E&apos;]]cur -&gt; (0, 2) ESEEEFS, [[&apos;-&apos;, &apos;-&apos;, &apos;-&apos;, &apos;E&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;E&apos;, &apos;S&apos;], [&apos;A&apos;, &apos;D&apos;, &apos;E&apos;, &apos;E&apos;]]cur -&gt; (1, 2) SEEEFS, [[&apos;-&apos;, &apos;-&apos;, &apos;-&apos;, &apos;E&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;-&apos;, &apos;S&apos;], [&apos;A&apos;, &apos;D&apos;, &apos;E&apos;, &apos;E&apos;]]cur -&gt; (1, 3) EEEFS, [[&apos;-&apos;, &apos;-&apos;, &apos;-&apos;, &apos;E&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;A&apos;, &apos;D&apos;, &apos;E&apos;, &apos;E&apos;]]cur -&gt; (0, 3) EEFS, [[&apos;-&apos;, &apos;-&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;A&apos;, &apos;D&apos;, &apos;E&apos;, &apos;E&apos;]]spreaded False, g [[&apos;-&apos;, &apos;-&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;A&apos;, &apos;D&apos;, &apos;E&apos;, &apos;E&apos;]]cur -&gt; (2, 3) EEFS, [[&apos;-&apos;, &apos;-&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;A&apos;, &apos;D&apos;, &apos;E&apos;, &apos;-&apos;]]cur -&gt; (2, 2) EFS, [[&apos;-&apos;, &apos;-&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;A&apos;, &apos;D&apos;, &apos;-&apos;, &apos;-&apos;]]spreaded False, g [[&apos;-&apos;, &apos;-&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;A&apos;, &apos;D&apos;, &apos;-&apos;, &apos;-&apos;]]spreaded False, g [[&apos;-&apos;, &apos;-&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;A&apos;, &apos;D&apos;, &apos;-&apos;, &apos;-&apos;]]spreaded False, g [[&apos;-&apos;, &apos;-&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;A&apos;, &apos;D&apos;, &apos;-&apos;, &apos;-&apos;]]spreaded False, g [[&apos;-&apos;, &apos;-&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;A&apos;, &apos;D&apos;, &apos;-&apos;, &apos;-&apos;]]spreaded False, g [[&apos;-&apos;, &apos;-&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;A&apos;, &apos;D&apos;, &apos;-&apos;, &apos;-&apos;]]spreaded False, g [[&apos;-&apos;, &apos;-&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;A&apos;, &apos;D&apos;, &apos;-&apos;, &apos;-&apos;]]spreaded False, g [[&apos;-&apos;, &apos;-&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;A&apos;, &apos;D&apos;, &apos;-&apos;, &apos;-&apos;]]cur -&gt; (2, 0) BCESEEEFS, [[&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;E&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;E&apos;, &apos;S&apos;], [&apos;-&apos;, &apos;D&apos;, &apos;E&apos;, &apos;E&apos;]]spreaded False, g [[&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;E&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;E&apos;, &apos;S&apos;], [&apos;-&apos;, &apos;D&apos;, &apos;E&apos;, &apos;E&apos;]] 这个稍微看一下就明白了，虽然每次匹配第一个字符串A的时候传入了一个新的二维数组，但是在找A之后的路径时，每次返回False的时候没有将-恢复成原来的字母。下面请记住我代码中写的方向顺序为上下左右。 在上面的几步延伸之后，回到了ABC然后右边的字母没有恢复，所以返回了False。于是我们可以先记录一下之前的字母，然后在得到结果后将其恢复。 123456789101112131415161718192021222324def exist(self, g: List[List[str]], word: str) -&gt; bool: from copy import deepcopy R, C = len(g), len(g[0]) def spread(g, i, j, w): if not w: return True original, g[i][j] = g[i][j], '-' spreaded = False print('cur -&gt; (&#123;&#125;, &#123;&#125;) &#123;&#125;, &#123;&#125;'.format(i, j, w, g)) for x, y in ((i-1, j), (i+1, j), (i, j-1), (i, j+1)): if 0&lt;=x&lt;R and 0&lt;=y&lt;C and w[0]==g[x][y]: if spread(g, x, y, w[1:]): spreaded = True g[i][j] = original print('spreaded &#123;&#125;, recover (&#123;&#125;, &#123;&#125;), after &#123;&#125;'.format(spreaded, i, j, g)) return spreaded for i in range(R): for j in range(C): if g[i][j] == word[0]: if spread(deepcopy(g), i, j, word[1:]): return True return False 输出为: 12345678910111213141516171819202122232425262728293031323334cur -&gt; (0, 0) BCESEEEFS, [[&apos;-&apos;, &apos;B&apos;, &apos;C&apos;, &apos;E&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;E&apos;, &apos;S&apos;], [&apos;A&apos;, &apos;D&apos;, &apos;E&apos;, &apos;E&apos;]]cur -&gt; (0, 1) CESEEEFS, [[&apos;-&apos;, &apos;-&apos;, &apos;C&apos;, &apos;E&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;E&apos;, &apos;S&apos;], [&apos;A&apos;, &apos;D&apos;, &apos;E&apos;, &apos;E&apos;]]cur -&gt; (0, 2) ESEEEFS, [[&apos;-&apos;, &apos;-&apos;, &apos;-&apos;, &apos;E&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;E&apos;, &apos;S&apos;], [&apos;A&apos;, &apos;D&apos;, &apos;E&apos;, &apos;E&apos;]]cur -&gt; (1, 2) SEEEFS, [[&apos;-&apos;, &apos;-&apos;, &apos;-&apos;, &apos;E&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;-&apos;, &apos;S&apos;], [&apos;A&apos;, &apos;D&apos;, &apos;E&apos;, &apos;E&apos;]]cur -&gt; (1, 3) EEEFS, [[&apos;-&apos;, &apos;-&apos;, &apos;-&apos;, &apos;E&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;A&apos;, &apos;D&apos;, &apos;E&apos;, &apos;E&apos;]]cur -&gt; (0, 3) EEFS, [[&apos;-&apos;, &apos;-&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;A&apos;, &apos;D&apos;, &apos;E&apos;, &apos;E&apos;]]spreaded False, recover (0, 3), after [[&apos;-&apos;, &apos;-&apos;, &apos;-&apos;, &apos;E&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;A&apos;, &apos;D&apos;, &apos;E&apos;, &apos;E&apos;]]cur -&gt; (2, 3) EEFS, [[&apos;-&apos;, &apos;-&apos;, &apos;-&apos;, &apos;E&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;A&apos;, &apos;D&apos;, &apos;E&apos;, &apos;-&apos;]]cur -&gt; (2, 2) EFS, [[&apos;-&apos;, &apos;-&apos;, &apos;-&apos;, &apos;E&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;A&apos;, &apos;D&apos;, &apos;-&apos;, &apos;-&apos;]]spreaded False, recover (2, 2), after [[&apos;-&apos;, &apos;-&apos;, &apos;-&apos;, &apos;E&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;A&apos;, &apos;D&apos;, &apos;E&apos;, &apos;-&apos;]]spreaded False, recover (2, 3), after [[&apos;-&apos;, &apos;-&apos;, &apos;-&apos;, &apos;E&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;A&apos;, &apos;D&apos;, &apos;E&apos;, &apos;E&apos;]]spreaded False, recover (1, 3), after [[&apos;-&apos;, &apos;-&apos;, &apos;-&apos;, &apos;E&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;-&apos;, &apos;S&apos;], [&apos;A&apos;, &apos;D&apos;, &apos;E&apos;, &apos;E&apos;]]spreaded False, recover (1, 2), after [[&apos;-&apos;, &apos;-&apos;, &apos;-&apos;, &apos;E&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;E&apos;, &apos;S&apos;], [&apos;A&apos;, &apos;D&apos;, &apos;E&apos;, &apos;E&apos;]]cur -&gt; (0, 3) SEEEFS, [[&apos;-&apos;, &apos;-&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;E&apos;, &apos;S&apos;], [&apos;A&apos;, &apos;D&apos;, &apos;E&apos;, &apos;E&apos;]]cur -&gt; (1, 3) EEEFS, [[&apos;-&apos;, &apos;-&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;E&apos;, &apos;-&apos;], [&apos;A&apos;, &apos;D&apos;, &apos;E&apos;, &apos;E&apos;]]cur -&gt; (2, 3) EEFS, [[&apos;-&apos;, &apos;-&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;E&apos;, &apos;-&apos;], [&apos;A&apos;, &apos;D&apos;, &apos;E&apos;, &apos;-&apos;]]cur -&gt; (2, 2) EFS, [[&apos;-&apos;, &apos;-&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;E&apos;, &apos;-&apos;], [&apos;A&apos;, &apos;D&apos;, &apos;-&apos;, &apos;-&apos;]]cur -&gt; (1, 2) FS, [[&apos;-&apos;, &apos;-&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;A&apos;, &apos;D&apos;, &apos;-&apos;, &apos;-&apos;]]cur -&gt; (1, 1) S, [[&apos;-&apos;, &apos;-&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;S&apos;, &apos;-&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;A&apos;, &apos;D&apos;, &apos;-&apos;, &apos;-&apos;]]spreaded True, recover (1, 1), after [[&apos;-&apos;, &apos;-&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;A&apos;, &apos;D&apos;, &apos;-&apos;, &apos;-&apos;]]spreaded True, recover (1, 2), after [[&apos;-&apos;, &apos;-&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;E&apos;, &apos;-&apos;], [&apos;A&apos;, &apos;D&apos;, &apos;-&apos;, &apos;-&apos;]]spreaded True, recover (2, 2), after [[&apos;-&apos;, &apos;-&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;E&apos;, &apos;-&apos;], [&apos;A&apos;, &apos;D&apos;, &apos;E&apos;, &apos;-&apos;]]spreaded True, recover (2, 3), after [[&apos;-&apos;, &apos;-&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;E&apos;, &apos;-&apos;], [&apos;A&apos;, &apos;D&apos;, &apos;E&apos;, &apos;E&apos;]]cur -&gt; (1, 2) EEFS, [[&apos;-&apos;, &apos;-&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;A&apos;, &apos;D&apos;, &apos;E&apos;, &apos;E&apos;]]cur -&gt; (2, 2) EFS, [[&apos;-&apos;, &apos;-&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;A&apos;, &apos;D&apos;, &apos;-&apos;, &apos;E&apos;]]cur -&gt; (2, 3) FS, [[&apos;-&apos;, &apos;-&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;A&apos;, &apos;D&apos;, &apos;-&apos;, &apos;-&apos;]]spreaded False, recover (2, 3), after [[&apos;-&apos;, &apos;-&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;A&apos;, &apos;D&apos;, &apos;-&apos;, &apos;E&apos;]]spreaded False, recover (2, 2), after [[&apos;-&apos;, &apos;-&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;A&apos;, &apos;D&apos;, &apos;E&apos;, &apos;E&apos;]]spreaded False, recover (1, 2), after [[&apos;-&apos;, &apos;-&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;E&apos;, &apos;-&apos;], [&apos;A&apos;, &apos;D&apos;, &apos;E&apos;, &apos;E&apos;]]spreaded True, recover (1, 3), after [[&apos;-&apos;, &apos;-&apos;, &apos;-&apos;, &apos;-&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;E&apos;, &apos;S&apos;], [&apos;A&apos;, &apos;D&apos;, &apos;E&apos;, &apos;E&apos;]]spreaded True, recover (0, 3), after [[&apos;-&apos;, &apos;-&apos;, &apos;-&apos;, &apos;E&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;E&apos;, &apos;S&apos;], [&apos;A&apos;, &apos;D&apos;, &apos;E&apos;, &apos;E&apos;]]spreaded True, recover (0, 2), after [[&apos;-&apos;, &apos;-&apos;, &apos;C&apos;, &apos;E&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;E&apos;, &apos;S&apos;], [&apos;A&apos;, &apos;D&apos;, &apos;E&apos;, &apos;E&apos;]]spreaded True, recover (0, 1), after [[&apos;-&apos;, &apos;B&apos;, &apos;C&apos;, &apos;E&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;E&apos;, &apos;S&apos;], [&apos;A&apos;, &apos;D&apos;, &apos;E&apos;, &apos;E&apos;]]spreaded True, recover (0, 0), after [[&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;E&apos;], [&apos;S&apos;, &apos;F&apos;, &apos;E&apos;, &apos;S&apos;], [&apos;A&apos;, &apos;D&apos;, &apos;E&apos;, &apos;E&apos;]] 这个例子非常复杂也非常棒，由衷感谢提交这个TestCase的人让我意识到自己的愚蠢，此例子一共做了4次尝试，让我们用图解的方式来还原一下。因为是上下左右这个顺序，所以尝试过程如下： 这一次，我们代码可能通过功能测试了，但是想想如果每个匹配第一个字符串都深拷贝一个数组，如果数组特别大，那么将耗费大量时间，其实我们在做好恢复工作后就不需要在拷贝数组了。将其去掉后： 12345678910111213141516171819202122def exist(self, g: List[List[str]], word: str) -&gt; bool: R, C = len(g), len(g[0]) def spread(i, j, w): if not w: return True original, g[i][j] = g[i][j], '-' spreaded = False for x, y in ((i-1, j), (i+1, j), (i, j-1), (i, j+1)): if 0&lt;=x&lt;R and 0&lt;=y&lt;C and w[0]==g[x][y]: if spread(x, y, w[1:]): spreaded = True g[i][j] = original return spreaded for i in range(R): for j in range(C): if g[i][j] == word[0]: if spread(i, j, word[1:]): return True return False 自信提交后，又被这样一个TestCase教育了，返回超时。 12[[&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a...&quot;baaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot; 想了半天终于明白，我在四个方向寻找是否可以延伸时，只要有一个方向可以，那么我就无需再判断其他方向了。 所以这里加一个break即可。 123456789101112131415161718192021def exist(self, g: List[List[str]], word: str) -&gt; bool: R, C = len(g), len(g[0]) def spread(i, j, w): if not w: return True original, g[i][j] = g[i][j], '-' spreaded = False for x, y in ((i-1, j), (i+1, j), (i, j-1), (i, j+1)): if (0&lt;=x&lt;R and 0&lt;=y&lt;C and w[0]==g[x][y] and spread(x, y, w[1:])): spreaded = True break g[i][j] = original return spreaded for i in range(R): for j in range(C): if g[i][j] == word[0] and spread(i, j, word[1:]): return True return False 以上就是最终的代码，试了一下LeetCode评论区的高票代码，其中有一个写法，将主循环的g[i][j]==word[0]移到了spread中判断，个人觉得这个是为什么比它快了100ms以上的原因。此文中的最终方法AC188ms，而那个代码需要336ms。 通过一番深入的分析，自己对于回溯有了更深一步的认识，同时也明白了一个深刻的道理，不要轻信他人的代码，包括此文中的也是。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithm</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[龟速爬天梯]]></title>
    <url>%2F%E9%BE%9F%E9%80%9F%E7%88%AC%E5%A4%A9%E6%A2%AF%2F</url>
    <content type="text"><![CDATA[好激动，第一次离大神这么近像每个周日一样，9点半起来，然后点了外卖，整理了一下最近的笔记。然后开始等待LeetCode Contest的到来。这周的题确实相对来说比较简单，做着做着发现到了最后一题。然后最后一题也只有Medium难度。感觉还没有Q3难，用了递归就做出来了。 惊奇的发现，居然用了一小时就做完了。以前有时还会卡在第3题，然后看了排行榜，开始还有点担心，Q2是否算作弊，不过后来完成了一看，排行榜前十的大神也是这么写的，而且还没我写的优雅，（虽然用了三方库）。 吃过早饭，然后该review一下题目，优化一下解法并整理到相关博客中。给自己定个小目标，向前200努力。 好气，lee神居然比我先发了答案，我俩的方法是一样的，😦错过了好几个赞。]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法篇目录汇总]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%E7%AF%87%E7%9B%AE%E5%BD%95%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[前言从去年9开始刷算法题，截止到今天，陆续用了大概半年的时间，已经完成《剑指Offer》中的题目，LeetCode中Easy难度的题型也已经基本完成了。由于相关算法博客日益增多，所以建立此目录方便快速查找。另外有一些题型在初期分类不是很合适，所以在完成Easy题之后对所有种类了解的情况下，重新修改一些题的分类。 目录 《剑指Offer》 LeetCode 数组篇 LeetCode 链表篇 LeetCode 二叉树篇 LeetCode 哈希篇 LeetCode 字符串篇 LeetCode 位运算篇 LeetCode 二分法篇 LeetCode 回溯篇 LeetCode 数学篇 LeetCode 设计篇 LeetCode 动态规划篇 LeetCode 贪心篇 LeetCode 正则篇 LeetCode 图篇 LeetCode sql篇 总结目前收录大概不到300题，但是并没有追求数量，每道题都是先思考用自己的方法做，然后再不断地优化，最后结合Solution和Discuss里大神的写法进行修改。一开始有时候一道题想好几天，后来一天可以完成5，6道题，期间也通过Weekly Contest来测试自己，前几次只能做出一两道题，后来有时候甚至最后一题也差点几步就完成，收货颇丰。刷到差不多后半段的时候，基本上有些题就是换汤不换药，可以用之前的解法做出来，或者是几道题的步骤加起来。 关于分类，因为LeetCode中的分类其实是多对多的关系，这里博客中并不想记录重复的题，所以分类是没有按照LeetCode中来分的，有时候会根据题目分类，有时候会根据答案的最优解分类。答案中标记绿色的部分表示是最优解，但不唯一；极个别用红色标出为错误答案，因为具有强烈的误导性，所以记录下来。 期间在Discuss中单方面结识了两位大神，一位叫Stefan Pochmann，另一位叫lee215。两者都是万星大神，博客中有一些题的最优解都是这两位的答案。前者在小题号时比较活跃，后者在大题号时较活跃，他们俩的答案总是给人眼前一亮的感觉，从中学习到了很多，也能应用到其它一些题上。 关于周赛，周赛的时候感觉又和刷别的题不一样，周赛一般的解法偏向于解答速度，有什么现成的库就直接用，哪个解法最稳用那个，因为Bug会有惩罚时间，排行榜前十的也是这么做的。而平时刷题更倾向于时间复杂度和空间复杂度低，并且写法优雅。 有时候Discuss中也没有自己满意的答案，也会自己冥思苦想想出一个优雅的解法，然后Share给大家，获得几个点赞。这种赞同还有看到Contest上升的排名，都会让自己信心十足，去面对更加艰难的挑战。2019年给自己定了一个小目标，解题达到500+，rating达到1800+，star达到200+。接下来准备重新整理一下目前的题，然后按照类别进行一次解答，疑难题会记录到LeetCode的flashcard中反复训练。不断告诉自己，不要为了刷题而刷题，重要的是思考的过程。然后优化一些还不够优雅的答案，最后迈向Medium难度。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode算法题整理（图篇）Graph]]></title>
    <url>%2FLeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E5%9B%BE%E7%AF%87%EF%BC%89Graph%2F</url>
    <content type="text"><![CDATA[990. Satisfiability of Equality Equations满足所有方程式，判断是否存在变量的值满足所有的等式与不等式。原题解析：所有的相等的点，在图中是联通的。 123456789Input: [&quot;a==b&quot;,&quot;b!=a&quot;]Output: falseExplanation: If we assign say, a = 1 and b = 1, then the first equation is satisfied, but not the second. There is no way to assign the variables to satisfy both equations.Input: [&quot;a==b&quot;,&quot;b==c&quot;,&quot;a==c&quot;]Output: trueInput: [&quot;a==b&quot;,&quot;b!=c&quot;,&quot;c==a&quot;]Output: false 方法一：set. 1234567891011121314151617181920def equationsPossible(self, equations: 'List[str]') -&gt; 'bool': equals = [] equations.sort(key=operator.itemgetter(1), reverse=True) # print(equations) for x, e, _, y in equations: if e == '=': for i, eq in enumerate(equals): if x in eq or y in eq: equals[i].update(&#123;x, y&#125;) break else: equals.append(&#123;x, y&#125;) else: if x == y: return False for eq in equals: if x in eq and y in eq: return False # print(equals) return True 方法二：union find. 并查集。find方法可以想象成一个链表，返回的是链表末尾key,val相等的元素。同时建立连接关系。如a==b, b==c时fc={&#39;a&#39;: &#39;b&#39;, &#39;b&#39;: &#39;c&#39;, &#39;c&#39;: &#39;c&#39;}比较a!=c时就会最终找到fc[&#39;a&#39;] == &#39;c&#39;；如a==b, c==a时，fc={&#39;a&#39;: &#39;b&#39;, &#39;b&#39;: &#39;b&#39;, &#39;c&#39;: &#39;b&#39;}。 12345678910111213141516def equationsPossible(self, equations: 'List[str]') -&gt; 'bool': equations.sort(key=lambda e: e[1] == '!') uf = &#123;a: a for a in string.ascii_lowercase&#125; def find(x): if x != uf[x]: uf[x] = find(uf[x]) return uf[x] for a, e, _, b in equations: if e == "=": uf[find(a)] = find(b) else: if find(a) == find(b): return False return True 997. Find the Town Judge找到小镇审判长。审判长被除自己以外的所有人信任，并且不信任任何人。根据信任列表找出审判长。原题123456Input: N = 4, trust = [[1,3],[1,4],[2,3],[2,4],[4,3]]Output: 3Input: N = 3, trust = [[1,3],[2,3],[3,1]]Output: -1Input: N = 3, trust = [[1,3],[2,3]]Output: 3 方法一：brute force. 123456789101112def findJudge(self, N: int, trust: List[List[int]]) -&gt; int: if not trust: return N a, b = zip(*trust) candidates = collections.Counter(b) villages = set(a) for c, votes in candidates.most_common(): if votes &lt; N - 1: return -1 if c not in villages: return c return -1 方法二：定向图。 12345678910def findJudge(self, N: int, trust: List[List[int]]) -&gt; int: count = [0] * (N + 1) for i, j in trust: count[i] -= 1 count[j] += 1 print(count) for i in range(1, N + 1): if count[i] == N - 1: return i return -1 133. Clone Graph深拷贝一个简单环。原题 1234567891011def cloneGraph(self, node: 'Node') -&gt; 'Node': cp = collections.defaultdict(lambda: Node(0, [])) nodes = [node] seen = set() while nodes: n = nodes.pop() cp[n].val = n.val cp[n].neighbors = [cp[x] for x in n.neighbors] nodes.extend(x for x in n.neighbors if x not in seen) seen.add(n) return cp[node]]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
        <tag>Algorithm</tag>
        <tag>Graph</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode算法题整理（哈希篇）hashtable]]></title>
    <url>%2FLeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E5%93%88%E5%B8%8C%E7%AF%87%EF%BC%89hashtable%2F</url>
    <content type="text"><![CDATA[1. Two Sum给定一个数组，找出数组两个元素相加为目标值，假定只有唯一解。原题123Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. 1234567def two_sum(nums, target): buff_dict = &#123;&#125; for i, num in enumerate(nums): if num not in buff_dict: buff_dict[target-num] = i else: return [buff_dict[num], i] 720. Longest Word in Dictionary字典中的最长单词，找出一个列表中的一个单词，该单词的子单词也必须在字典中。相同长度的单词，返回字典序最前的一个。原题12345Input: words = [&quot;w&quot;,&quot;wo&quot;,&quot;wor&quot;,&quot;worl&quot;, &quot;world&quot;]Output: &quot;world&quot;Explanation: The word &quot;world&quot; can be built one character at a time by &quot;w&quot;, &quot;wo&quot;, &quot;wor&quot;, and &quot;worl&quot;. 方法一：Brute Force. 12345678def longestWord(self, words): res = '' wordset = set(words) for word in words: if len(word)&gt;len(res) or len(word)==len(res) and word&lt;res: if all(word[:k] in wordset for k in range(1, len(word))): res = word return res 方法二：trie. 暂且留坑。 748. Shortest Completing Word最短的完整匹配单词。包含licensePlate中的所有字母，大小写不敏感。假设答案一定存在。原题12345Input: licensePlate = &quot;1s3 PSt&quot;, words = [&quot;step&quot;, &quot;steps&quot;, &quot;stripe&quot;, &quot;stepple&quot;]Output: &quot;steps&quot;Explanation: The smallest length word that contains the letters &quot;S&quot;, &quot;P&quot;, &quot;S&quot;, and &quot;T&quot;.Note that the answer is not &quot;step&quot;, because the letter &quot;s&quot; must occur in the word twice.Also note that we ignored case for the purposes of comparing whether a letter exists in the word. 方法一：先排序。 123456789def shortestCompletingWord(self, licensePlate: 'str', words: 'List[str]') -&gt; 'str': lp = ''.join(x for x in licensePlate.lower() if x.isalpha()) c1 = collections.Counter(lp) words.sort(key=len) words = map(str.lower, words) for word in words: diff = c1 - collections.Counter(word) if not diff: return word 方法二：more elegant. 123456def shortestCompletingWord(self, licensePlate: 'str', words: 'List[str]') -&gt; 'str': lp = ''.join(x for x in licensePlate.lower() if x.isalpha()) c1 = collections.Counter(lp) words = map(str.lower, words) return min((word for word in words if not c1-collections.Counter(word)), key=len) 方法三：most efficient. 认为方法二是在计算-的操作时，涉及一些无关的key导致效率过低。 1234567891011121314def shortestCompletingWord(self, licensePlate: 'str', words: 'List[str]') -&gt; 'str': ans = '' lp = ''.join(x for x in licensePlate.lower() if x.isalpha()) for w in words: temp = list(w.lower()) for l in lp: if l in temp: temp.remove(l) else: break else: if len(w)&lt;len(ans) or ans=='': ans = w return ans 811. Subdomain Visit Count子域名访问量。给定一个三级或二级域名列表，统计所有三级、二级和顶级域名的访问量。原题1234567Example 1:Input: [&quot;9001 discuss.leetcode.com&quot;]Output: [&quot;9001 discuss.leetcode.com&quot;, &quot;9001 leetcode.com&quot;, &quot;9001 com&quot;]Explanation: We only have one website domain: &quot;discuss.leetcode.com&quot;. As discussed above, the subdomain &quot;leetcode.com&quot; and &quot;com&quot; will also be visited. So they will all be visited 9001 times. 方法一：Solution中用了Counter，个人认为defaultdict. 123456789def subdomainVisits(self, cpdomains: 'List[str]') -&gt; 'List[str]': ans = collections.defaultdict(int) for domain in cpdomains: count, d = domain.split() count = int(count) frags = d.split('.') for i in range(len(frags)): ans['.'.join(frags[i:])] += count return ['&#123;&#125; &#123;&#125;'.format(c, d) for d, c in ans.items()] 884. Uncommon Words from Two Sentences求两句话中的单词，在本句中出现一次，并不在另一句中的单词。也就是在两句中出现一次。原题12Input: A = &quot;this apple is sweet&quot;, B = &quot;this apple is sour&quot;Output: [&quot;sweet&quot;,&quot;sour&quot;] 方法一：Counter 1234def uncommonFromSentences(self, A: 'str', B: 'str') -&gt; 'List[str]': from collections import Counter count = Counter((A + ' ' + B).split()) return [word for word, c in count.items() if c == 1] 1013. Pairs of Songs With Total Durations Divisible by 60和能被60整除的为一对，求有多少对。原题123456Input: [30,20,150,100,40]Output: 3Explanation: Three pairs have a total duration divisible by 60:(time[0] = 30, time[2] = 150): total duration 180(time[1] = 20, time[3] = 100): total duration 120(time[1] = 20, time[4] = 40): total duration 60 12345678def numPairsDivisibleBy60(self, time: List[int]) -&gt; int: c = collections.defaultdict(int) ans = 0 for t in time: # ans += c[(60-t%60)%60] ans += c[-t % 60] c[t%60] += 1 return ans]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
        <tag>Algorithm</tag>
        <tag>HashTable</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode算法题整理（贪心篇）Greedy]]></title>
    <url>%2FLeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E8%B4%AA%E5%BF%83%E7%AF%87%EF%BC%89greedy%2F</url>
    <content type="text"><![CDATA[984. String Without AAA or BBB生成字符串没有‘aaa’和’bbb’。原题123Input: A = 1, B = 2Output: &quot;abb&quot;Explanation: &quot;abb&quot;, &quot;bab&quot; and &quot;bba&quot; are all correct answers. 123456789101112131415def strWithout3a3b(self, A, B): ans = '' while A or B: if len(ans) &gt;= 2 and ans[-1]==ans[-2]: writeA = ans[-1]=='b' else: writeA = A&gt;=B if writeA: A -= 1 ans += 'a' else: B -= 1 ans += 'b' return ans 455. Assign Cookies发小饼干，s为若干个饼干的大小，g为每个人需要的大小，没人发的饼干不能比要求的size小，问最多可以满足几个人。原题1234567Input: [1,2], [1,2,3]Output: 2Explanation: You have 2 children and 3 cookies. The greed factors of 2 children are 1, 2. You have 3 cookies and their sizes are big enough to gratify all of the children, You need to output 2. 12345678def findContentChildren(self, g: List[int], s: List[int]) -&gt; int: g.sort() s.sort() i = j = 0 while i &lt; len(g) and j &lt; len(s): i += s[j] &gt;= g[i] j += 1 return i 860. Lemonade Change柠檬找零，每人买一个柠檬，（价值5）可能付5, 10, 20面值的钞票，问零钱是否能找开。原题1234567Input: [5,5,5,10,20]Output: trueExplanation: From the first 3 customers, we collect three $5 bills in order.From the fourth customer, we collect a $10 bill and give back a $5.From the fifth customer, we give a $10 bill and a $5 bill.Since all customers got correct change, we output true. 方法一：defaultdict。 123456789101112131415def lemonadeChange(self, bills: 'List[int]') -&gt; 'bool': c = collections.defaultdict(int) for bill in bills: if bill == 10: c[5] -= 1 elif bill == 20: if c[10] &gt;= 1: c[10] -= 1 c[5] -= 1 else: c[5] -= 3 if c[5] &lt; 0: return False c[bill] += 1 return True 944. Delete Columns to Make Sorted找出并行项中未排序的个数。原题方法一：sorted要比any快，感觉是Cpython的优化导致，理论上来说应该是any快。 1234567def minDeletionSize(self, A: 'List[str]') -&gt; 'int': ans = 0 for col in zip(*A): # if any(col[i]&gt;col[i+1] for i in range(len(col)-1)): if sorted(col) != list(col): ans += 1 return ans 55. Jump Game跳跃游戏，数组中每个元素表示下一步的距离，问是否能跳到最后索引位置。原题123Input: [2,3,1,1,4]Output: trueExplanation: Jump 1 step from index 0 to 1, then 3 steps to the last index. 方法一：贪心。 123456def canJump(self, nums: List[int]) -&gt; bool: last_pos = len(nums) - 1 for i in range(len(nums)-1, -1, -1): if i + nums[i] &gt;= last_pos: last_pos = i return last_pos == 0 1005. Maximize Sum Of Array After K NegationsK次取负后的数组最大和。原题123Input: A = [3,-1,0,2], K = 3Output: 6Explanation: Choose indices (1, 2, 2) and A becomes [3,1,0,2]. 方法一：竞赛的时候，写得比较麻烦，分了两个数组，还考虑了0，后来看lee神的整理一下。注意最后一步要用一下min，否则获取不了最小值。 1234567def largestSumAfterKNegations(self, A: List[int], K: int) -&gt; int: A.sort() i = 0 while i&lt;len(A) and i&lt;K and A[i]&lt;0: A[i] = -A[i] i += 1 return sum(A) - (K-i)%2*min(A)*2]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
        <tag>Algorithm</tag>
        <tag>Greedy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一次淘宝接口sign签名破解]]></title>
    <url>%2F%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%B7%98%E5%AE%9D%E6%8E%A5%E5%8F%A3sign%E7%AD%BE%E5%90%8D%E7%A0%B4%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[淘宝H5页面接口Sign签名破解前言：由于公司业务需求，需要显示淘宝商品详情页面的图文详情部分。之前原业务逻辑是根据https://world.taobao.com/item/{num_iid}.htm，在得到html文本后全量通过图片前缀名如https://img.alicdn.com/imgextra进行抓取，返回给客户端。 由于header中的UA传的一个PC端的UA，所以获取的H5数据中，可能含有一些广告，商家之类自己的布局，从而无法在客户端正常展示。另一方面，该接口为高频接口，打开htm页面每次耗时70~80%，严重影响客户端体验，所以对此将接口进行升级。 后来发现手机上打开该页面是不显示一些无关的广告的，而且布局也正常。于是将UA改为了手机端的UA，然后通过抓包分析，返回的页面是一个不包含图片的html，图文详情是根据js接口调用动态渲染。接口为https://h5api.m.taobao.com/h5/mtop.wdetail.getitemdescx/4.9/?jsv=2.4.11&amp;appKey=12574478&amp;t=1544165283634&amp;sign=c691925755f2ff429c950f7b00903a23&amp;api=mtop.wdetail.getItemDescx&amp;v=4.9&amp;type=jsonp&amp;dataType=jsonp&amp;callback=mtopjsonp6&amp;data=%7B%22item_num_id%22%3A%22554401452734%22%7D。看到参数中包含了sign，所以是根据某种规则算出来的签名。 接着就是找到sign的签名算法了，将页面中的js格式化了一下。找到关于sign签名的部分。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107s.prototype.__processRequestUrl = function(n) &#123; &#123;var e = this.params, r = this.options; if (r.hostSetting &amp;&amp; r.hostSetting[t.location.hostname]) &#123; var o = r.hostSetting[t.location.hostname]; o.prefix &amp;&amp; (r.prefix = o.prefix), o.subDomain &amp;&amp; (r.subDomain = o.subDomain), o.mainDomain &amp;&amp; (r.mainDomain = o.mainDomain) &#125; if (!0 === r.H5Request) &#123; var i = "//" + (r.prefix ? r.prefix + ".": "") + (r.subDomain ? r.subDomain + ".": "") + r.mainDomain + "/h5/" + e.api.toLowerCase() + "/" + e.v.toLowerCase() + "/", a = e.appKey || ("waptest" === r.subDomain ? "4272": "12574478"), c = (new Date).getTime(), u = function(t) &#123; function n(t, n) &#123; return t &lt;&lt; n | t &gt;&gt;&gt; 32 - n &#125; function e(t, n) &#123; var e, r, o, i, a; return o = 2147483648 &amp; t, i = 2147483648 &amp; n, a = (1073741823 &amp; t) + (1073741823 &amp; n), (e = 1073741824 &amp; t) &amp; (r = 1073741824 &amp; n) ? 2147483648 ^ a ^ o ^ i: e | r ? 1073741824 &amp; a ? 3221225472 ^ a ^ o ^ i: 1073741824 ^ a ^ o ^ i: a ^ o ^ i &#125; function r(t, r, o, i, a, c, u) &#123; return e(n(t = e(t, e(e(function(t, n, e) &#123; return t &amp; n | ~t &amp; e &#125; (r, o, i), a), u)), c), r) &#125; function o(t, r, o, i, a, c, u) &#123; return e(n(t = e(t, e(e(function(t, n, e) &#123; return t &amp; e | n &amp; ~e &#125; (r, o, i), a), u)), c), r) &#125; function i(t, r, o, i, a, c, u) &#123; return e(n(t = e(t, e(e(function(t, n, e) &#123; return t ^ n ^ e &#125; (r, o, i), a), u)), c), r) &#125; function a(t, r, o, i, a, c, u) &#123; return e(n(t = e(t, e(e(function(t, n, e) &#123; return n ^ (t | ~e) &#125; (r, o, i), a), u)), c), r) &#125; function c(t) &#123; var n, e = "", r = ""; for (n = 0; 3 &gt;= n; n++) e += (r = "0" + (t &gt;&gt;&gt; 8 * n &amp; 255).toString(16)).substr(r.length - 2, 2); return e &#125; var u, s, f, l, p, d, h, v, m, g; for (g = function(t) &#123; for (var n, e = t.length, r = e + 8, o = 16 * ((r - r % 64) / 64 + 1), i = new Array(o - 1), a = 0, c = 0; e &gt; c;) a = c % 4 * 8, i[n = (c - c % 4) / 4] = i[n] | t.charCodeAt(c) &lt;&lt; a, c++; return a = c % 4 * 8, i[n = (c - c % 4) / 4] = i[n] | 128 &lt;&lt; a, i[o - 2] = e &lt;&lt; 3, i[o - 1] = e &gt;&gt;&gt; 29, i &#125; (t = function(t) &#123; t = t.replace(/\r\n/g, "\n"); for (var n = "", e = 0; e &lt; t.length; e++) &#123; var r = t.charCodeAt(e); 128 &gt; r ? n += String.fromCharCode(r) : r &gt; 127 &amp;&amp; 2048 &gt; r ? (n += String.fromCharCode(r &gt;&gt; 6 | 192), n += String.fromCharCode(63 &amp; r | 128)) : (n += String.fromCharCode(r &gt;&gt; 12 | 224), n += String.fromCharCode(r &gt;&gt; 6 &amp; 63 | 128), n += String.fromCharCode(63 &amp; r | 128)) &#125; return n &#125; (t)), d = 1732584193, h = 4023233417, v = 2562383102, m = 271733878, u = 0; u &lt; g.length; u += 16) s = d, f = h, l = v, p = m, h = a(h = a(h = a(h = a(h = i(h = i(h = i(h = i(h = o(h = o(h = o(h = o(h = r(h = r(h = r(h = r(h, v = r(v, m = r(m, d = r(d, h, v, m, g[u + 0], 7, 3614090360), h, v, g[u + 1], 12, 3905402710), d, h, g[u + 2], 17, 606105819), m, d, g[u + 3], 22, 3250441966), v = r(v, m = r(m, d = r(d, h, v, m, g[u + 4], 7, 4118548399), h, v, g[u + 5], 12, 1200080426), d, h, g[u + 6], 17, 2821735955), m, d, g[u + 7], 22, 4249261313), v = r(v, m = r(m, d = r(d, h, v, m, g[u + 8], 7, 1770035416), h, v, g[u + 9], 12, 2336552879), d, h, g[u + 10], 17, 4294925233), m, d, g[u + 11], 22, 2304563134), v = r(v, m = r(m, d = r(d, h, v, m, g[u + 12], 7, 1804603682), h, v, g[u + 13], 12, 4254626195), d, h, g[u + 14], 17, 2792965006), m, d, g[u + 15], 22, 1236535329), v = o(v, m = o(m, d = o(d, h, v, m, g[u + 1], 5, 4129170786), h, v, g[u + 6], 9, 3225465664), d, h, g[u + 11], 14, 643717713), m, d, g[u + 0], 20, 3921069994), v = o(v, m = o(m, d = o(d, h, v, m, g[u + 5], 5, 3593408605), h, v, g[u + 10], 9, 38016083), d, h, g[u + 15], 14, 3634488961), m, d, g[u + 4], 20, 3889429448), v = o(v, m = o(m, d = o(d, h, v, m, g[u + 9], 5, 568446438), h, v, g[u + 14], 9, 3275163606), d, h, g[u + 3], 14, 4107603335), m, d, g[u + 8], 20, 1163531501), v = o(v, m = o(m, d = o(d, h, v, m, g[u + 13], 5, 2850285829), h, v, g[u + 2], 9, 4243563512), d, h, g[u + 7], 14, 1735328473), m, d, g[u + 12], 20, 2368359562), v = i(v, m = i(m, d = i(d, h, v, m, g[u + 5], 4, 4294588738), h, v, g[u + 8], 11, 2272392833), d, h, g[u + 11], 16, 1839030562), m, d, g[u + 14], 23, 4259657740), v = i(v, m = i(m, d = i(d, h, v, m, g[u + 1], 4, 2763975236), h, v, g[u + 4], 11, 1272893353), d, h, g[u + 7], 16, 4139469664), m, d, g[u + 10], 23, 3200236656), v = i(v, m = i(m, d = i(d, h, v, m, g[u + 13], 4, 681279174), h, v, g[u + 0], 11, 3936430074), d, h, g[u + 3], 16, 3572445317), m, d, g[u + 6], 23, 76029189), v = i(v, m = i(m, d = i(d, h, v, m, g[u + 9], 4, 3654602809), h, v, g[u + 12], 11, 3873151461), d, h, g[u + 15], 16, 530742520), m, d, g[u + 2], 23, 3299628645), v = a(v, m = a(m, d = a(d, h, v, m, g[u + 0], 6, 4096336452), h, v, g[u + 7], 10, 1126891415), d, h, g[u + 14], 15, 2878612391), m, d, g[u + 5], 21, 4237533241), v = a(v, m = a(m, d = a(d, h, v, m, g[u + 12], 6, 1700485571), h, v, g[u + 3], 10, 2399980690), d, h, g[u + 10], 15, 4293915773), m, d, g[u + 1], 21, 2240044497), v = a(v, m = a(m, d = a(d, h, v, m, g[u + 8], 6, 1873313359), h, v, g[u + 15], 10, 4264355552), d, h, g[u + 6], 15, 2734768916), m, d, g[u + 13], 21, 1309151649), v = a(v, m = a(m, d = a(d, h, v, m, g[u + 4], 6, 4149444226), h, v, g[u + 11], 10, 3174756917), d, h, g[u + 2], 15, 718787259), m, d, g[u + 9], 21, 3951481745), d = e(d, s), h = e(h, f), v = e(v, l), m = e(m, p); return (c(d) + c(h) + c(v) + c(m)).toLowerCase() &#125; (r.token + "&amp;" + c + "&amp;" + a + "&amp;" + e.data), s = &#123; jsv: "2.4.11", appKey: a, t: c, sign: u &#125;, f = &#123; data: e.data, ua: e.ua &#125;; Object.keys(e).forEach(function(t) &#123; "undefined" == typeof s[t] &amp;&amp; "undefined" == typeof f[t] &amp;&amp; "headers" !== t &amp;&amp; "ext_headers" !== t &amp;&amp; "ext_querys" !== t &amp;&amp; (s[t] = e[t]) &#125;), e.ext_querys &amp;&amp; Object.keys(e.ext_querys).forEach(function(t) &#123; s[t] = e.ext_querys[t] &#125;), r.getJSONP ? s.type = "jsonp": r.getOriginalJSONP ? s.type = "originaljsonp": (r.getJSON || r.postJSON) &amp;&amp; (s.type = "originaljson"), "undefined" != typeof e.valueType &amp;&amp; ("original" === e.valueType ? r.getJSONP || r.getOriginalJSONP ? s.type = "originaljsonp": (r.getJSON || r.postJSON) &amp;&amp; (s.type = "originaljson") : "string" === e.valueType &amp;&amp; (r.getJSONP || r.getOriginalJSONP ? s.type = "jsonp": (r.getJSON || r.postJSON) &amp;&amp; (s.type = "json"))), !0 === r.useJsonpResultType &amp;&amp; "originaljson" === s.type &amp;&amp; delete s.type, r.dangerouslySetProtocol &amp;&amp; (i = r.dangerouslySetProtocol + ":" + i), r.querystring = s, r.postdata = f, r.path = i &#125; n()&#125;,&#125; 看到这里应该是一个加密后的js，后来找到一篇文章。淘宝sign加密算法。根据抓包的参数，按照公式来计算sign，验证算法是否正确。可能由于时间戳没有取整，或者一些其他的原因如编码问题等，导致sign的值没有和正确值对上，又看到文中贴的代码比我找到的js更加简单，以为淘宝更新了算法。再后来一位知友提示说算法没有问题，（在此特别感谢知友Jaho及文章作者小歪）才又抓包试了一次，这次将毫秒时间戳转为了int，并将字符串进行utf8编码，算出来的sign值和抓包中的匹配。后来证实通过js断点调试也可以验证公式的正确性。sign生成公式为：md5Hex(token&amp;t&amp;appKey&amp;data)t表示毫秒时间戳，appKey一般为固定值。data为参数。本文中的例子为6b2310e47a950f1c8c3fe6ec792f356a&amp;1544165283634&amp;12574478&amp;{&quot;item_num_id&quot;:&quot;554401452734&quot;}再进行md5转换。 知道了sign算法，接下来就是token的获取，根据知乎文中作者所说，第一次请求是会设置cookie，于是使用Postman清理cookie后请求，此时sign的值传任何值均无影响，接口会返回 123456mtopjsonp2(&#123; "api": "mtop.wdetail.getItemDescx", "v": "4.9", "ret": ["FAIL_SYS_TOKEN_EXOIRED::令牌过期"], "data": &#123;&#125;&#125;) 并设置两个cookie，一个是_m_h5_tk值为6b2310e47a950f1c8c3fe6ec792f356a_1544173923544，另一个是_m_h5_tk_enc，这个目前用不到，我们要的token就是前者_分割的前部分。这样一来，我们请求两次接口，第一次拿到token，第二次请求拿到数据。 123456789101112131415161718192021222324252627282930313233343536&#123; "api": "mtop.wdetail.getItemDescx", "data": &#123; "pages": [ "&lt;txt&gt;特别提醒：此款收纳箱尺寸测量方法：（盖上盖子测量长宽高）长度=盖子+把手。手工量的，稍许误差，谢谢谅解！ 注意：不要把本店的L数跟超市的比较，本店的L数是网上笼统的叫法，以箱子实际尺寸为主，介意的亲请勿拍！建议：店长推荐拍套装几个套在一起 可以抗摔 。。10L不建议购买只能装一些小东西人工测量会有2cm左右误差属于正常现象温馨提醒：塑料属于易碎品，为了免去亲的麻烦，请亲在收货时先拆开检查后在签收，如有破损请直接拒收&lt;/txt&gt;&lt;img&gt;https://img.alicdn.com/imgextra/i3/2651141793/TB2kQKqbgsSMeJjSspcXXXjFXXa_!!2651141793.jpg&lt;/img&gt;&lt;img&gt;https://img.alicdn.com/imgextra/i1/2651141793/TB2UkPszC8mpuFjSZFMXXaxpVXa_!!2651141793.jpg&lt;/img&gt;&lt;img&gt;https://img.alicdn.com/imgextra/i3/2651141793/TB2dJSBzstnpuFjSZFKXXalFFXa_!!2651141793.jpg&lt;/img&gt;&lt;img&gt;https://img.alicdn.com/imgextra/i4/2651141793/TB2U3i5zxxmpuFjSZFNXXXrRXXa_!!2651141793.jpg&lt;/img&gt;&lt;img&gt;https://img.alicdn.com/imgextra/i1/2651141793/TB22qfEzr4npuFjSZFmXXXl4FXa_!!2651141793.jpg&lt;/img&gt;&lt;img&gt;https://img.alicdn.com/imgextra/i2/2651141793/TB2_8HcvbJkpuFjy1zcXXa5FFXa_!!2651141793.jpg&lt;/img&gt;", "&lt;img&gt;https://img.alicdn.com/imgextra/i1/2651141793/TB2f7YszC8mpuFjSZFMXXaxpVXa_!!2651141793.jpg&lt;/img&gt;&lt;img&gt;https://img.alicdn.com/imgextra/i3/2651141793/TB2B600zrBnpuFjSZFGXXX51pXa_!!2651141793.jpg&lt;/img&gt;&lt;img&gt;https://img.alicdn.com/imgextra/i4/2651141793/TB2C.HmvgFkpuFjSspnXXb4qFXa_!!2651141793.jpg&lt;/img&gt;&lt;img&gt;https://img.alicdn.com/imgextra/i3/2651141793/TB25AYszC8mpuFjSZFMXXaxpVXa_!!2651141793.jpg&lt;/img&gt;&lt;img&gt;https://img.alicdn.com/imgextra/i3/2651141793/TB2Tt1BzstnpuFjSZFKXXalFFXa_!!2651141793.jpg&lt;/img&gt;&lt;img&gt;https://img.alicdn.com/imgextra/i3/2651141793/TB2FNPgvgxlpuFjSszbXXcSVpXa_!!2651141793.jpg&lt;/img&gt;&lt;img&gt;https://img.alicdn.com/imgextra/i2/2651141793/TB26j40zrBnpuFjSZFGXXX51pXa_!!2651141793.jpg&lt;/img&gt;&lt;img&gt;https://img.alicdn.com/imgextra/i4/2651141793/TB2uDGozCVmpuFjSZFFXXcZApXa_!!2651141793.jpg&lt;/img&gt;", "&lt;img&gt;https://img.alicdn.com/imgextra/i1/2651141793/TB2Bx9ntxRDOuFjSZFzXXcIipXa_!!2651141793.jpg&lt;/img&gt;&lt;img&gt;https://img.alicdn.com/imgextra/i2/2651141793/TB2nSblvm0jpuFjy0FlXXc0bpXa_!!2651141793.jpg&lt;/img&gt;&lt;img&gt;https://img.alicdn.com/imgextra/i2/2651141793/TB2wtaQvbXlpuFjSszfXXcSGXXa_!!2651141793.jpg&lt;/img&gt;&lt;img&gt;https://img.alicdn.com/imgextra/i4/2651141793/TB2k1vfvl4lpuFjy1zjXXcAKpXa_!!2651141793.jpg&lt;/img&gt;&lt;img&gt;https://img.alicdn.com/imgextra/i1/2651141793/TB26HbQvbFkpuFjy1XcXXclapXa_!!2651141793.jpg&lt;/img&gt;&lt;img&gt;https://img.alicdn.com/imgextra/i3/2651141793/TB24miYzypnpuFjSZFIXXXh2VXa_!!2651141793.jpg&lt;/img&gt;&lt;txt&gt;.................welcome20160618152824&lt;/txt&gt;" ], "images": [ "https://img.alicdn.com/imgextra/i3/2651141793/TB2kQKqbgsSMeJjSspcXXXjFXXa_!!2651141793.jpg", "https://img.alicdn.com/imgextra/i1/2651141793/TB2UkPszC8mpuFjSZFMXXaxpVXa_!!2651141793.jpg", "https://img.alicdn.com/imgextra/i3/2651141793/TB2dJSBzstnpuFjSZFKXXalFFXa_!!2651141793.jpg", "https://img.alicdn.com/imgextra/i4/2651141793/TB2U3i5zxxmpuFjSZFNXXXrRXXa_!!2651141793.jpg", "https://img.alicdn.com/imgextra/i1/2651141793/TB22qfEzr4npuFjSZFmXXXl4FXa_!!2651141793.jpg", "https://img.alicdn.com/imgextra/i2/2651141793/TB2_8HcvbJkpuFjy1zcXXa5FFXa_!!2651141793.jpg", "https://img.alicdn.com/imgextra/i1/2651141793/TB2f7YszC8mpuFjSZFMXXaxpVXa_!!2651141793.jpg", "https://img.alicdn.com/imgextra/i3/2651141793/TB2B600zrBnpuFjSZFGXXX51pXa_!!2651141793.jpg", "https://img.alicdn.com/imgextra/i4/2651141793/TB2C.HmvgFkpuFjSspnXXb4qFXa_!!2651141793.jpg", "https://img.alicdn.com/imgextra/i3/2651141793/TB25AYszC8mpuFjSZFMXXaxpVXa_!!2651141793.jpg", "https://img.alicdn.com/imgextra/i3/2651141793/TB2Tt1BzstnpuFjSZFKXXalFFXa_!!2651141793.jpg", "https://img.alicdn.com/imgextra/i3/2651141793/TB2FNPgvgxlpuFjSszbXXcSVpXa_!!2651141793.jpg", "https://img.alicdn.com/imgextra/i2/2651141793/TB26j40zrBnpuFjSZFGXXX51pXa_!!2651141793.jpg", "https://img.alicdn.com/imgextra/i4/2651141793/TB2uDGozCVmpuFjSZFFXXcZApXa_!!2651141793.jpg", "https://img.alicdn.com/imgextra/i1/2651141793/TB2Bx9ntxRDOuFjSZFzXXcIipXa_!!2651141793.jpg", "https://img.alicdn.com/imgextra/i2/2651141793/TB2nSblvm0jpuFjy0FlXXc0bpXa_!!2651141793.jpg", "https://img.alicdn.com/imgextra/i2/2651141793/TB2wtaQvbXlpuFjSszfXXcSGXXa_!!2651141793.jpg", "https://img.alicdn.com/imgextra/i4/2651141793/TB2k1vfvl4lpuFjy1zjXXcAKpXa_!!2651141793.jpg", "https://img.alicdn.com/imgextra/i1/2651141793/TB26HbQvbFkpuFjy1XcXXclapXa_!!2651141793.jpg", "https://img.alicdn.com/imgextra/i3/2651141793/TB24miYzypnpuFjSZFIXXXh2VXa_!!2651141793.jpg" ] &#125;, "ret": [ "SUCCESS::接口调用成功" ], "v": "4.9"&#125; 其中的images数组就是我想要的数据，这里返回值不是标准的json，套了一层mtopjsonp2({JSON})，于是获取结果后还要根据正则截取一下json的文本。 附上部分相关代码，python版本 123456789101112131415161718192021222324252627282930313233343536def get_images_from_mtop(num_iid): APPKEY = '12574478' DATA = '&#123;"item_num_id":"%s"&#125;' % num_iid URL = 'https://h5api.m.taobao.com/h5/mtop.wdetail.getitemdescx/4.9/' params = &#123;'jsv': '2.4.11', 'appKey': APPKEY, 't': int(time.time()*1000), 'sign': 'FAKE_SIGN_WITH_ANYTHING', 'api': 'mtop.wdetail.getItemDescx', 'v': '4.9', 'type': 'jsonp', 'dataType': 'jsonp', 'callback': 'mtopjsonp2', 'data': DATA&#125; headers = &#123; 'User-Agent': 'Mozilla/5.0 (iPhone; CPU iPhone OS 9_3_4 like Mac OS X) AppleWebKit/601.1.46 ' + \ '(KHTML, like Gecko) Version/9.0 Mobile/13G35 Safari/601.1', &#125; images = [] try: # get token in first request r1 = requests.get(URL, params=params, headers=headers) token_with_time = r1.cookies.get('_m_h5_tk') token = token_with_time.split('_')[0] enc_token = r1.cookies.get('_m_h5_tk_enc') logger.debug(r1.cookies) # get results in second request t2 = str(int(time.time() * 1000)) c = '&amp;'.join([token, t2, APPKEY, DATA]) m = hashlib.md5() m.update(c.encode('utf-8')) params.update(&#123;'t': t2, 'sign': m.hexdigest()&#125;) cookies = &#123;'_m_h5_tk': token_with_time, '_m_h5_tk_enc': enc_token&#125; r2 = requests.get(URL, params=params, headers=headers, cookies=cookies) logger.debug(r2.text) json_text = re.match(r'(.*\()(.*)(\))', r2.text).group(2) images = dict(json.loads(json_text))['data']['images'] except Exception as e: logger.warning(e) finally: return images 可以看到，接口响应时间有了大幅度提升。]]></content>
      <categories>
        <category>逆向工程</category>
      </categories>
      <tags>
        <tag>Sign签名</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Web API 的设计与开发》读后总结]]></title>
    <url>%2F%E3%80%8AWeb-API-%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91%E3%80%8B%E8%AF%BB%E5%90%8E%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[前言此书为[日]水野贵明著，之前已经通读了一遍，收获不少，为了复习与总结，这里便整理一份笔记，以便忘记的时候查找。 第一章：什么是Web APIREST与Web APIREST一词经常以”REST API”的形式出现。一般而言，人们认为它是指”能够通过HTTP协议进行访问，得到XML或JSON格式的返回数据的API”。而REST一词一般是有两种意思： 符合REST架构风格的Web服务系统。 符合RPC风格的XML(or JSON)+HTTP接口的系统（不适用SOAP）。 书中的API设计思想侧重于第2条，旨在API更加亲切易懂，比如搜索操作时，没有在URI中强制使用名词，而是使用search；在URI中添加版本号，而不是Header中。 LSUD vs SSKD LSUD(Large Set of Unknown Developers) SSKD(Small Set of Known Developers)，有时使用REST这种基于资源的思维方式不能完全满足需求，还需要引入策略编排层这样的思维方式。 第二章：端点的设计与请求的形式端点的概念：在Web API的语境里，端点是指用于访问的API的URI。 端点的设计规范： 短小便于输入 http://api.example.com/service/api/search不如http://api.example.com/search，不应该出现重复的词，也不应该使用service这种含义过于广泛的词。 人可以读懂 不要使用缩写，甚至将products缩写为prod，即使是SSKD，也应尽量减少缩写。 合适的语义，使用合适的单词，拼写错误是不应该出现的。 不能大小写混用 修改方便 如/items/12346，明显修改12346就可以查看其它商品信息。 不会暴露服务端的架构 比如，php或jsp结尾。 规则统一 URI采用一致的风格 HTTP方法和端点URI和HTTP的关系可以认为是操作对象和操作方法的关系。如果把URI当做API(HTTP)的“操作对象=资源”，HTTP方法则表示“进行怎样的操作”。 GET 表示获取信息，最为常用。一般不会修改已有资源（已读/未读，最后访问日期等属性属于例外）。 POST 一般认为POST方法用于更新信息，其实这样的理解存在一些偏差。POST方法的初衷是用于向服务器注册新建的资源。信息的更新和删除等操作应使用其他HTTP方法。由于HTML4.0的表单中method属性只支持GET和POST两种方法，因此使用表单从浏览器提交信息时，以及更新删除，都使用POST方法了。虽然在HTML5的草案中加入了表单允许使用PUT以及DELETE方法的规范，但最终还是讲该内容删除了。由于Web API基本不涉及表单通过浏览器进行访问，所以一般使用PUT和DELETE更容易理解。 PUT 和POST方法相同，都可用与对服务端的信息进行更新，但二者URI的指定方式有所不同。POST方法发送的数据“附属”于指定的URI，附属表示从属URI之下。以文件系统为例，把文件放入目录后，文件就成了目录的附属部分。虽然HTTP协议定义了当所指定的资源不存在时，可以通过PUT操作发送数据，生成心得资源，但Web API一般只用PUT方法来更新数据，而一般会使用POST来生成新的资源。PUT会用发送的数据完全替换原有的资源信息，如果只是更新资源的某部分数据，可以使用PATCH方法来实现。 DELETE 删除资源。 PATCH PATCH和PUT相同，用于更新指定的资源。在数据量较高的情况下，会有显著的效果。 X-HTTP-Method-Override由于HTML的表单规范只支持GET和POST，或是其它开发客户端中只能有GET和POST。所以要利用POST方法将真正想要使用的HTTP方法以元数据信息的形式发送给服务器。有两种方式： 通过名为X-HTTP-Method-Override的Header来实现，推荐使用。 123POST /v1/users/123 HTTP/1.1Host: api.example.comX-HTTP-Method-Override: DELETE 通过传递表单参数_method来实现。 user=testuser&amp;_method=PUT使用application/x-www-form-urlencodedMedia Type。 这里看了一下，Django没有支持这种功能，需要自己写中间件或者三方库来实现。django-method-override。而DRF这里的文档说，在3.3.0版本之前是支持的，后来将其从核心功能中移除。DRF文档。 动态相关的端点举例 目的 端点 方法 编辑动态信息 http://api.example.com/v1/updates/:id PUT 删除动态信息 http://api.example.com/v1/updates/:id DELETE 发表动态信息 http://api.example.com/v1/updates POST 获取特定用户的动态信息 http://api.example.com/v1/users/:id/updates GET 获取好友的动态列表 http://api.example.com/v1/users/:id/friends/updates GET 访问资源的端点设计注意事项 使用名词的复数形式 极力避免使用动词，因为HTTP协议原本就是用URI来表示资源，用HTTP方法来表示对资源所进行的操作。 注意所用的单词 多看大公司的开放API范例，查阅ProgrammableWeb，明白那些具有相近意义的单词哪个更加合适。 不适用空格及需要编码的字符 使用连接符-来连接多个单词 相对于驼峰发和蛇形法，这种脊柱法对于SEO更加友好。不过应尽量避免使用多个单词，而是使用路径划分，如popular_users不如users/popular，或者将一部分内容作为查询参数，让URI变得更短。 相对位置获取数据大分页时效率低下使用绝对位置，事先记录下当前已获得的数据里最后一条数据的ID、时间等信息，然后再指定“该ID之前的所有数据”或“该时刻之前的所有数据”。 查询参数还是使用路径？ 是否是表示唯一资源所需的信息，比如用户ID。 是否可以省略，如page等分页参数，一般都会设置默认值。 登录与OAuth2.0什么是OAuth?假设带有用户注册功能的在线服务A（Facebook）对外公开了API，在线服务B便可以使用这些在线服务A的API提供的各种功能。在这种情况下，当某个已在Facebook里注册的用户需要使用你的在线服务时，你的在线服务就回希望访问Facebook来使用该用户在Facebook中注册的信息。这时，判断是否允许你的在线服务使用该用户在Facebook里注册的信息的机制就是OAuth。 OAuth2.0里的4中类型的交互模式用于访问资源的许可，称为Grant Type。 Grant Type 作用 Authorization Code 适用于在服务端进行大量处理的Web应用 Implicit 适用于只能手机应用及使用JavaScript客户端进行大量处理的应用 Resource Owner Password Credentials 适用于不适用服务端（网站B）的应用 Client Credentials 适用于不以用户为单位来进行认证的应用 Resource 的模式能够应用于公司内部所开发的客户端应用中。 SSKD应用尽量减少API调用次数如首页包含“人气商品”，“推荐商品”，“用户信息”等信息，这样需要访问不同的API，效率很低，因此可以把应用主页所需要的显示信息归集到一个API中，提高了客户端的便捷性。为了完成一次任务需要多次访问API，这样的API设计叫“Chatty API”，不但会加大网络流量的消耗，还会增加客户端的处理工序。 HETEOAS和REST LEVEL3 API等级制度 LEVEL0：使用HTTP LEVEL1：引入资源概念 LEVEL2：引入HTTP动词 LEVEL3：引入HATEOAS概念 HETEOAS: (Hypermedia As The Engine Of Application State)，超媒体即应用状态引擎。意思就是在API返回的数据中包含下一步要执行的行为、要获取的数据等URI的链接信息，客户端只要看到这些信息，就能知道接下来需要访问什么端点，比如DRF中的下一页链接。 优点：使URI得更改变得容易。 面向SSKDs的API，需要根据实际需求采用。面向LSUDs的API，这个概念还没有得到广泛的普及。 第三章：响应数据的设计JSONP概念JSONP是一种将JSON传递给浏览器的方式，是JSON with Padding的缩写。一般形式如下： callback({&quot;id&quot;: 123, &quot;name&quot;: &quot;Saeed&quot;}) 留坑… 封装是否必要比如返回的格式为： 123456789&#123; "meta": &#123; "code": 0, "message": 'OK', &#125;, "data": &#123; ... &#125;&#125; 如果结构形式统一，在客户端就更容易抽象化处理。实际上由于封装的做法会显得冗长，并不值得实现。因为Web API基本上都是用HTTP协议，HTTP已经帮你完成了封装的工作。HTTP协议里引入首部的概念，在首部中可以放入各种数据信息，也可以通过状态码来确认无误地判断是否发生了某种错误等，并将更详细的错误信息放入HTTP首部返回。而如果对API数据进行封装，发生错误时，用户所获得的状态依然是200，这就无法通过状态码来判断处理是成功还是失败。这样的做法没有正确地运用好HTTP协议的机制。这可能会导致客户端的处理发生混乱，这种情况是无论如何都要明令禁止的。而且通用的HTTP客户端程序往往会首先根据状态码来判断请求的处理是否成功，如果出错时返回200，客户端就无法利用通用的错误分类，增加处理负担。 扁平化还是层级？Google的JSON Style Guide使用了模棱两可的陈述：“虽然要尽可能使用扁平化方式，但在某些情况下使用层级形式反而更容易理解。” 情景一： 层级 123456789101112&#123; "id": 3342124, "message": "Hi!", "sender": &#123; "id": 3456, "name": "Tom" &#125;, "receiver": &#123; "id": 12877, "name": "Bob" &#125;&#125; 扁平化 12345678&#123; "id": 3342124, "message": "Hi!", "sender_id": 3456, "sender_name": "Tom", "receiver_id": 12877, "receiver_name": "Bob"&#125; 其中”sender”和”receiver”描述了相同的用户这一数据结构，因此层级形式较好，因为客户端可以将各个数据作为用户这一相同的数据来处理。 情景二： 层级 12345678&#123; "id": 2345, "name": "Tom", "profile": &#123; "birthday": 3322, "gender": "male" &#125;&#125; 扁平化 123456&#123; "id": 2345, "name": "Tom", "birthday": 3322, "gender": "male"&#125; 这种情况，层级导致JSON数据尺寸变大，而且两者看起来没有什么区别，所以应该扁平化。 序列与格式比如一个好友列表的URI /friends 序列原封不动返回 12345678910[ &#123; "id": 234, "name": "Tom" &#125;, &#123; "id": 235, "name": "Bob" &#125;] 用对象进行封装 123456789101112&#123; "friends": [ &#123; "id": 234, "name": "Tom" &#125;, &#123; "id": 235, "name": "Bob" &#125; ]&#125; 看上去第二种方式显得有些冗余，因为URI中已经使用了”friends”来表示好友。而且又显得冗长。但是这样写有三个优点： 更容易理解响应数据表示什么 响应数据通过对象封装实现了结构统一 顶层数据不会根据API的不同而不同，客户端无需适配序列或是对象，免除麻烦。 可以避免安全方面的风险 顶层数据中使用JSON序列，可能会导致名为JSON注入的安全隐患，风险很大。 返回数据的个数返回数据的名称 使用多数API中使用的表示相同含义的单词 通过尽可能少的单词来表示 比如注册时间registrationDateTime不如registeredAt 使用多个单词时，整个API中连接单词的方法要统一 一般使用驼峰法 尽可能不用奇怪的缩略语 注意单复数形式 日期的格式 格式名 示例 RFC 822 Sun, 06 Nov 1994 08:49:37 GMT RFC 850 Sunday, 06-Nov-94 08:49:37 GMT ANSI C的asctime()格式 Sun Nov 6 08:49:37 1994 RFC 3339 2015-10-12T11:30:22+09:00 Unix 时间戳（epoch）秒 1396821803 一般采用RFC 3339格式。如果考虑国际化产品，则推荐使用”+00:00”。在RFC 3339中使用UTC时，可以通过”Z”来标记。2015-11-02T13:00:12+00:00 == 2015-11-02T13:00:12Z。如果是”-00:00”，则表示时区不明。 如果面向SSKD，也可使用Unix时间戳，因为其易于保存和比较，不过会调试稍微麻烦。 有时需要在HTTP首部添加时间，这个格式不支持RFC 3339，只支持上表中的前三项。 详细的出错信息状态码属于通用的错误描述，在表示同各个API的内容相关的错误时显得力不从心。所以要返回额外的错误信息。 一种是通过首部返回 123X-MYNAME-ERROR-CODE: 2013X-MYNAME-ERROR-MESSAGE: Bad authentication tokenX-MYNAME-ERROR-INFO: http://docs.example.com/api/vi/authentication 将出错信息放入消息体 1234567&#123; "error": &#123; "code": 2013, "message": "Bad authentication token", "info": "http://docs.example.com/api/vi/authentication" &#125;&#125; 对于客户端来说第二种消息体的方案比较容易处理，所以优先选择后者。错误码一般4位与HTTP状态码区分，1字头表示通用错误，2字头表示用户错误等。有时提示信息里同时包含面向非开发人员和开发人员的信息。 12345678&#123; "error": &#123; "developerMessage": "面向开发人员信息", "userMessage": "面向用户的信息", "code": 2013, "info": "http://docs.example.com/api/vi/authentication" &#125;&#125; 有时程序返回500、503或404等错误时，默认会返回HTML或者是ContentType: text/plain格式的信息，会导致客户端崩溃等问题。所以即使这种情况下，服务端应该努力保证发生错误、负载过高、访问的端点不存在等情况下也能以合适的格式返回数据。 如果服务端不得已进行维护返回503状态码的同时，还应该返回Retry-After来告知客户端重试的时间。 12503 Service Temporarily UnavailableRetry-After Mon, 2 Dec 2013 03:00:00 GMT 需要返回意义不明确的信息时比如用户在登录时需要输入邮箱和密码，如果登录失败，返回邮箱不存在还是返回邮箱存在但密码错误，还是返回用户已冻结？虽然详细信息对于用户而言显得非常友好，但从另一方面来说，也为非法登录和爬虫提供了友好的信息。所以服务端在这种情况下一般只提供非常少量的信息，让无法正常登陆的用户通过重置密码等手段重新登录。不过这样不太方便调试，所以也可将逻辑分开，在开发时返回详尽信息，生产环境返回不明确的信息。 第四章：最大程度地利用HTTP协议使用HTTP协议规范的意义HTTP协议等很多互联网协议都是由名为RFC的规范文档来定义的。 正确使用状态码首位数字大概含义 状态码 含义 1字头 消息 2字头 成功 3字头 重定向 4字头 客户端原因引起的错误 5字头 服务端原因引起的错误 主要的HTTP状态码 状态码 名称 说明 200 OK 请求成功 201 Created 请求成功，新的资源已创建 202 Accepted 请求成功 204 No Content 没有内容 300 Multiple Choices 存在多个资源 301 Moved Permanently 资源被永久转移 302 Found 请求的资源被暂时转移 303 See Other 引用他出 304 Not Modified 自上一次访问后没有发生更新 307 Temporary Redirect 请求的资源被暂时转移 400 Bad Request 请求不正确 401 Unauthorized 需要认证 403 Forbidden 禁止访问 404 Not Found 没有找到指定的资源 405 Method Not Allowed 无法使用指定的方法 406 Not Acceptable 同Accept相关的首部里含有无法处理的内容 408 Request Timeout 请求在规定时间内没有处理结束 409 Conflict 资源存在冲突 410 Gone 指定的资源已不存在 413 Request Entity Too Large 请求消息体太大 414 Request-URI Too Long 请求的URI太长 415 Unsupported Media Type 不支持所指定的媒体类型 429 Too Many Requests 请求次数过多 500 Internal Server Error 服务器端发生错误 503 Service Unavailable 服务器暂时停止运行 状态码详解及使用场景： 2字头 成功 201 “Created” POST请求的场景，表示创建了一个资源，上传了图片，或是添加了用户。 202 “Accepted” 表示“Accepted”，在异步处理客户端请求时，它用来表示服务器端已接收了来自客户端的请求，但处理尚未结束。 通常的使用场景是文件格式转换、处理远程通知耗时的场景中。 以LinkedIn的参与群组讨论的API为例，我们知道如果成功参与讨论并发表意见，服务器通常会返回201；但如果需要得到 群主确认，所发表的意见就无法立即在页面上显示出来，这时服务器就需要返回202状态码。从广义上来看，也属于异步处理，但是与程序里所说的异步不是一个概念。 另外，使用Box的API来下载文件时，如果文件尚未准备好，服务器会返回202，还会在首部中添加Retry-After写入处理完成所需时间。 204 “No Content” 响应消息为空时会返回该状态码。 使用DELETE方法删除数据时。 关于204有一些争论，这里笔者给出的建议是PUT或PATCH请求时，服务端返回200并将数据同时返回，使用DELETE请求时，返回204。这样，无论在何种情况下，都可以从服务器端返回的数据得知修改操作正确执行。病情也能在PUT/PATCH操作后同时获得ETag信息。 这里有个疑问，实际业务中有时需要“假删除”，此时应该返回204还是200？ 3字头 添加必要的处理 常用来描述重定向操作。在定义了HTTP1.1的RFC 2068中，用于重定向的状态码只有301和302。301表示请求内容已从当前位置移动到了其他地方，而302则表示请求内容只是临时移动到了别处，而且使用的HTTP方法不会在访问重定向的URI时发生变化（如使用POST方法的话，在重定向后依然会使用POST方法来访问重定向的地址）。不过大部分浏览器却采用了与协议相反的设计，用GET方法来访问重定向后的地址。由于这个原因，在RFC 2616里，人们又新定义了303和307状态码。303定义了无论在重定向之前使用什么HTTP方法访问，都允许在请求完成后用GET方法继续访问。即便如此，现在依然有很多重定向操作会返回302状态码。另外RFC 7238里还定义了308状态码。307和308输入302和301的修正版，定义更加严密。302和301允许访问方法从POST变更为GET，307和308则不允许任何HTTP方法在访问过程中发生变更。 API中应极力避免返回重定向类状态码。 300 “Multiple Choices” 当有多个分支可供客户端选择时，服务端会返回该状态码。API使用场景可能性很低，在文件存储类服务里，对于客户端请求的某个键值，如果存在多个数据库，有时会返回该状态码。 304 “Not Modified” 表示客户端上次获取的数据至今为止没有发生更新。当服务端返回304时，整个响应消息体为空。 4字头 客户端请求发生问题 服务端无法理解客户端发送的请求，或虽然服务端能理解但请求没有被执行。 400 “Bad Request” 它表示“其他错误”，无法找到其它满足要求的状态码时返回，比如参数错误。 401 “Unauthorized” 表示认证（Authentication）类型的错误，“识别前来访问的是谁”。 403 “Forbidden” 表示授权（Authorization）类型的错误 ，“赋予特定用户执行特定操作的权限”。 404 “Not Found” 有时不明确是URI不存在还是资源不存在，所以一般会额外返回其它详细的说明。 405 “Method Not Allowed” 客户端使用的HTTP方法不被服务器端允许。 406 “Not Acceptable” API不支持客户端指定的数据格式时服务器端所返回的状态码。 408 “Request Timeout” 客户端发送请求至服务端所需的时间过长时，触发服务端的超时处理。 409 “Conflict” 状态码用于表示资源发生冲突时的错误。比如通过指定ID等唯一键值信息来调用注册功能的API，当这样的API创建数据时，倘若已有相同ID的数据存在，就回导致服务端返回409状态码告知客户端该邮箱地址或ID已被使用。 410 “Gone” 和404相同，表示资源不存在。只是410状态码表示资源曾经存在但目前已经消失了，因此服务端常在访问数据被删除时返回该状态码。但是为了该状态码，服务器必须保存数据已被删除的信息，有些邮箱地址搜索用户信息的API中，从保护个人信息的角度来说，返回410状态的做法会受到质疑。 413 “Request Entity Too Large” 和 414 “Request-URI Too Long” 413表示请求消息体过长，如上传文件过大。 414表示请求首部过长而引发的错误，如查询参数过长。 415 “Unsupported Media Type” 和406类似，表示服务器端不支持客户端请求首部Content-Type里指定的数据格式。区别在于，406一般和GET操作一起使用，415和POST、PUT以及PATCH等方法请求的消息体数据格式不被服务器端支持。例如在只接受JSON格式的请求的API里放入XML格式的数据并向服务器发送，或在Content-Type首部里指定application/xml，都会导致该类型的错误。 429 “Too Many Requests” 访问次数超过了所允许的范围。 5字头 服务器端发生问题 500 “Internal Server Error” 服务端代码存在bug，会返回该类型的错误。应该监控错误日志，防止再次发生。 503 “Service Unavailable” 服务端暂时不可用，服务器维护，或者自身负载过高。 缓存与HTTP协议规范HTTP协议中，缓存处于可用的状态时称为fresh（新鲜）状态，而处于不可用的状态时则称为stale（不新鲜）状态。 过期模型预先决定响应数据的保存期限，当到达期限后机会再次访问服务端来重新获得所需的数据。 一个方法是用Cache-Control响应首部，另一个使用Expires响应首部。 12Expires: Fri, 01 Jan 2016 00:00:00 GMTCache-Control: max-age=3600 Expires使用RFC 1123中定义的时间格式。HTTP1.0就存在，Cache-Control是HTTP1.1中定义的。有时需要制定一个遥远的日期，使得缓存始终生效，但HTTP1.1规定，不允许设置超过1年以上的时间。两者同时定义时，Cache-Control优先。max-age是根据首部中的Date算的。根据HTTP协议的规定，除了5字头错误等几个特殊情况以外，所有的HTTP消息都必须添加Date首部。描述日期的HTTP首部信息里，只能使用GMT（格林尼治标准时区）作为时区。 验证模型轮询当前保存的缓存数据是否为最新数据，并只在服务器端进行数据更新时，才重新获取新的数据。 虽然这么做没有减少网络通信的开销，但假设客户端缓存的数据过大，那么此时缓存的作用就体现出来了。这种方式，服务器需要知道“客户端当前保存的信息的状态”，为此需要用到更新日期或实体标签（Entity Tag）作为指标。两者分别填充在Last-Modified和ETag响应消息首部返回给客户端。 12Last-Modified: Tue, 01 Jul 2014 00:00:00 GMTEtag: &quot;jfkeiwjpii189u98jljdfioj822adf&quot; ETag如何生成取决于服务器端的实现。 客户端使用最后更新日期执行附带条件的请求时，会用到Modified-Since首部。使用实体标签时，会用到If-None-Match首部。 12GET /v1/users/12345If-Modified-Since: Tue, 01 Jul 2014 00:00:00 GMT 12GET /v1/users/12345If-None-Match: &quot;jfkeiwjpii189u98jljdfioj822adf&quot; 服务端检查是否有更新，如果有更新，则返回200和更新后的资源，同时添加最后更新日期或实体标签。未更新，则返回304，响应消息体为空。 如果使用验证模型，并且更新的资源是某个特定的资源，则返回资源自身的最后更新日期；如果是列表信息的多个资源的话，则要使用其中最后更新的资源的最后更新日期。Django中的Etag相关。 ETag有强验证和弱验证两个概念。 强验证ETag： Etag: &quot;jfkeiwjpii189u98jljdfioj822adf&quot;，服务端同客户端数据不能有一个字节的差别，必须完全一样。 弱验证ETag：Etag: W/&quot;jfkeiwjpii189u98jljdfioj822adf&quot;，只要从资源意义的角度来看没有发生变化，就可以视为相同的数据。例如Web页面的广告信息，虽然每次看到广告的内容会有所改变，但它们依然是相同的资源。 启发式过期客户端自己寻找服务端资源的规律，所以服务器如果不能返回“将缓存数据保存多久”的信息，那么应该返回Last-Modified等首部信息来告知客户端，努力减少客户端不必要的访问，这一点非常重要。 不希望实施缓存在实时性要求比较高的场景中，不希望客户端进行缓存。使用Cache-Control首部。 1Cache-Control: no-cache 除此之外，如果Expires首部里写入的过去的日期或不正确的日期格式，客户端也不会进行缓存操作。但不同浏览器可能发生不同的行为，所以此方法并不建议。 no-cache严格意义来讲，不是“不缓存”的意思，而是表示至少“需要使用验证模型来验证”。如果不希望含有机密信息的数据在代理服务器上保存，就可以在Cache-Control首部里使用no-store并返回。 使用Vary来指定缓存单位在实施缓存时可能还需要同时指定Vary首部。在实施缓存时，Vary用于指定除URI外使用哪个请求首部项目来确定唯一的数据。因为即使URI相同，获取的数据有时也会因请求首部内容的不同而发生变化。 HTTP里有这样一种机制：根据由Accept开始的一系列请求首部值的不同，响应消息的内容也会发生变化。该机制称为服务器驱动的内容协商。比如API可以通过支持Accept-Language首部指定客户端能接受的自然语言，并据此切换响应数据里包含的语言信息。这时可以使用Vary首部来判断哪个请求首部需要实施缓存操作。 1Vary: Accept-Language 一般而言，Vary首部用于HTTP经由代理服务器进行交互的场景，特别是在代理服务器拥有缓存功能时。但是有时服务器端无法知晓客户端的访问是否经由代理服务器，这种情况下就需要用到服务器驱动的内容协商机制，Vary首部就成了必选项。比如如果希望在查看用户代理（User Agent）信息后对返回的数据内容进行更新，就需要指定User-Agent首部。 1Vary: Accept-Language,User-Agent 在API中，返回的数据信息根据用户代理的不同而变化的情况非常少见，但我们仍需要考虑这样的情况：当使用智能手机对普通的Web页面进行访问时，即使URI相同，网站也需要返回和访问终端相匹配的内容。因此当Google的网络爬虫访问服务器端时，如果服务器端会根据URI以外的信息改变返回的内容，则推荐添加Vary首部。 Cache-Control 首部缓存操作指令及含义 指令名称 含义 public 代理服务器处保存的缓存可以在不同用户之间共享 private 每个用户的缓存数据必须各不相同 no-cache 缓存数据需要通过验证模型来确认 no-store 不需要进行缓存 no-transform 代理服务器不可变更响应数据的媒体类型或其他相关内容 must-revalidate 不管何时都需要向原始服务器进行再次验证 proxy-revalidate 代理服务器需要向原始服务器进行再次验证 max-age 表示缓存数据处于新鲜状态的时间 s-maxage 和max-age一样，但只用于中继服务器 通过stale-while-revalidate=600这样指定秒数，那么即使代理服务器超过了max-age指定的时间，其内部也能异步进行缓存验证，并指定在一定的时间内允许将缓存数据经由响应消息返回。换言之，在指定了max-age=600,stale-while-revalidate=600的情况下，虽然数据维持新鲜状态的时间只有10分钟，但在随后的10分钟内，缓存服务器也能处理来自客户端的请求，并将所保存的缓存数据直接返回给客户端。与此同时，代理服务器还会异步地向原始服务器发起缓存验证的询问。也就是说，客户端最长可以在20分钟内接收到缓存的数据，使得缓存的数据不会因为突然变得到期而不可用。另外，在缓存到期时，这样做还能异步地完成缓存的交互更新，从而更有效率地对客户端的访问做出响应。 由于某种原为无法访问原始服务器时，可以将stale-if-error指令指定为一定的秒数，允许在该段时间内代理服务器直接将所保存的不新鲜缓存返回给客户端。使用该指令的话，万一突发时间导致宕机，直接通过代理服务器和客户端交互，至少还能够在某段时间内不中断客户端的访问。 媒体类型的指定具有代表性的媒体类型，也就是Content-Type 媒体类型 数据格式 text/plain 纯文本 text/html HTML文件 application/xml XML文件 text/css CSS 文件 application/javascript JavaScript application/json JSON文件 application/rss+xml RSS域 application/atom+xml Atom域 application/octet-stream 二进制数据 application/zip zip文件 image/jpeg JPEG图像 image/png PNG图像 image/svg+xml SVG图像 multipart/form-data 多个数据组成的Web表单数据 video/mp4 MP4动画文件 application/vnd.ms-excel Excel文件 顶层类型名称中application和text非常容易混淆。比如XML文件的媒体类型由RFC 3023定义，根据该协议，text/xml媒体类型用于表示（没有XML背景知识的用户）能够理解的XML，而API返回的数据中应该不会存在这样的XML文件，因此使用application/xml更加合理。 除了由于历史原因而一直使用text作为顶层类型的text/css和text/html之外，某数据格式即使能够作为文本数据打开，但如果只有知道该数据格式的人才能理解，那么其媒体类型也依然需要用application作为顶层类型名称，这一方式已成为主流。 以x-开头的媒体类型如application/x-msgpack。表示该媒体类型尚未在IANA里注册。IANA(Internet Assigned Numbers Authority)是管理Internet相关编号的组织，还负责域名的管理、IP地址的分配等，在Internet领域承担了非常重要的职责。 没有在IANA里注册的并且以x-开头的媒体类型 媒体类型 数据格式 application/x-msgpack MessagePack application/x-yaml YAML application/x-plist 属性列表 但是有些媒体类型已在IANA注册，但在过去刚出现时，使用了x-开头。需要去查一下是否存在不以x-开头的替代类型。 这里有一个例外就是发送HTML表单数据时使用的application/x-www-form-urlencoded类型。该类型在RFC 1866中定义，虽然由于历史原因在命名时加上了x-，但确实IANA中正式注册的媒体类型，虽然有了不加x-的替代，但尚未被IANA采用。 自定义媒体类型根据不同的前缀区分 树名 前缀 Standards tree（标准树） 无 Vendor tree（供应商树） vnd Personal(Vanity) tree（个人树） prs. Unregistered tree（未注册树） x. 标准树指RFC进行了规范化后的媒体类型，如text/html那样，没有前缀。 供应商树下的数据格式虽然旨在大范围使用，但却由特定的企业、团体来管理。例如Excel文件由微软公司管理，媒体类型为application/vnd.ms-excel。可以这样定义application/vnd.companyname.awesomeformat，Excel由于名气大，所以省略了公司名。 个人树下的数据格式只在实验性质或未公开的产品等中使用。 未注册树下的数据格式一般用于本地环境和私有环境，一般供应商树和个人树基本涵盖未注册树所涉及的用例，因此不推荐这种类型。 请求数据与媒体类型 Content-Type 首部和相应消息首部一样，表示请求消息体是以怎样的数据格式发送给服务端的。如客户端发送POST请求时，如果以JSON的形式发送数据，就应该在首部里指定application/json；如果是从Web页面发送表单数据，就会使用application/x-www-form-urlencoded。进行表单操作时，如果有添加文件的情况，就要指定multipart/form-data。 Accept 此首部用于客户端向服务端表明能接受怎样的媒体类型。 Accept: text/html,application/xml;q=0.9,*/*;q=0.8 q表示品质因数（Quality Value），指定该媒体类型的优先级。默认为1，表示优先级最高。可以使用*/*表示所有的媒体类型。 在使用服务器驱动的内容协商确定返回的数据格式时，服务器端会在响应消息的Vary首部里指定Accept，根据Accept的值的不同，响应的详细也可能不同。 同源策略和跨域资源共享概念通过XHTTPRequest对不同的域进行访问将无法获取响应数据，这一原则称为同源策略。同源策略主要是出于安全方面的考虑，它只允许从相同的源来获取数据，并通过URI里的schema（http, https等）、主机（api.example.com）、端口号的组合来判断是否同源。由于JSONP有很多安全问题，所以制定了跨域资源共享（Cross-Origin Resource Sharing，CORS）的方式解决跨域访问的问题。 CORS基本的交互当实施CORS时，客户端要先发送一个名为Origin的请求消息首部。如从http://www.example.com/访问http://api/example.com/ 1Origin: http://www.example.com 服务器保存着允许访问的白名单，请求发送过来，会判断是否在白名单中。如果不在，则返回403；如果在，服务端会在Access-Control-Allow-Origin响应消息首部里放入和请求消息的Origin首部相同的源并返回，表示允许访问。 1Access-Control-Allow-Origin: http://www.example.com CORS与用户认证信息CORS中发送用户认证信息时，必须发布追加的HTTP响应消息首部。例如当客户端使用Cookie首部、Authentication首部发送用户认证信息时，服务器端需要像下面这样将Access-Control-Allow-Credentials首部设为true，来告知客户端“已识别所发送的认证信息”。 1Access-Control-Allow-Credentials: true 如果不这么做，浏览器会直接拒绝来自服务器的响应消息。 在各个浏览器的XHTTPRequest中，发送cookie等认证信息时，必须把withCredentials属性设为true，否则客户端将无法向服务器发送用户的认证信息。 私有的HTTP首部定义新的HTTP首部时，一般需要在最前面加X-，接着添加服务、应用、团体等名称。例如GitHub会通过X-GitHub-Request-Id的自定义首部来针对每个请求返回唯一的ID。 RFC 6648中建议不适用X-前缀，即目前的最佳方案，其定义的规则并不具备强制实施的效力。所以，用或不用，统一就好。 第五章：开发方便更改设计的Web API版本迭代： 在URI路径的开头添加形如v1的版本号，如果新API没有向下兼容，则新增版本号；如果是bug，增加build编号，如果向下兼容的变更或废除某些特定的功能，增加次版本号。 第六章：开发牢固的Web API中间人攻击（Man-In-The-Middle Attack, MITM攻击）使用HTTPS加密机制进行通信时，客户端会从服务端获得SSL证书，此时就要求客户端验证该证书的真伪。如果客户端未能执行验证工作，整个通信过程就有可能遭到中间人攻击，导致通信内容被窃取。 有时一些不含机密信息的API，可以直接使用HTTP而不使用HTTPS加密机制。虽然根据不同类别的API采用不同的方式略微有些复杂，但从降低访问延迟、提高响应速度的角度来说，无疑是行之有效的方法。 XSSXSS接收用户的输入内容并将其嵌入页面的HTML代码，当页面在浏览器里显示时，会自动执行用户输入的JavaScript脚本。一旦页面执行了用户输入的JavaScript脚本，攻击者就能够访问会话、cookie等浏览器里保存的信息，或者篡改页面，还能不受同源策略的限制进行跨域访问，从而完成任意操作。 如服务器返回 1&#123;"data": "&lt;script&gt;alert('xss');&lt;/script&gt;"&#125; 在Content-Type首部的值为text/html的情况下，如果浏览器直接访问该JSON数据的URI，该JSON数据会被解释为HTML，导致通过SCRIPT元素加载的JavaScript代码被浏览器执行。所以为了防范，需要让浏览器将JSON格式的数据只识别成JSON，响应首部添加 1Content-Type: application/json 但是IE会有一个Content Sniffering功能，根据实际的数据内容来推测数据格式。所以在返回JSON类型的数据时还应该添加 1X-Content-Type-Options: nosniff 这会使IE8以后的浏览器不再使用Content sniffering功能。 XSRF/CSRF(Cross Site Request Forgery)跨站点请求伪造。通过跨站点发送伪造的请求，让服务器执行用户意愿意外的处理。 常见例子：向公告板任意发帖，攻击站点以造成损失；恶意刷好评或差评。 防范： 禁止通过GET方法来修改服务端的数据，如添加收藏、公告板发帖等。这样一来，就无法用IMG元素等嵌入用于攻击的脚本了。 CSRF 令牌。 如果Web API只存在由XMLHTTPRequest或非浏览器客户端发起的访问，就要求客户端使用某种机制在请求附加一个特殊的首部，如果请求消息中不存在这一特殊的首部，就拒绝访问。如X-Request-With首部 JSON劫持未完待续。]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>API</tag>
        <tag>RESTful</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工作中项目优化小记]]></title>
    <url>%2F%E5%B7%A5%E4%BD%9C%E4%B8%AD%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[前言博主目前接手了一个项目，该项目代码从某马微店那里买来，社交金融相关。这个项目的代码可以说是逻辑混乱，毫无可重用性，而且又无文档，git message中一堆毫无用处的“update”，PEP8规范？不存在的。使得我每日游走在被代码劝退的边缘。震惊！一次请求1W多条sql。该功能为商品的热销分类表单。之前大概看了一眼，数据是先从redis中取，redis值存的永久有效，没有的话查DB。然后某天清了一下测试数据库的redis，这下好了，接口超时。查了一下silk发现运行了1w多次sql。 万恶之源的代码，难怪查了1W多次，这外键coupon，每次都要查询数据库。而且这里channel也没有用set，这简直基础数据结构都没掌握啊。 123456tbkcoupons = TbkCouponTags.objects.filter(is_hot=True)channel = []for t in tbkcoupons: cc = t.coupon.channel if cc not in channel: channel.append(cc) 使用select_related简单的处理了一下 12345tbkcoupons = TbkCouponTags.objects.select_related('coupon').filter(is_hot=True)channel = set()for t in tbkcoupons: cc = t.coupon.channel channel.add(cc) 快了10倍，冷静一下，思考一下这大哥到底要干嘛，后面看到拿到了tbkcoupons没有再做其他用处。所以这东西完全可以使用反向连接加去重来解决啊，看来sql基础也欠缺。这里改成了values+distinct来处理，因为mysql不支持distinct(‘channel’)这种指定字段的形式。 12tbkcoupons = TbkCoupon.objects.filter(tbkcoupontags__is_hot=True).values('channel').distinct()channels = [c['channel'] for c in tbkcoupons] 后面的逻辑判断，又使用了一堆的ifelse，看着不清晰，将其改为了字典。这些倒不是什么大问题。 最后，修改了一些取值的逻辑。最后将结果保存到了redis中。命中缓存的话大概10+ms。 后来又发现了一个有意思的事情，他好像也知道这个查询挺慢的，所以用celerybeat实现了一个周期任务，定时地更新这个redis。 返回按照当前查询数组顺序的queryset。遇见了这样一个需求 ，收藏列表需要返回按照收藏顺序的商品。而这个顺序保存在java后台。通过Thrift接口调用，返回了一个id列表，而商品保存在我这里。需要根据这个id的顺序返回queryset。django-get-a-queryset-from-array-of-ids-in-specific-order。 123from django.db.models import Case, Whenpreserved = Case(*[When(num_iid=num_iid, then=pos) for pos, num_iid in enumerate(num_iids)])TbkCoupon.objects.filter(num_iid__in=num_iids).order_by(preserved)]]></content>
      <categories>
        <category>Project</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>Django-rest-framework</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode算法题整理（正则篇）regex]]></title>
    <url>%2FLeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E6%AD%A3%E5%88%99%E7%AF%87%EF%BC%89regex%2F</url>
    <content type="text"><![CDATA[193. Valid Phone Numbers使用bash命令在一行中提取一个文本中的手机号。原题 12345678910(xxx) xxx-xxxx or xxx-xxx-xxxx. (x means a digit).Assume that file.txt has the following content:987-123-4567123 456 7890(123) 456-7890Your script should output the following valid phone numbers:987-123-4567(123) 456-7890 1awk '/^([0-9]&#123;3&#125;-|\([0-9]&#123;3&#125;\) )[0-9]&#123;3&#125;-[0-9]&#123;4&#125;$/' telephone.txt]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
        <tag>Algorithm</tag>
        <tag>Regex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 并行赋值]]></title>
    <url>%2FPython-%E5%A4%9A%E4%B8%AA%E5%8F%98%E9%87%8F%E5%90%8C%E6%97%B6%E8%B5%8B%E5%80%BC%2F</url>
    <content type="text"><![CDATA[经常可以在Python看到这样的赋值语句 a, b, c = 1, 2, 3，其执行顺序先执行=右边的表达式，再依次将值赋给左边，Python解释器会将其组成为一个tuple，赋值的时候再unpack。 1234&gt;&gt;&gt; a, b = 2, 0&gt;&gt;&gt; a, b, a = 1, a, 4&gt;&gt;&gt; a, b(4, 2) 可以看到，上面是先把算出右边的值(1, 2, 4)再将其赋值给左边，最后a的值被修改成了4。 如果是可变的对象怎么办，LeetCode有一道经典的题，叫反转一个链表。要求将1-&gt;2-3-&gt;None的链表反转成3-&gt;2-&gt;1-&gt;None。有一个迭代的写法是这样的。 12345678def reverseList(head): prev = None while head: cur = head head = head.next cur.next = prev prev = cur return prev 它的简化写法如下： 12345def reverseList(self, head): prev = None while head: head.next, prev, head = prev, head, head.next return prev 具体的过程是这样的。先执行=右边表达式(None, head, head.next)，然后第一步把head.next=None，此时head变成了1-&gt;None；第二步，执行prev=head，这里为什么head的值时1-&gt;None而不是1-&gt;2-3-&gt;None呢，因为虽然等式先执行的右边，拿到了head，但是上一步的操作是将head修改了，由于head是一个可变对象，prev的值是1-&gt;None，最后再把head=head.next，这里为什么head.next的值又是2-&gt;3-&gt;None了呢，因为，执行右侧的表达式之后，head.next这个对象再前两步中没有被修改，一直都是2-&gt;3-&gt;None，这正是和第二步不同的地方，所以这两个写法是等同的。 参考： Multiple assignment and evaluation order in Python]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[371. Sum of Two Integers - Python]]></title>
    <url>%2F371-Sum-of-Two-Integers-Python%2F</url>
    <content type="text"><![CDATA[不用加减乘除做加法剑指Offer中也出现过此题，此篇文章着重分析一下为什么Python需要做一些多余的操作。 根据书中的分析，大致分为三步： 相加但不进位，使用^ 进位使用&amp;和&lt;&lt; 前两步结果相加 这里不再赘述详细过程。那么我们不难写出代码： 1234567def get_sum(a, b): res, carry = 0, 0 while b != 0: res = a ^ b carry = (a &amp; b) &lt;&lt; 1 a, b = res, carry return res 但是当输入a=-1, b=1时，会发现程序超时。先来看看正常的32位int类型运算时发生了什么，因为进行位运算时要使用补码进行运算，而正数的反码和补码都是本身，负数的反码为除符号位，其它按位取反，负数的补码为反码+1。下面列出了32为整数传入a=-1,b=1时，每次循环中a和b的补码。 a的原码 a的补码 b的补码 a ^ b a &amp; b 10…0001 11…1111 00…0001 11…1110 00…0001 10…0010 11…1110 00…0010 11…1100 00…0010 10…0100 11…1100 00…0100 11…1000 00…0100 ⋮ ⋮ ⋮ ⋮ ⋮ 110…000 110…000 010…000 100…000 010…000 100…000 100…000 100…000 000…000 100…000 000…000 000…000 000…000 ‘break’ ‘break’ 可以看出由于位数的限制，b和a最后都变成了0。因为Python中的int没有范围限制，所以这就是为什么会死循环的原因。 如何解决这个问题呢？我们需要在b的补码变成1000…000(32个0)时终止循环，如何将一个一个无限位的整型转成32位呢，想到了&amp;，所以我们找到一个mask=2**32-1也就是32个1，用一个无限位的值和mask进行与运算，就变成了上述表格中的例子，于是我们将代码改为： 12345678def getSum(self, a, b): res, carry = 0, 0 mask = 0xFFFFFFFF while b != 0: res = (a ^ b) &amp; mask carry = ((a &amp; b) &lt;&lt; 1) &amp; mask a, b = res, carry return res 提交之后还是不能通过测试用例，当a=-12, b=-8时输出了4294967276而不是-20。好，把mask先去掉，传入这两个值，发现可以正常输出-20，那么这里的mask是怎么造成了一些副作用的。再来分析一下这两个参数下，具体的过程是怎样的。 为了方便DEBUG，我们添加一些输出： 1234567891011121314def get_sum(self, a, b): mask = 0xFFFFFFFF res, carry = 0, 0 while b != 0: print('bin(&#123;&#125;) = &#123;&#125;, bin(&#123;&#125;) = &#123;&#125;'.format(a, bin(a), b, bin(b))) res = (a ^ b) &amp; mask # res = (a ^ b) print('\t res = &#123;&#125;, bin(res) = &#123;&#125;'.format(res, bin(res))) carry = ((a &amp; b) &lt;&lt; 1) &amp; mask # carry = ((a &amp; b) &lt;&lt; 1) print('\t \t a&amp;b = &#123;&#125;, (a&amp;b)&lt;&lt;1 = &#123;&#125;, carry = &#123;&#125;'.format((a&amp;b), ((a&amp;b)+1), carry)) a, b = res, carry # return res if res &lt;= MAX else ~(res ^ mask) return res 输出如下： 12345678910111213141516Finished in 20 msbin(-12) = -0b1100, bin(-8) = -0b1000 res = 12, bin(res) = 0b1100 a&amp;b = -16, (a&amp;b)&lt;&lt;1 = -15, carry = -32bin(12) = 0b1100, bin(-32) = -0b100000 res = -20, bin(res) = -0b10100 a&amp;b = 0, (a&amp;b)&lt;&lt;1 = 1, carry = 0-20Finished in 24 msbin(-12) = -0b1100, bin(-8) = -0b1000 res = 12, bin(res) = 0b1100 a&amp;b = -16, (a&amp;b)&lt;&lt;1 = -15, carry = 4294967264bin(12) = 0b1100, bin(4294967264) = 0b11111111111111111111111111100000 res = 4294967276, bin(res) = 0b11111111111111111111111111101100 a&amp;b = 0, (a&amp;b)&lt;&lt;1 = 1, carry = 04294967276 可以看到在进行-15&amp;mask时，carry变成了一个很大的正数，并丢失了符号。此处为个人猜想，当负数与mask进行与运算时，比如-2，此时-2的补码变为11…10，一个33-bit的数字，然后和32位的mask与操作后，变为了一个33位的正数。 有一个公式可以帮我们还原a，如果一个负数n，它的无符号的32位补码是m，那么m=~(n ^ mask) 或者n=~(m ^ mask) 于是代码修改为： 1234567891011121314def getSum(self, a, b): MASK = 0xffffffff # in Python, every integer is associated with its two's complement and its sign. # However, doing bit operation "&amp; mask" loses the track of sign. # Therefore, after the while loop, a is the two's complement of the final result as a 32-bit unsigned integer. while b != 0: a, b = (a ^ b) &amp; MASK, ((a &amp; b) &lt;&lt; 1) &amp; MASK # a is negative if the first bit is 1 if (a &gt;&gt; 31) &amp; 1: return ~(a ^ MASK) else: return a 虽然python进行大数字运算很方便，但是无限制位数往往会对位运算的操作中产生一些陷阱。如果可以直接转成Java中那种32的int，岂不是没有这么多麻烦了，好在numpy为我们提供了这样的方法。 1234567import numpy as npclass Solution(object): def getSum(self, a, b): while b != 0: a, b = np.int32(a ^ b), np.int32((a &amp; b) &lt;&lt; 1) return int(a) 最后要再转回int，否则是没法通过测试用例的。 参考： numpy实现方式 mask实现方式 the-meaning-of-bit-wise-not-in-python stackoverflow]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Bit Manipulation</tag>
        <tag>LeetCode</tag>
        <tag>Python</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[约瑟夫环问题（Josephus problem）]]></title>
    <url>%2F%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E9%97%AE%E9%A2%98%EF%BC%88Josephus-problem%EF%BC%89%2F</url>
    <content type="text"><![CDATA[问题：0，1，…，n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求这个圆圈里剩下的最后一个数字。 注意到，一开始有 n 个人，报到 m 的人出局后，如果我们从刚才出局的那人的下一位开始重新从 1 开始编号，原问题就转化为了一个 n–1 人的问题。如下表所示： 原始编号(i) 第一个人出局后的编号(j) m 0 m+1 1 m+2 2 … … m-2 n-2 （n为出局前的总人数） m-1 OUT 可以看出老编号i和新编号j的关系为：i = (j+m) % n，于是总结递推公式： f(n) = (f(n-1) + m) % n (n &gt; 1)，其中f(n)为当场上还有n个人时在场的人的编号。当最后只剩下一个人的时候，这个人的编号只能是0，即f(1)=0，现在根据上面的公式反推，推导出当n个人在场时这个最后幸存者的编号。例如：f(2)=(f(1)+m) % 2，所以range范围从2开始，执行n-1次，也就是range(2, n+1) 12345678def LastRemaining_Solution(self, n, m): # write code here if n&lt;=0 or m&lt;=0: return -1 last_num = 0 for i in range(2, n+1): last_num = (last_num+m) % i return last_num]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>algorithm</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[波义尔摩尔投票算法（Boyer-Moore Voting Algorithm）]]></title>
    <url>%2F%E6%B3%A2%E4%B9%89%E5%B0%94%E6%91%A9%E5%B0%94%E6%8A%95%E7%A5%A8%E7%AE%97%E6%B3%95%EF%BC%88Boyer-Moore-Voting-Algorithm%EF%BC%89%2F</url>
    <content type="text"><![CDATA[简介 The Boyer–Moore majority vote algorithm is an algorithm for finding the majority of a sequence of elements using linear time and constant space. It is named after Robert S. Boyer and J Strother Moore, who published it in 1981,[1] and is a prototypical example of a streaming algorithm. 波义尔摩尔投票算法是一种使用线性时间复杂度和常数空间复杂度来找到数组的主要元素（出现超过一半次数的元素）。 题目: 169. Majority Element。找出数组中出现超过一半的元素。 Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times. You may assume that the array is non-empty and the majority element always exist in the array. 《剑指Offer》中的解释 遍历数组的时候保存两个值：一个是数组中的数字，另一个是次数。当我们遍历到下一个数字的时候，如果下一个数字和我们之前保存的数字相同，则次数加1；如果下一个数字和我们之前保存的数字不同，则次数减1。如果次数为零，那么需要保存下一个数字，并把次数设为1.由于我们要找的数字出现的次数比其他所有数字出现的次数之和还要多，那么要找的数字肯定是最后一次把次数设为1时的对应数字。 整个过程想象成一次投票选举投票规则：大屏幕上只允许出现一位候选人。如果选举人投的票不是当前候选人，那么让当前候选人票-1，如果是，则+1。OK，我们现在把所有数组的元素当成是选举人举出的号牌。我们先考虑最极端的情况：最后的winner以一票之差险胜。也就是元素出现的次数为n//2+1。这种情况是如何出现的呢，假设数组是这样的： 1[7, 7, 7, 7, 1, 2, 3] 没有投7的选举人假设在一开始知道了最有潜力的winner即7号，那么他们‘同仇敌忾’，将-1的票都投在了7号上，这种情况7号一直处于大屏幕中，没有更换过候选人。但是最后也没能打败7号，因为7号最后还保留一票。 另外一种非极端的情况，没有投7的选举人产生了‘内讧’： 1[7, 1, | 2, 3, | 7, 7, 7] 首先7号得到一票，然后被1号干掉，接着2号称为候选人，被3号干掉。3号的票浪费在了‘自己人’身上，即‘我们中出了一个叛徒’。就算团结起来都干不过7号，所以winner还是7号。 最后附上LeetCode上的Python代码： 1234567891011class Solution: def majorityElement(self, nums): count = 0 candidate = None for num in nums: if count == 0: candidate = num count += (1 if num == candidate else -1) return candidate 参考： 维基百科 LeetCode]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode算法题整理（sql篇）sql]]></title>
    <url>%2FLeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88sql%E7%AF%87%EF%BC%89sql%2F</url>
    <content type="text"><![CDATA[595. Big Countries查询’大城市’。原题 使用where OR 123select name, population, area from World where area &gt; 3000000 or population &gt; 25000000; 使用UNION 12345678select name, population, area from World where area &gt; 3000000unionselect name, population, areafrom Worldwhere population &gt; 25000000; 补充说明：Solution中解释道，使用UNION会比OR快上一丢丢。 Suppose we are searching population and area, Given that MySQL usually uses one one index per table in a given query, so when it uses the 1st index rather than 2nd index, it would still have to do a table-scan to find rows that fit the 2nd index. 因为前者查询的时候只用到第一个索引，对第二个条件查询时，也就是population，使用的是全表扫描，于是浪费了一些时间。但是想想背后的代价，想必是以空间来换时间。 627. Swap Salary转换性别。原题 使用if 123UPDATE salarySET sex=IF(sex='m', 'f', 'm'); 使用CASE 1234567update salaryset sex = CASE sex when 'm' Then 'f' else 'm' END; 使用XOR 123update salaryset sex = CHAR(ASCII('f') ^ ASCII('m') ^ ASCII(sex)); 620. Not Boring Movies使用MOD替代%。原题12345select *from cinemawhere mod(id, 2) = 1 and description != 'boring'order by rating DESC; 182. Duplicate Emails查询多余的重复值。原题思考：开始陷入了误区，以为要将重复的id也查出来。 1234SELECT emailFROM PersonGROUP BY emailHAVING Count(*) &gt; 1; 175. Combine Two Tables左链接。过于简单。原题123456SELECT p.FirstName, p.LastName, ad.City, ad.StateFROM Person p LEFT JOIN Address ad ON p.PersonId = ad.PersonId; 181. Employees Earning More Than Their Managers自链接。原题123456select e.name Employeefrom Employee e inner join Employee m on e.ManagerId = m.Idwhere e.Salary &gt; m.Salary; 183. Customers Who Never Order没有订单的顾客。原题123456select c.name Customersfrom Customers c left join Orders o on c.id = o.CustomerIdwhere o.CustomerId is Null; 123456select customers.name as 'Customers'from customerswhere customers.id not in( select customerid from orders); 596. Classes More Than 5 Students超过5个学生的班级。原题12345select classfrom coursesgroup by classhaving count(distinct student) &gt;= 5; 197. Rising Temperature这个挺有意思，开始天真地想用id作为条件，测试用例教做人。原题 我的答案 123456SELECT today.IdFROM Weather yest INNER JOIN Weather today ON today.RecordDate = DATE_ADD(yest.RecordDate, INTERVAL 1 day)WHERE today.Temperature &gt; yest.Temperature; 标准答案 12345678SELECT weather.id AS 'Id'FROM weather JOIN weather w ON DATEDIFF(weather.date, w.date) = 1 AND weather.Temperature &gt; w.Temperature; 查看Mysql文档： DATEDIFF(expr1,expr2) DATEDIFF() returns expr1 − expr2 expressed as a value in days from one date to the other. expr1 and expr2 are date or date-and-time expressions. Only the date parts of the values are used in the calculation. 1234mysql&gt; SELECT DATEDIFF('2007-12-31 23:59:59','2007-12-30'); -&gt; 1mysql&gt; SELECT DATEDIFF('2010-11-30 23:59:59','2010-12-31'); -&gt; -31 196. Delete Duplicate Emails删除重复的邮件。原题1234delete p1 from Person p1, Person p2where p1.email=p2.email and p1.Id &gt; p2.Id; 176. Second Highest Salary返回第二高的salary。原题PS：奇怪的题，没有记录非要人返回Null，只能再套一层查询或者使用IFNULL也可以。 12345678SELECT (SELECT DISTINCT Salary FROM Employee ORDER BY Salary DESC LIMIT 1 OFFSET 1) AS SecondHighestSalary; 626. Exchange Seats交换相邻两行的值。原题开始理解错了，以为要update。 CASE 123456789101112SELECT ( CASE WHEN MOD(id, 2) != 0 AND counts != id THEN id + 1 WHEN MOD(id, 2) != 0 AND counts = id THEN id ELSE id - 1 end ) AS id, studentFROM seat, (SELECT Count(*) AS counts FROM seat) AS seat_countsORDER BY id ASC;; COALESCE() 第一步：使用XOR，但是不能直接使用排序因为id为5的被换成了6。 1SELECT id, (id+1)^1-1, student FROM seat; 123456789+------+------+----------+------------+---------+| id | id+1 | (id+1)^1 | (id+1)^1-1 | student |+------+------+----------+------------+---------+| 1 | 2 | 3 | 2 | Abbot || 2 | 3 | 2 | 1 | Doris || 3 | 4 | 5 | 4 | Emerson || 4 | 5 | 4 | 3 | Green || 5 | 6 | 7 | 6 | Jeame |+------+------+----------+------------+---------+ 第二步：使用LEFT JOIN链接。 12345SELECT *FROM seat s1 LEFT JOIN seat s2 ON ( s1.id + 1 )^1 - 1 = s2.idORDER BY s1.id; 123456789+------+---------+------+---------+| id | student | id | student |+------+---------+------+---------+| 1 | Abbot | 2 | Doris || 2 | Doris | 1 | Abbot || 3 | Emerson | 4 | Green || 4 | Green | 3 | Emerson || 5 | Jeame | NULL | NULL |+------+---------+------+---------+ 第三步：使用COALESCE() 1234567SELECT s1.id, Coalesce(s2.student, s1.student) as studentFROM seat s1 LEFT JOIN seat s2 ON ( s1.id + 1 )^1 - 1 = s2.idORDER BY s1.id; 参考：Mysql文档 Returns the first non-NULL value in the list, or NULL if there are no non-NULL values.The return type of COALESCE() is the aggregated type of the argument types. 178. Rank Scores]]></content>
      <categories>
        <category>sql</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode算法题整理（位运算篇）Bit Manipulation]]></title>
    <url>%2FLeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AF%87%EF%BC%89Bit-Manipulation%2F</url>
    <content type="text"><![CDATA[191. Number of 1 Bits计算数字的二进制中有多少个1。原题123Input: 11Output: 3Explanation: Integer 11 has binary representation 00000000000000000000000000001011 方法一：常规解法，使用1与n作与运算，如果不是0说明，含有一个1。 1234567def hamming_weight(n): bits, mask = 0, 1 for _ in range(32): if n&amp;mask != 0: bits += 1 mask &lt;&lt;= 1 return bits 方法二：关键点是，一个数n和n-1的与运算操作，相当于去掉了最右面的1。 123456def hamming_weigth(n): bits = 0 while n: bits += 1 n = (n-1) &amp; n return bits 136. Single Number找出数组中不重复的元素。其它元素出现两次。原题12Input: [4,1,2,1,2]Output: 4 123def single_num(nums): from itertools import reduce return reduce(lambda x, y: x ^ y, nums) 137. Single Number II找出数组中出现一次的元素，其它元素出现三次。原题12Input: [2,2,3,2]Output: 3 方法一：找出单独元素每一位的值。如果把所有数字的二进制每一位加起来，如果某一位可以被3整除，则表示单独元素的该位为0，否则为1。以下使用count来表示每一位1的个数。假设count%3!=0为True，说明该元素i位为1，然后是用|=更新ans在第i个位置的值，这里也可以使用+=，但是效率稍慢。convert的作用是因为python中的int是个对象，且没有最大限制，不是在第32位使用1来表示负数。 1234567891011121314def singleNumber(self, nums, n=3): ans = 0 for i in range(32): count = 0 for num in nums: if ((num &gt;&gt; i) &amp; 1): count += 1 ans |= ((count%n!=0) &lt;&lt; i) return self.convert(ans)def convert(self, x): if x &gt;= 2**31: x -= 2**32 return x 这里有个状态机的解法，不明觉厉，留坑。讨论1和讨论2 123456def singleNumber(self, nums): ones, twos = 0, 0; for i in range(len(nums)): ones = (ones ^ nums[i]) &amp; ~twos twos = (twos ^ nums[i]) &amp; ~ones return ones 260. Single Number III找出数组中两个唯一出现一次的元素，其余元素均出现两次。原题12Input: [1,2,1,3,2,5]Output: [3,5] 思想：将这两个元素分到两个组，由于这两个数不相等，所以亦或结果不为0，也就是说二进制中至少有一位1，记为第n位。我们以第n位是否为1，把数组分为两个子数组。 123456789101112def singleNumber(self, nums): total_xor = self.get_xor(nums) mask = 1 while total_xor&amp;mask == 0: mask &lt;&lt;= 1 p1 = [num for num in nums if num&amp;mask==0] p2 = [num for num in nums if num&amp;mask!=0] return [self.get_xor(p1), self.get_xor(p2)] def get_xor(self, nums): from functools import reduce return reduce(lambda x, y: x ^ y, nums) 371. Sum of Two Integers不用加减乘除做加法。原题解析为何Python位运算有些不同 实际上加法分为三个步骤 相加但不进位，1^0=1，1^1=0，0^0=0，所以第一步用异或。 只求进位的结果，只有两个1才会进位，所以用&amp;，然后左移1位，表示要进的位。 把前两步的结果再重复1，2步，直到没有进位产生，即b=0。 12345678910111213def getSum(self, a, b): # 32 bits integer max MAX = 0x7FFFFFFF # 2**31-1 # 32 bits interger min MIN = 0x80000000 # -2**31 # mask to get last 32 bits mask = 0xFFFFFFFF # 2*32-1 while b != 0: # ^ get different bits and &amp; gets double 1s, &lt;&lt; moves carry a, b = (a ^ b) &amp; mask, ((a &amp; b) &lt;&lt; 1) &amp; mask # if a is negative, get a's 32 bits complement positive first # then get 32-bit positive's Python complement negative return a if a &lt;= MAX else ~(a ^ mask) 190. Reverse Bits返回一个数的二进制的倒序的十进制。原题1234Input: 43261596Output: 964176192Explanation: 43261596 represented in binary as 00000010100101000001111010011100, return 964176192 represented in binary as 00111001011110000010100101000000. 方法一：使用原生库。ljust表示在右侧补’0’。或者使用format来补0。 123def reverseBits(self, n): return int(bin(n)[:1:-1].ljust(32, '0'), 2) # return int('&#123;:0&lt;32s&#125;'.format(bin(n)[:1:-1]), 2) 方法二：自己实现进制转换，使用位运算优化。 123456def reverseBits(self, n): code = '' for _ in range(32): code += str(n &amp; 1) n &gt;&gt;= 1 return sum([int(bit) &lt;&lt; i for i, bit in enumerate(code[::-1])]) 方法二改进：这里有个误区，为什么非要将整个二进制完整体现出来，再去遍历它转成int，而不是直接构建这个int。 123456def reverseBits(self, n): code = 0 for _ in range(32): code = (code&lt;&lt;1) + (n&amp;1) n &gt;&gt;= 1 return code 389. Find the Differences和t两个由小写字母组成的字符串，t是由s打乱顺序并再随机添加一个小写字母组成。原题方法一：使用Collection。 123def findTheDifference(self, s, t): from collections import Counter return next((Counter(t) - Counter(s)).elements()) 方法二：使用异或。 1234def findTheDifference(self, s, t): from operator import xor from functools import reduce return chr(reduce(xor, map(ord, s+t))) 401. Binary Watch有这样一个二进制的手表，输入一个n，表示有几个亮着的灯，返回所有可能出现的时间。时间范围为12小时制，即hours(0-11)，minutes(0-59)。原题 12Input: n = 1Return: [&quot;1:00&quot;, &quot;2:00&quot;, &quot;4:00&quot;, &quot;8:00&quot;, &quot;0:01&quot;, &quot;0:02&quot;, &quot;0:04&quot;, &quot;0:08&quot;, &quot;0:16&quot;, &quot;0:32&quot;] 一开始的思路：这是个错误的解法，因为分钟的灯不应该超过60分钟，因为要进位。类似的4和8的小时灯也不能同时亮起。 1234567def readBinaryWatch(self, num): from itertools import combinations # transform hours to minutes minutes = list(map(lambda x: x * 60, (1, 2, 4, 8))) + [32, 16, 8, 4, 2, 1] minutes_groups = combinations(minutes, num) res = ['&#123;:d&#125;:&#123;:0&gt;2d&#125;'.format(sum(g)//60, sum(g)%60) for g in minutes_groups] return res 方法二：正确的写法。需要分开判断小时和分钟，然后再合并。 123456789101112def readBinaryWatch(self, num): from itertools import combinations # transform hours to minutes hours = list(map(lambda x: x*60, (1, 2, 4, 8))) minutes = (1, 2, 4, 8, 16, 32) res = [] for i in range(num+1): get_hours = [x for x in list(combinations(hours, i)) if sum(x) &lt; 12 * 60] get_minutes = [x for x in list(combinations(minutes, num-i)) if sum(x) &lt; 60] minutes_groups = [h+m for h in get_hours for m in get_minutes] res += ['&#123;:d&#125;:&#123;:0&gt;2d&#125;'.format(sum(g)//60, sum(g)%60) for g in minutes_groups] return res 方法三：遍历所有可能的时间，找到符合条件的。因为表中的数组都是二进制，所以’1’的个数就是亮灯的个数。 1234def readBinaryWatch(self, num): return ['&#123;:d&#125;:&#123;:0&gt;2d&#125;'.format(h, m) for h in range(12) for m in range(60) if (bin(h)+bin(m)).count('1') == num] 405. Convert a Number to Hexadecimal把一个32位有符号的整数转换成16进制。原题123456789Input:26Output:&quot;1a&quot;Input:-1Output:&quot;ffffffff&quot; 123def toHex(self, num): return ''.join(['0123456789abcdef'[(num &gt;&gt; 4 * i) &amp; 15] for i in range(8)])[::-1].lstrip('0') or '0' 461. Hamming Distance求两个正数的原码中不同位的个数。原题1234567Input: x = 1, y = 4Output: 2Explanation:1 (0 0 0 1)4 (0 1 0 0) ↑ ↑The above arrows point to positions where the corresponding bits are different. 12def hammingDistance(self, x, y): return bin(x ^ y).count('1') 476. Number Complement给定一个正数，求其原码的按位取反后的数。原题123Input: 5Output: 2Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2. 方法一：暴力的方法。 12def findComplement(self, num): return int(''.join([str(1 ^ int(d)) for d in bin(num)[2:]]), 2) 方法二：其实就是求101和111的异或。所以先找到111。 12345def findComplement(self, num): i = 1 while i &lt;= num: i &lt;&lt;= 1 return (i-1) ^ num 方法三：更少的位移。核心思想还是找到111。比如一个8位数，最高代表符号：1000000，先将其右移1位，使得左边两位都变成1。然后再右移2位，使得左边四位变成1，以此类推，8位数最多移动3次就可以得到1111111，32位则还需要再移动2次。 12345def findComplement(self, num): mask = num for i in range(5): mask |= mask &gt;&gt; (2**i) return num ^ mask 693. Binary Number with Alternating Bits二进制是否是交替的0和1。原题1234Input: 5Output: TrueExplanation:The binary representation of 5 is: 101 方法一：字符串法。 12def hasAlternatingBits(self, n): return '00' not in bin(n) and '11' not in bin(n) 方法二：除2法。 1234567def hasAlternatingBits(self, n): n, cur = divmod(n, 2) while n: if cur == n % 2: return False n, cur = divmod(n, 2) return True 方法三：异或。 12345def hasAlternatingBits(self, n): if not n: return False num = n ^ (n &gt;&gt; 1) return not (num &amp; num+1) 762. Prime Number of Set Bits in Binary Representation求某范围的所有自然数中，二进制中1的个数是质数的个数。原题123456789Input: L = 10, R = 15Output: 5Explanation:10 -&gt; 1010 (2 set bits, 2 is prime)11 -&gt; 1011 (3 set bits, 3 is prime)12 -&gt; 1100 (2 set bits, 2 is prime)13 -&gt; 1101 (3 set bits, 3 is prime)14 -&gt; 1110 (3 set bits, 3 is prime)15 -&gt; 1111 (4 set bits, 4 is not prime) 方法一：direct. 12345678def countPrimeSetBits(self, L: 'int', R: 'int') -&gt; 'int': primes = &#123;2, 3, 5, 7, 11, 13, 17, 19&#125; # ans = 0 # for num in range(L, R+1): # if bin(num)[2:].count('1') in primes: # ans += 1 # return ans return sum(bin(n)[2:].count('1') in primes for n in range(L, R+1)) 方法二：位运算。p 的2，3，5，7。。位是1，其余是0，这样在右移后，可&amp;1就可以判断这个数是否是质数。 123def countPrimeSetBits(self, L: 'int', R: 'int') -&gt; 'int': p = int('10100010100010101100', 2) return sum(p &gt;&gt; bin(i).count('1') &amp; 1 for i in range(L, R+1)) 868. Binary Gap二进制两个1的最大距离。原题12345678Input: 22Output: 2Explanation: 22 in binary is 0b10110.In the binary representation of 22, there are three ones, and two consecutive pairs of 1&apos;s.The first consecutive pair of 1&apos;s have distance 2.The second consecutive pair of 1&apos;s have distance 1.The answer is the largest of these two distances, which is 2. 方法一：字符串或是位运算都可以。 12345678910def binaryGap(self, N: 'int') -&gt; 'int': ans, last = 0, None # for i, b in enumerate(bin(N)[2:]): for i in range(32): # if b == '1': if (N &gt;&gt; i) &amp; 1: if last is not None: ans = max(ans, i - last) last = i return ans 方法二：列表生成式。 1234def binaryGap(self, N: 'int') -&gt; 'int': one = [i for i, v in enumerate(bin(N)) if v == '1'] # return max([one[i+1] - one[i] for i in range(len(one)-1)] or [0]) return max([b-a for a, b in zip(one, one[1:])] or [0]) 268. Missing Number0~n中缺失的数字。原题方法一：数学公式。 12345def missingNumber(self, nums): n = len(nums) expected_sum = n*(n+1) // 2 actual_sum = sum(nums) return expected_sum - actual_sum 方法二：XOR. index 0 1 2 value 3 0 1 12345def missingNumber(self, nums: 'List[int]') -&gt; 'int': missing = len(nums) for i, num in enumerate(nums): missing ^= i ^ num return missing 1012. Complement of Base 10 Integer非负数的反码。原题123456def bitwiseComplement(self, N: int) -&gt; int: mask = 1 while mask &lt; N: mask = (mask &lt;&lt; 1) + 1 # return mask - N return N ^ mask]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Bit Manipulation</tag>
        <tag>LeetCode</tag>
        <tag>Python</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode算法题整理（二分法篇）Binary Search]]></title>
    <url>%2FLeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E4%BA%8C%E5%88%86%E6%B3%95%E7%AF%87%EF%BC%89Binary-Search%2F</url>
    <content type="text"><![CDATA[704. Binary Search二分法在有序数组中查找元素。原题123Input: nums = [-1,0,3,5,9,12], target = 9Output: 4Explanation: 9 exists in nums and its index is 4 方法一：实现原理。 1234567891011def binary_search(nums, target): l, r = 0, len(nums)-1 while l &lt;= r: mid = (l+r) // 2 if nums[mid] &gt; target: r = mid - 1 elif nums[mid] &lt; target: l = mid + 1 else: return mid return -1 方法二：使用标准库。 1234def search(self, nums, target): from bisect import bisect_left index = bisect_left(nums, target) return index if index &lt; len(nums) and nums[index] == target else -1 35. Search Insert Position给定一个target，插入到一个有序数组中，假定数组中无重复元素。原题12Input: [1,3,5,6], 5Output: 2 方法一：实现原理。 1234567891011def binary_insert(nums, target): l, r = 0, len(nums)-1 while l &lt;= r: mid = (l+r) // 2 if nums[mid] &gt; target: r = mid - 1 elif nums[mid] &lt; target: l = mid + 1 else: return mid return l 方法二：使用标准库。 123def searchInsert(self, nums, target): from bisect import bisect_left return bisect_left(nums, target) 153. Find Minimum in Rotated Sorted Array通过一个排序数组旋转后的结果，找出最小元素。原题12Input: [3,4,5,1,2] Output: 1 思路：通过二分法不断缩小范围，由于mid是整除，最后l==mid，并且nums[mid] &gt; nums[r]的。 123456789101112def find_min(nums): l, r = 0, len(nums)-1 if nums[l] &lt; nums[r]: return nums[l] while l &lt;= r: mid = (l+r) // 2 if nums[mid] &gt; nums[l]: l = mid elif nums[mid] &lt; nums[r]: r = mid else: return nums[r] 34. Find First and Last Position of Element in Sorted Array有序数组中查找数组，返回数字的索引范围。原题1234Input: nums = [5,7,7,8,8,10], target = 8Output: [3,4]Input: nums = [5,7,7,8,8,10], target = 6Output: [-1,-1] 12345678910111213141516def searchRange(self, nums, target): left_idx = self.search_edge(nums, target, True) if left_idx == len(nums) or nums[left_idx] != target: return [-1, -1] return [left_idx, self.search_edge(nums, target, False)-1] def search_edge(self, nums, target, left): l, r = 0, len(nums) while l &lt; r: mid = (l+r) // 2 if nums[mid] &gt; target or (left and nums[mid]==target): r = mid else: l = mid + 1 return l 278. First Bad Version找出提交版本中的bad version。原题1234567Given n = 5, and version = 4 is the first bad version.call isBadVersion(3) -&gt; falsecall isBadVersion(5) -&gt; truecall isBadVersion(4) -&gt; trueThen 4 is the first bad version. 123456789def firstBadVersion(self, n): l, r = 1, n while l &lt;= r: mid = (l+r) // 2 if isBadVersion(mid): r = mid - 1 else: l = mid + 1 return l 374. Guess Number Higher or Lower猜数游戏1~n，每猜一次会告诉你答案是更小还是更大。原题12345678def guess(num): return -1 : My number is lower 1 : My number is higher 0 : Congrats! You got it! Input: n = 10, pick = 6Output: 6 方法一：实现原理。 12345678910def guessNumber(self, n): l, r = 1, n while l &lt;= r: mid = (l+r) // 2 if guess(mid) == -1: r = mid - 1 elif guess(mid) == 1: l = mid + 1 else: return mid 方法二：使用标准库。此答案受stefan大神启发。核心思想为将guess返回的结果转为一个数组，然后使用二分法查找。 1234567def guessNumber(self, n): from bisect import bisect, bisect_left class C: def __getitem__(self, x): return -guess(x) # return bisect(C(), -1, 1, n) return bisect_left(C(), 0, 1, n) 解析：以n=10, pick=6为例。实际上C class相当于: 1234ary = map(lambda x: -guess(x), range(1, n+1))ary.insert(0, None)# ary = [None, -1, -1, -1, -1, -1, 0, 1, 1, 1, 1]return bisect(ary, -1, 1, n) 而索引又是从1开始，所以这里在前面添加了一个None，实际上将题转为了查找ary的0，问题便迎刃而解。值得注意的是，如果使用了map，会导致空间，时间复杂度增加，而使用class的方法，并没有求出整个的list，所以效率更高。 744. Find Smallest Letter Greater Than Target找出比目标大的最小字母，没有的返回首字母。原题1234567891011121314Input:letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]target = &quot;d&quot;Output: &quot;f&quot;Input:letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]target = &quot;g&quot;Output: &quot;j&quot;Input:letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]target = &quot;j&quot;Output: &quot;c&quot; 方法一：二分法实现。 123456789def nextGreatestLetter(self, letters: 'List[str]', target: 'str') -&gt; 'str': lo, hi = 0, len(letters)-1 while lo &lt;= hi: mid = (lo + hi) // 2 if letters[mid] &gt; target: hi = mid -1 elif letters[mid] &lt;= target: lo = mid + 1 return letters[lo % len(letters)] 方法二：使用库。 123def nextGreatestLetter(self, letters: 'List[str]', target: 'str') -&gt; 'str': index = bisect.bisect(letters, target) return letters[index % len(letters)] 852. Peak Index in a Mountain Array找到数组中的峰值。假设峰值一定存在。原题12Input: [0,2,1,0]Output: 1 方法一：Linear Scan. Time: O(N) 1234def peakIndexInMountainArray(self, A: 'List[int]') -&gt; 'int': for i in range(1, len(A)-1): if A[i] &gt; A[i+1]: return i 方法二：one-line. 12def peakIndexInMountainArray(self, A: 'List[int]') -&gt; 'int': return A.index(max(A)) 方法三：看到Solution才想到二分法。 123456789def peakIndexInMountainArray(self, A: 'List[int]') -&gt; 'int': lo, hi = 0, len(A)-1 while lo &lt; hi: mid = (lo + hi) // 2 if A[mid] &gt; A[mid+1]: hi = mid else: lo = mid + 1 return lo 方法四：黄金分割法，应用在单峰函数求极值，速度比二分法要快。 12345678910111213141516171819def peakIndexInMountainArray(self, A: 'List[int]') -&gt; 'int': def gold1(i, j): return i + int(round((j-i) * 0.382)) def gold2(i, j): return i + int(round((j-i) * 0.618)) l, r = 0, len(A) - 1 x1, x2 = gold1(l, r), gold2(l, r) while x1 &lt; x2: if A[x1] &lt; A[x2]: l = x1 x1 = x2 x2 = gold1(x1, r) else: r = x2 x2 = x1 x1 = gold2(l, x2) return x1 1014. Capacity To Ship Packages Within D Daysn天内轮船运送的最小容量。原题1234567891011Input: weights = [1,2,3,4,5,6,7,8,9,10], D = 5Output: 15Explanation: A ship capacity of 15 is the minimum to ship all the packages in 5 days like this:1st day: 1, 2, 3, 4, 52nd day: 6, 73rd day: 84th day: 95th day: 10Note that the cargo must be shipped in the order given, so using a ship of capacity 14 and splitting the packages into parts like (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) is not allowed. 贴一下竞赛时AC的丑陋写法。 123456789101112131415161718192021222324def shipWithinDays(self, weights: List[int], D: int) -&gt; int: def can_ship(capacity, D): l = 0 for _ in range(D): each = 0 for r in range(l, len(weights)): if weights[r]+each &lt;= capacity: each += weights[r] else: l = r break else: return True return False lo, hi = max(weights), sum(weights) while lo &lt;= hi: mid = (lo + hi) // 2 if can_ship(mid, D): hi = mid - 1 else: lo = mid + 1 return lo 优化。遇见一个诡异的现象，同样的代码用python比python3快了60ms，和3MB的内存。这解法也没涉及两者的区别。 123456789101112131415def shipWithinDays(self, weights: List[int], D: int) -&gt; int: lo, hi = max(weights), sum(weights) while lo &lt;= hi: mid, days, cur = (lo + hi) // 2, 1, 0 for w in weights: if cur+w &gt; mid: days += 1 cur = 0 cur += w if days &gt; D: lo = mid + 1 else: hi = mid - 1 # print(lo, mid, hi) return lo 875. Koko Eating Bananas这道题思路和1014一样。不同的是，如果当前堆的香蕉小于吃的速度，那么也不能吃下一堆。原题12Input: piles = [3,6,7,11], H = 8Output: 4 方法一：写习惯了Python3，老是想写//，注意是p/mid。 1234567891011def minEatingSpeed(self, piles: List[int], H: int) -&gt; int: lo, hi = 1, max(piles) while lo &lt;= hi: mid = (lo + hi ) &gt;&gt; 1 # needs = sum(math.ceil(p/mid) for p in piles) # slower needs = sum((p-1)//mid+1 for p in piles) if needs &gt; H: lo = mid + 1 else: hi = mid - 1 return lo]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
        <tag>Algorithm</tag>
        <tag>Binary Search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer]]></title>
    <url>%2F%E5%89%91%E6%8C%87Offer%2F</url>
    <content type="text"><![CDATA[2. 实现Singleton模式使用__new__控制实例创建过程123456789class Singleton: _instance = None def __new__(cls, *args, **kw): if not cls._instance: cls._instance = super().__new__(cls) return cls._instanceclass MyClass(Singleton): pass 使用decorator12345678910111213from functools import wrapsdef singleton(cls): instances = &#123;&#125; @wraps(cls) def get_instance(*args, **kw): if cls not in instances: instances[cls] = cls(*args, **kw) return instances[cls] return get_instance@singletonclass Myclass: pass 使用元类123456789101112131415class Singleton(type): def __init__(self, *args, **kwargs): self.__instance = None super().__init__(*args, **kwargs) def __call__(self, *args, **kwargs): if self.__instance is None: self.__instance = super().__call__(*args, **kwargs) return self.__instance else: return self.__instance# Exampleclass Spam(metaclass=Singleton): def __init__(self): print('Creating Spam') 3 数组中重复的数字牛客网传送门书中参数还传了一个数组用来保存重复的数字，身为一个Pythoner，直接返回tuple。 123456789def duplicate(nums: list) -&gt; int: for i, num in enumerate(nums): while i != num: if num == nums[num]: return True, num else: nums[i], nums[num] = nums[num], nums[i] num = nums[i] return False, None 3_1 数组中重复的数字，不能修改数组AcWing传送门元素范围变成了1~n。此方法有缺陷，不能找出所有的重复的数字，因为在1~2的范围里有1和2两个数字，这个范围的数字也出现两次，不能确定是每个数字各出现一次还是某个数字出现了两次。 12345678910111213141516171819def find_duplicate(nums: list) -&gt; int: def count_range(i, j): return sum(i&lt;=num&lt;=j for num in nums) lo = 1 hi = len(nums) - 1 # n为范围 while lo &lt;= hi: mid = (lo + hi) // 2 count = count_range(lo, mid) if lo == hi: if count &gt; 1: return lo else: break if count &gt; mid-lo+1: hi = mid else: lo = mid + 1 return -1 4. 二维数组中的查找牛客网传送门AcWing传送门选取右上角为起始点。 1234567891011def find(target, array): row = 0 col = len(array[0]) - 1 while col &gt;= 0 and row &lt;= len(array)-1: if array[row][col] &gt; target: col -= 1 elif array[row][col] &lt; target: row += 1 else: return True return False 5.替换空格牛客网传送门AcWing传送门12def replaceSpace(self, s): return ''.join(c if c!=' ' else '%20' for c in s) 6.从尾到头打印链表AcWing传送门123456def printListFromTailToHead(self, listNode): stack, h = [], listNode while h: stack.append(h.val) h = h.next return stack[::-1] 7.重建二叉树LeetCode传送门说明：根据前序遍历和中序遍历重建二叉树，假设遍历结果中不包含重复的数字。123456789def buildTree(preorder, inorder): if preorder == []: return None root_val = preorder[0] root = TreeNode(root_val) cut = inorder.index(root_val) root.left = buildTree(preorder[1:cut+1], inorder[:cut]) root.right = buildTree(preorder[cut+1:], inorder[cut+1:]) return root 方法二：空间复杂度更低的解法。 1234567891011def buildTree(self, preorder: 'List[int]', inorder: 'List[int]') -&gt; 'TreeNode': def build(stop): if inorder and inorder[-1] != stop: root = TreeNode(preorder.pop()) root.left = build(root.val) inorder.pop() root.right = build(stop) return root preorder.reverse() inorder.reverse() return build(None) 8 二叉树的下一个节点牛客网传送门AcWing传送门12345678910111213141516def GetNext(self, pNode): # write code here if not pNode: return None # 有右子树，右子树中最左节点 if pNode.right: pre = pNode.right while pre.left: pre = pre.left return pre while pNode.next: parent = pNode.next if parent.left == pNode: return parent pNode = parent return None 9.用两个栈实现队列LeetCode传送门123456789101112131415161718192021class MyQueue: def __init__(self): self.s1 = [] self.s2 = [] def push(self, x: int) -&gt; None: while self.s1: self.s2.append(self.s1.pop()) self.s1.append(x) while self.s2: self.s1.append(self.s2.pop()) def pop(self) -&gt; int: return self.s1.pop() def peek(self) -&gt; int: return self.s1[-1] def empty(self) -&gt; bool: return self.s1 == [] 9.1用两个队列实现栈LeetCode传送门两个队列1234567891011121314151617181920class MyStack: def __init__(self): from collections import deque self.q1, self.q2 = deque(), deque() def push(self, x: int) -&gt; None: self.q2.append(x) while self.q1: self.q2.append(self.q1.popleft()) self.q1, self.q2 = self.q2, self.q1 def pop(self) -&gt; int: return self.q1.popleft() def top(self) -&gt; int: return self.q1[0] def empty(self) -&gt; bool: return not self.q1 单队列旋转123456789101112131415161718192021class MyStack: def __init__(self): from collections import deque self.q = deque() def push(self, x: int) -&gt; None: self.q.append(x) # self.q.rotate(1) 这里是用了双端队列的特性 # self.q.rotate(1-len(self.q)) 这里和下面循环是一样的效果 for _ in range(len(self.q)-1): self.q.append(self.q.popleft()) def pop(self) -&gt; int: return self.q.popleft() def top(self) -&gt; int: return self.q[0] def empty(self) -&gt; bool: return not self.q 10.斐波那契数列LeetCode传送门12345def fibonacci(n): a = b = 1 for _ in range(n-1): a, b = b, a+b return b 11.旋转数组的最小数字LeetCode传送门思路：通过二分法不断缩小范围，由于mid是整除，最后l==mid，并且nums[mid] &gt; nums[r]的。123456789101112def find_min(nums): l, r = 0, len(nums)-1 if nums[l] &lt; nums[r]: return nums[l] while l &lt;= r: mid = (l+r) // 2 if nums[mid] &gt; nums[l]: l = mid elif nums[mid] &lt; nums[r]: r = mid else: return nums[r] 12.矩阵中的路径LeetCode传送门123456789101112131415161718192021def exist(self, g: List[List[str]], word: str) -&gt; bool: R, C = len(g), len(g[0]) def spread(i, j, w): if not w: return True original, g[i][j] = g[i][j], '-' spreaded = False for x, y in ((i-1, j), (i+1, j), (i, j-1), (i, j+1)): if (0&lt;=x&lt;R and 0&lt;=y&lt;C and w[0]==g[x][y] and spread(x, y, w[1:])): spreaded = True break g[i][j] = original return spreaded for i in range(R): for j in range(C): if g[i][j] == word[0] and spread(i, j, word[1:]): return True return False 13. 机器人的运动范围AcWing传送门1234567891011121314def movingCount(self, threshold, rows, cols): visited = [[False]*cols for _ in range(rows)] def get_sum(x, y): return sum(map(int, str(x)+str(y))) def movingCore(threshold, rows, cols, i, j): if get_sum(i, j) &lt;= threshold: visited[i][j] = True for x, y in ((i-1, j), (i+1, j), (i, j-1), (i, j+1)): if 0&lt;=x&lt;rows and 0&lt;=y&lt;cols and not visited[x][y]: movingCore(threshold, rows, cols, x, y) movingCore(threshold, rows, cols, 0, 0) return sum(sum(visited, [])) 14.剪绳子AcWing传送门说明：数学思想，当n&gt;=5时，2(n-2)&gt;n并且3(n-3)&gt;n，而且3(n-3) &gt;= 2(n-2)，所以尽可能多剪长度为3的绳子。如果长度为4的时候，2*2&gt;3*1，所以4的时候就剪成2*2的两段。 123456789101112131415def cut_rope(length): if length &lt; 2: return 0 if length == 2: return 1 if length == 3: return 2 # 尽可能剪出3 timesOf3 = length // 3 # 如果最后余1，则留一段4分成两半 if length-timesOf3*3 == 1: timeOf3 -= 1 timesOf2 = (length-timesOf3*3) // 2 return (3**timesOf3) * (2**timesOf2) 15.二进制中1的个数LeetCode传送门方法一：常规解法，使用1与n作与运算，如果不是0说明，含有一个1。123456def hamming_weight(n): count = 0 for _ in range(32): count += (n&amp;1==1) n &gt;&gt;= 1 return count 方法二：关键点是，一个数n和n-1的与运算操作，相当于去掉了最右面的1。123456def hamming_weigth(n): bits = 0 while n: bits += 1 n = (n-1) &amp; n return bits 16.数值的整数次方LeetCode传送门1234567891011121314151617def myPow(self, x: float, n: int) -&gt; float: def pow_with_unsigned(x, n): if n == 0: return 1 if n == 1: return x ans = pow_with_unsigned(x, n&gt;&gt;1) ans *= ans if n &amp; 1 == 1: ans *= x return ans if n &lt; 0: return 1 / pow_with_unsigned(x, -n) else: return pow_with_unsigned(x, n) 17 打印从1到最大的n位数404.打印呗，反正Python的int没有长度限制。 1234def print_n(n: int): n = 10 ** (n) for i in range(1, n): print(i) 18.删除链表中的节点LeetCode传送门开始看到这题的思路是，要是能拿到父节点就好了，然后这道题需要别的思路，其关键在于复制123def deleteNode(self, node): node.val = node.next.val # 4-&gt;1-&gt;1-&gt;9 node.next = node.next.next # 4-&gt;1-&gt;9 19.正则表达式LeetCode传送门先考虑没有*的情况，通过一个递归逐个字符判断 1234def match(text, pattern): if not pattern: return not text first_match = bool(text) and pattern[0] in &#123;text[0], '.'&#125; return first_match and match(text[1:], pattern[1:]) 当*出现时，一定会在前面跟一个其他字符，所以一定会出现在pattern[1]的位置。一种情况是我们忽略这对pattern，因为可以出现0次；另一种情况是匹配上这个字符，用递归的方式匹配下一个。 一定要用f_match = bool(s)，否则结果可能输出&#39;&#39; 12345678def match(self, s, pattern): if not pattern: return not s f_match = bool(s) and pattern[0] in &#123;s[0], '.'&#125; if len(pattern) &gt; 1 and pattern[1] == '*': return (self.match(s, pattern[2:]) or (f_match and self.match(s[1:], pattern))) else: return f_match and self.match(s[1:], pattern[1:]) 20. 表示数值的字符串65. Valid Number此处留坑，排名第一的python答案暂时没有理解。 21.调整数组顺序使奇数位于偶数前面AcWing传送门时间：O(n), 空间O(1) 123456789def reOrderArray(self, array): # write code here l, r = 0, len(array)-1 while l &lt; r: while l &lt; r and array[l]&amp;1 == 1: l += 1 while l &lt; r and array[r]&amp;1 == 0: r -= 1 array[l], array[r] = array[r], array[l] 看了一下没有通过牛客网的测试用例，因为题目有些不同，牛客网要求奇数和奇数，偶数和偶数之前的相对位置不变。 12def reOrderArray(array): return sorted(array, key=lambda x:x&amp;1==0) 不使用sort 1234567891011def reOrderArray(self, array): # write code here from collections import deque q = deque() n = len(array) for i in range(n): if array[-i-1] &amp; 1 == 1: # 从后找奇数 q.appendleft(array[-i-1]) if array[i] &amp; 1 == 0: #从前找偶数 q.append(array[i]) return q 22.链表中倒数第k个节点AcWing传送门思路：两个指针，快指针先走k-1步，然后两个一起走，快指针走到尾节点时，慢指针在倒数第k个节点。需考虑k=0时和fast已经走到尾节点的情况。 12345678910def FindKthToTail(self, head, k): fast = slow = head for _ in range(k): if fast: fast = fast.next else: return None while fast: slow, fast = slow.next, fast.next return slow 23.链表中环的入口节点LeetCode传送门 首先判断此链表是否有环。 然后再相交点和头结点一起走，一定会在入口相遇。 12345678910111213def detectCycle(self, head): fast = slow = head # 检测是否有环 while fast and fast.next: slow, fast = slow.next, fast.next.next if slow is fast: break else: return None # 找出入口节点 while head is not slow: head, slow = head.next, slow.next return head 24.反转链表LeetCode传送门12345def reverseList(self, head): prev = None while head: head.next, prev, head = prev, head, head.next return prev 25.合并两个有序链表LeetCode传送门方法1：iteratively 迭代 12345678910def mergeTwoLists(l1, l2): l = head = ListNode(0) while l1 and l2: if l1.val &lt;= l2.val: l.next, l1 = l1, l1.next else: l.next, l2 = l2, l2.next l = l.next l.next = l1 or l2 return head.next 方法2：recursively 递归 12345678910def mergeTwoLists(l1, l2): # 判断是否存在None if not l1 or not l2: return l1 or l2 if l1.val &lt; l2.val: l1.next = mergeTwoLists(l1.next, l2) return l1 else: l2.next = mergeTwoLists(l1, l2.next) return l2 26.树的子结构572. Subtree of Another Tree 二刷的时候突然发现，此题和LeetCode中不同。LeetCode中子树4-1-2返回False因为2下边还有节点，所以不一样；而书中认为True，不考虑2下边的节点。 1234567 3 / \ 4 5 / \1 2 / 0 12345678910111213141516171819202122def is_subtree(s: 'TreeNode', t: 'TreeNode') -&gt; 'bool': def is_same(s, t): if s and t: equal = s.val==t.val if not t.left and not t.right: return equal else: return (equal and is_same(s.left, t.left) and is_same(s.right, t.right)) else: return s is t stack = s and [s] while stack: node = stack.pop() if node: res = is_same(node, t) if res: return True stack.append(node.right) stack.append(node.left) return False 27.二叉树的镜像AcWing传送门12345def Mirror(self, root): if root: root.left, root.right = root.right, root.left self.Mirror(root.left) self.Mirror(root.right) 迭代 1234567def Mirror(self, root): stack = root and [root] while stack: n = stack.pop() if n: n.left, n.right = n.right, n.left stack += n.right, n.left 28.对称的二叉树LeetCode传送门12345 1 / \ 2 2 / \ / \3 4 4 3 方法一：recursively. 123456789101112def isSymmetric(self, root: 'TreeNode') -&gt; 'bool': def symmetric(p1, p2): if p1 and p2: return (p1.val == p2.val and symmetric(p1.left, p2.right) and symmetric(p1.right, p2.left)) else: return p1 is p2 if not root: return True return symmetric(root.left, root.right) 方法二：iteratively. 12345678910def isSymmetric(self, root: 'TreeNode') -&gt; 'bool': stack = root and [(root.left, root.right)] while stack: p1, p2 = stack.pop() if not p1 and not p2: continue if not p1 or not p2: return False if p1.val != p2.val: return False stack.append((p1.left, p2.right)) stack.append((p1.right, p2.left)) return True 29.顺时针打印矩阵LeetCode传送门这里注意一点matrix.pop(0)需要转成list，因为zip函数中的每个元素是一个tuple，如果不转变成了一个tuple+list，会抛出异常。 123def spiralOrder(self, matrix): return (matrix and list(matrix.pop(0)) + self.spiralOrder(list(zip(*matrix))[::-1])) 此题有个变形，如果逆时针该如何打印。这样的话情况稍微复杂一些。 1234567def anti_clock_wise(self, matrix) if not matrix: return [] clock_wise = list(zip(*(matrix[::-1]))) a = list(clock_wise.pop(0))[::-1] b = self.anti_clock_wise(clock_wise) return a + b 30.包含min函数的栈LeetCode传送门12345678910111213141516171819202122232425class MinStack: def __init__(self): self._stack = [] def push(self, x: int) -&gt; None: cur_min = self.getMin() if x &lt; cur_min: cur_min = x self._stack.append((x, cur_min)) def pop(self) -&gt; None: self._stack.pop() def top(self) -&gt; int: if not self._stack: return None else: return self._stack[-1][0] def getMin(self) -&gt; int: if not self._stack: return float('inf') else: return self._stack[-1][1] 31.栈的压入、弹出序列LeetCode传送门123456789def validateStackSequences(self, pushed: 'List[int]', popped: 'List[int]') -&gt; 'bool': stack = [] j = 0 for num in pushed: stack.append(num) while stack and stack[-1] == popped[j]: stack.pop() j += 1 return j == len(popped) 32.从上到下打印二叉树AcWing传送门双端队列 1234567891011def PrintFromTopToBottom(self, root): from collections import deque queue = deque([root]) res = [] while queue: cur = queue.popleft() if cur: res.append(cur.val) queue.append(cur.left) queue.append(cur.right) return res 32.1分层从上到下打印二叉树LeetCode传送门123456def levelOrder(self, root: 'TreeNode') -&gt; 'List[List[int]]': ans, level = [], root and [root] while level: ans.append([n.val for n in level]) level = [k for n in level for k in (n.left, n.right) if k] return ans 32.2之字形打印二叉树LeetCode传送门1234567def zigzagLevelOrder(self, root: 'TreeNode') -&gt; 'List[List[int]]': ans, level, order = [], root and [root], 1 while level: ans.append([n.val for n in level][::order]) order *= -1 level = [kid for n in level for kid in (n.left, n.right) if kid] return ans 33.是否是二叉树的后序遍历AcWing传送门123456789101112131415def VerifySquenceOfBST(self, seq): from itertools import takewhile if not seq: return False p = seq[-1] left_sub = list(takewhile(lambda x: x &lt; p, seq[:-1])) right_sub = seq[len(left_sub):-1] if not all(x&gt;p for x in right_sub): return False left = right = True if left_sub: left = self.VerifySquenceOfBST(left_sub) if right_sub: right = self.VerifySquenceOfBST(right_sub) return left and right 34.二叉树和为某一值的路径LeetCode传送门12345678910111213sum = 22 5 / \ 4 8 / / \ 11 13 4 / \ / \7 2 5 1[ [5,4,11,2], [5,8,4,5]] 方法一：iteratively. 举一反三。 123456789101112def pathSum(self, root: 'TreeNode', total: 'int') -&gt; 'List[List[int]]': stack = root and [(root, [root.val], total)] ans = [] while stack: n, v, t = stack.pop() if not n.left and not n.right and n.val==t: ans.append(v) if n.right: stack.append((n.right, v+[n.right.val], t-n.val)) if n.left: stack.append((n.left, v+[n.left.val], t-n.val)) return ans recursively. 先找出所有路径，再过滤，实际上和257题一样。不过这并没有把这道题的特性涵盖进去。 12345678910def pathSum(self, root, sum_val): paths = self.all_paths(root) return [path for path in paths if sum(path)==sum_val] def all_paths(self, root): if not root: return [] return [[root.val]+path for kid in (root.left, root.right) if kid for path in self.all_paths(kid)] or [[root.val]] 方法三：recursively. 123456789def pathSum(self, root, sum): if not root: return [] val, *kids = root.val, root.left, root.right if any(kids): return [[val] + path for kid in kids if kid for path in self.pathSum(kid, sum-val)] return [[val]] if val==sum else [] 35.复杂链表的复制LeetCode传送门方法一：遍历两次。 1234567891011def copyRandomList(self, head: 'Node') -&gt; 'Node': cp = &#123;None: None&#125; m = n = head while m: cp[m] = Node(m.val, None, None) m = m.next while n: cp[n].next = cp[n.next] cp[n].random = cp[n.random] n = n.next return cp[head] Time-O(n), Memory-O(n). 这种方式是相当于把第一次迭代的过程委托给了defaultdict，通过创建一个默认的对象，再去修改它的label值。 12345678910def copyRandomList(self, head: 'Node') -&gt; 'Node': cp = collections.defaultdict(lambda: Node(0, None, None)) cp[None] = None h = head while h: cp[h].val = h.val cp[h].next = cp[h.next] cp[h].random = cp[h.random] h = h.next return cp[head] 36.二叉搜索树与双向链表LeetCode有此题，但是不是免费的。AcWing传送门方法一：中序遍历，再构造链表。 1234567891011121314def convert(self, root): from itertools import tee def dfs(node): if node: yield from dfs(node.left) yield node yield from dfs(node.right) a, b = tee(dfs(root)) ans = next(b, None) for f, s in zip(a, b): f.right = s s.left = f return ans 方法二：分别递归处理左子树和右子树。 12345678910111213141516171819202122232425def Convert(self, root): def convert_tree(node): if not node: return None if node.left: left = convert_tree(node.left) while left.right: left = left.right left.right = node node.left = left if node.right: right = convert_tree(node.right) while right.left: right = right.left right.left = node node.right = right return node if not root: return root root = convert_tree(root) while root.left: root = root.left return root 方法三：Morris Traversal. 1234567891011121314151617def Convert(self, root): cur = root pre = ans = None while cur: while cur.left: q = cur.left while q.right: q = q.right q.right = cur # 补齐右指针 cur.left, cur = None, cur.left # 拆掉左指针 cur.left = pre if pre is None: ans = cur # 这里是为了找到链表的头，只执行一次 else: pre.right = cur pre, cur = cur, cur.right return ans 37.序列化二叉树LeetCode传送门12345678910111213141516171819class Codec: def serialize(self, root): if not root: return '$' return str(root.val) + ',' + self.serialize(root.left) + ',' + self.serialize(root.right) def deserialize(self, data): def deserialize_tree(nodes): val = next(nodes) if val == '$': return None root = TreeNode(val) root.left = deserialize_tree(nodes) root.right = deserialize_tree(nodes) return root nodes = iter(data.split(',')) return deserialize_tree(nodes) 38.字符串的排列46. Permutations II 使用itertools 123456def Permutation(self, ss): # write code here from itertools import permutations if not ss: return [] return sorted(list(set([''.join(x) for x in permutations(ss)]))) 这里注意几点： 为什么要判断if not ss，是因为如果ss=&#39;&#39;的时时候，返回了[&#39;&#39;]而不是[]。因为这里返回了一个空的tuple，所以在列表推导式中是有一个元素的。 12&gt;&gt;&gt; list(permutations('', 0))[()] 为什么使用set去重，因为当ss=&#39;aa&#39;的时候，牛客网的测试用例要求返回一个元素，即[&#39;aa&#39;]。 排序也是为了满足测试用例。 自己实现。这里拆成两个方法的原因还是因为ss=&#39;&#39;的时候会影响递归循环。 12345678910def Permutation(self, ss): if not ss: return [] return self.permute(ss)def permute(self, ss): return sorted(list(set([h + p for i, h in enumerate(ss) for p in self.permute(ss[:i]+ss[i+1:]) ]))) or [""] 方法二：迭代。 123456def Permutation(self, ss): ans = [''] for s in ss: ans = [p[:i] + s + p[i:] for p in ans for i in range((p+s).index(s)+1)] return sorted(ans) if ss else [] 39.数组中出现次数超过一半的数字LeetCode传送门方法一：排序. Time-O(nlogn), Space-O(n) 12def majority_element(nums): return sorted(nums)[len(nums)//2] 方法二：Counter Time-O(n), Space-O(n) 12345def majority_element(nums): from collections import Counter c = Counter(nums) # return max(c.keys(), key=c.get) return c.most_common(1)[0][0] 方法三：Boyer-Moore Voting Algorithm. 书中的算法说的就是这个，这详情请看波义尔摩尔投票。 12345678def majorityElement(self, nums): count = 0 candidate = None for num in nums: if count == 0: candidate = num count += (1 if num == candidate else -1) return candidate 40.最小的k个数相似题目，但是求最大的k个数LeetCode传送门牛客网传送门12345678910111213141516171819202122def GetLeastNumbers_Solution(self, tinput, k): # write code here l, r = 0, len(tinput)-1 if k &gt; len(tinput) or k &lt; 1: return [] # for passing the damn testcase while True: pos = self.partition(tinput, l, r) if pos &lt; k-1: l = pos + 1 elif pos &gt; k-1: r = pos - 1 else: return sorted(tinput[:pos+1]) # sorted for passing the damn testcase def partition(self, nums, l, r): from random import randint p = randint(l, r) nums[r], nums[p] = nums[p], nums[r] for i, v in enumerate(nums[l:r+1], l): if nums[i] &lt;= nums[r]: nums[l], nums[i] = nums[i], nums[l] l += 1 return l-1 # the pivot index 使用堆，不改变原数组 123456789def GetLeastNumbers_Solution(self, tinput, k): import heapq as hq if k &gt; len(tinput) or k &lt;= 0: return [] heap = [-x for x in tinput[:k]] hq.heapify(heap) for num in tinput[k:]: if -heap[0] &gt; num: hq.heapreplace(heap, -num) return sorted(-x for x in heap) 41.数据流中的中位数LeetCode传送门思路：使用两个堆，最大堆存储较小的数据，最小堆存储较大的数据。添加数字时，先添加到最大堆，然后最大堆返回一个最大的数字给最小堆，最后为了平衡，可能需要最小堆还给最大堆一个最小值，以保证最大堆的长度&gt;=最小堆的长度。由于headpq是最小堆，所以使用取反实现最大堆。添加数字：Time-O(logn)，取出中位数：Time-O(1)。 1234567891011121314151617181920212223242526272829Adding number 41MaxHeap lo: [41] // MaxHeap stores the largest value at the top (index 0)MinHeap hi: [] // MinHeap stores the smallest value at the top (index 0)Median is 41=======================Adding number 35MaxHeap lo: [35]MinHeap hi: [41]Median is 38=======================Adding number 62MaxHeap lo: [41, 35]MinHeap hi: [62]Median is 41=======================Adding number 4MaxHeap lo: [35, 4]MinHeap hi: [41, 62]Median is 38=======================Adding number 97MaxHeap lo: [41, 35, 4]MinHeap hi: [62, 97]Median is 41=======================Adding number 108MaxHeap lo: [41, 35, 4]MinHeap hi: [62, 97, 108]Median is 51.5 12345678910111213141516171819import heapq as hqclass MedianFinder: def __init__(self): self.lo, self.hi = [], [] # lo is max_heap, hi is min_heap def addNum(self, num): hq.heappush(self.lo, -num) hq.heappush(self.hi, -hq.heappop(self.lo)) if len(self.lo) &lt; len(self.hi): hq.heappush(self.lo, -hq.heappop(self.hi)) def findMedian(self): if len(self.lo) == len(self.hi): return (-self.lo[0]+self.hi[0]) / 2.0 else: return float(-self.lo[0]) 42.连续子数组的最大和LeetCode传送门方法一：书中的思想。 123456def maxSubArray(self, nums): cp_nums = nums[:] for i in range(1, len(nums)): if cp_nums[i-1] &gt; 0: cp_nums[i] += cp_nums[i-1] return max(cp_nums) 方法二：one-liner。注意accumulate是把函数放到后面的。 123def maxSubArray(self, nums): from itertools import accumulate return max(accumulate(nums, lambda x, y: x+y if x &gt; 0 else y)) 43.1~n整数中1出现的次数LeetCode传送门1234567def countDigitOne(self, n): countr, i = 0, 1 while i &lt;= n: divider = i * 10 countr += (n // divider) * i + min(max(n % divider - i + 1, 0), i) i *= 10 return countr 45.把数组排成最小的数字AcWing传送门python2的写法。 123def PrintMinNumber(self, numbers): return ''.join(sorted(map(str, numbers), lambda x, y: cmp(x+y, y+x))) 匿名函数作为sort的参数，在python2中有这个参数。 cmp specifies a custom comparison function of two arguments (iterable elements) which should return a negative, zero or positive number depending on whether the first argument is considered smaller than, equal to, or larger than the second argument: cmp=lambda x,y: cmp(x.lower(), y.lower()). The default value is None. 作为sort的参数，cmp提供了一个自定义的比较两个元素的方法，如果返回-1表示前者小于后者。python3中取消了这个参数，但是提供了一种key的转换。而内置函数可以通过运算符实现。 1cmp(a, b) 等同于 1(a&gt;b) - (a&lt;b) 所以python3的写法如下： 123456from functools import cmp_to_keydef PrintMinNumber(self, numbers): # write code here nums = list(map(str, numbers)) nums.sort(key=cmp_to_key(lambda x, y: ((x+y)&gt;(y+x)) - ((y+x)&gt;(x+y)))) return ''.join(nums) 46 把数字翻译成字符串LeetCode传送门123456789def numDecodings(self, s: str) -&gt; int: # w tells the number of ways # v tells the previous number of ways # d is the current digit # p is the previous digit v, w, p = 0, int(s&gt;''), '' for d in s: v, w, p = w, int(d&gt;'0')*w + (9&lt;int(p+d)&lt;27)*v, d return w 47 礼物的最大价值LeetCode传送门。相似题目，不过也差不少。Acwing传送门这个是原题。对首行使用初始化，然后消除了i的判断。 12345678910def get_max_value(g: 'List[List[int]]') -&gt; int: R, C = len(g), len(g[0]) cur = list(itertools.accumulate(g[0])) for i in range(1, R): tmp = [] for j in range(C): left = tmp[-1] if j &gt; 0 else float('-inf') tmp.append(max(cur[j], left) + g[i][j]) cur = tmp return cur[-1] 48.最长不含重复字符的子字符串LeetCode传送门方法二：找到重复值时，更新start的值，为什么使用max，因为start有可能大于dic[s[end]]+1，比如当s=&#39;abba&#39;，end走到最后的时候，上一次start因为b做了更新变为了2。 123456789def lengthOfLongestSubstring(self, s): ans = start = 0 pos = &#123;&#125; # last index of element for end, c in enumerate(s): if c in pos: start = max(start, pos[c]+1) pos[c] = end ans = max(ans, end-start+1) return ans 49.丑数LeetCode传送门1234567891011121314def nthUglyNumber(self, n: int) -&gt; int: q = [1] t2 = t3 = t5 = 0 for _ in range(n-1): a2, a3, a5 = q[t2]*2, q[t3]*3, q[t5]*5 to_add = min(a2, a3, a5) q.append(to_add) if a2 == to_add: t2 += 1 if a3 == to_add: t3 += 1 if a5 == to_add: t5 += 1 return q[-1] 50.第一个只出现一次的字符LeetCode传送门有一点小区别，LeetCode输出索引，书中输出值。1234s = &quot;leetcode&quot;return 0.s = &quot;loveleetcode&quot;,return 2. Time-O(N), Space-O(N)。暂时没发现更快的算法了。 1234567def firstUniqChar(self, s): from collections import Counter c = Counter(s) for i, ch in enumerate(s): if c[ch] == 1: return i return -1 51.数组中的逆序对牛客网传送门AcWing传送门这里使用了双端队列感觉不太合适，因为还要显式地转成list，否则没法对剩余的left或right做切片。也试了将其改为stack，但是stack来回reverse又太麻烦。 123456789101112131415161718192021222324252627def InversePairs(self, data): self.count = 0 def merge(left, right): q = deque() l, r = len(left)-1, len(right)-1 while l &gt;= 0 and r &gt;= 0: if left[l] &gt; right[r]: self.count += r + 1 q.appendleft(left[l]) l -= 1 else: q.appendleft(right[r]) r -= 1 # q.extendleft(left[l:-1:-1] or right[r:-1:-1]) q = left[:l+1] + right[:r+1] + list(q) return q def merge_sort(ary): if len(ary) &lt;= 1: return ary mid = len(ary) // 2 left = merge_sort(ary[:mid]) right = merge_sort(ary[mid:]) return merge(left, right) merge_sort(data) return self.count % 1000000007 52.两个链表的第一个公共节点LeetCode传送门123456def getIntersectionNode(self, headA, headB): p1, p2 = headA, headB while p1 is not p2: p1 = p1.next if p1 else headB p2 = p2.next if p2 else headA return p1 53.在排序数组中查找数字相似题目，LeetCode是求出数字的索引，书中返回个数。 LeetCode传送门。相似题目，LeetCode要返回两个索引，书中求个数。1234Input: nums = [5,7,7,8,8,10], target = 8Output: [3,4]Input: nums = [5,7,7,8,8,10], target = 6Output: [-1,-1] 方法一：标准库写法。这里不需要target去整个nums中判断。 1234567def searchRange(self, nums: List[int], target: int) -&gt; List[int]: from bisect import bisect, bisect_left lo = bisect_left(nums, target) if target in nums[lo:lo+1]: return lo, bisect(nums, target)-1 else: return -1, -1 方法二：自己实现。bisect_right的方式采用+1的形式。 12345678910111213141516def searchRange(self, nums: List[int], target: int) -&gt; List[int]: def search(n): lo, hi = 0, len(nums) while lo &lt; hi: mid = (lo + hi) // 2 if nums[mid] &gt;= n: hi = mid else: lo = mid + 1 return lo lo = search(target) if target in nums[lo:lo+1]: return lo, search(target+1)-1 else: return -1, -1 53.0~n-1中缺失的数字LeetCode传送门相似题目，LeetCode是未排序，书中是已排序。所以可以利用排序的特性使时间复杂度小于O(n)。即找出第一个下标与值不相等的元素，再-1就是缺失的元素。 AcWing传送门方法一：数学公式。 12345def missingNumber(self, nums): n = len(nums) expected_sum = n*(n+1) // 2 actual_sum = sum(nums) return expected_sum - actual_sum 方法二：XOR. index 0 1 2 value 3 0 1 12345def missingNumber(self, nums: 'List[int]') -&gt; 'int': missing = len(nums) for i, num in enumerate(nums): missing ^= i ^ num return missing 方法三：利用书中已排序的特性。 1234567891011def getMissingNumber(self, nums): lo, hi = 0, len(nums)-1 while lo &lt;= hi: mid = (lo + hi) &gt;&gt; 1 if nums[mid] != mid: if mid==0 or nums[mid-1]==mid-1: return mid hi = mid - 1 else: lo = mid + 1 return lo 53 数组中数值和下标相等的元素AcWing传送门1234567891011def getNumberSameAsIndex(self, nums): lo, hi = 0, len(nums)-1 while lo &lt;= hi: mid = (lo + hi) &gt;&gt; 1 if nums[mid] &lt; mid: lo = mid + 1 elif nums[mid] &gt; mid: hi = mid - 1 else: return mid return -1 54.二叉搜索树的第k大节点AcWing传送门注意：牛客网上是求第k小节点，这里被坑了一次，然后返回值居然要求返回节点对象，而不是节点值，这里的答案按书中返回。如果是牛客网上需要把节点添加到res中，然后return res[k-1] 123456789101112def kth_largest(self, root: TreeNode, k: int) -&gt; int: stack, ans = [], None while stack or root: while root: stack.append(root) root = root.right root = stack.pop() k -= 1 ans = root root = root.left if k == 0: return ans 55.二叉树的深度LeetCode传送门123456 3 / \ 9 20 / \ 15 7return 3 方法一：recursively 12345def max_depth(root): if not root: return 0 # return max(max_depth(root.left), max_depth(root.right)) + 1 return max(map(max_depth, (root.left, root.right))) + 1 方法二：iteratively. BFS with deque 12345678910def maxDepth(self, root: 'TreeNode') -&gt; 'int': q = root and collections.deque([(root, 1)]) d = 0 while q: node, d = q.popleft() if node.right: q.append((node.right, d+1)) if node.left: q.append((node.left, d+1)) return d 55.1平衡二叉树LeetCode传送门方法一：递归+递归。 12345678910def isBalanced(self, root): if not root: return True return self.isBalanced(root.left) and self.isBalanced(root.right) and \ abs(self.max_depth(root.left)-self.max_depth(root.right)) &lt;= 1 def max_depth(self, root): if not root: return 0 return max(self.max_depth(root.left), self.max_depth(root.right)) + 1 方法二：上诉两种方法中都包含了一些无意义的重复遍历。这里采用后序遍历，边遍历边判断，不会重复节点。受此思想启发，添加一种后序遍历二叉树的方法。 12345678910111213141516171819def isBalanced(self, root): stack, node, last = [], root, None depths = collections.defaultdict(int) while stack or node: if node: stack.append(node) node = node.left else: node = stack[-1] if not node.right or last == node.right: node = stack.pop() left, right = depths[node.left], depths[node.right] if abs(left - right) &gt; 1: return False depths[node] = 1 + max(left, right) last, node = node, None else: node = node.right return True 方法三：dfs. 算深度的时候判断左右是否深度超过1. 这里变量不能把self去掉，否则[1,2,2,3,3,null,null,4,4]会错误的返回True而不是False。也可以使用nonlocal 1234567891011121314def isBalanced(self, root: 'TreeNode') -&gt; 'bool': self.balanced = True def dfs(node): if not node: return 0 left = dfs(node.left) right = dfs(node.right) if abs(left-right) &gt; 1 and self.balanced: self.balanced = False return max(left, right) + 1 dfs(root) return self.balanced 56 数组中只出现一次的两个数字。找出数组中两个唯一出现一次的元素，其余元素均出现两次。LeetCode传送门12Input: [1,2,1,3,2,5]Output: [3,5] 思想：将这两个元素分到两个组，由于这两个数不相等，所以亦或结果不为0，也就是说二进制中至少有一位1，记为第n位。我们以第n位是否为1，把数组分为两个子数组。 123456789101112def singleNumber(self, nums: List[int]) -&gt; List[int]: from functools import reduce def get_single(nums): return reduce(operator.xor, nums) total_xor = get_single(nums) mask = 1 while total_xor&amp;mask == 0: mask &lt;&lt;= 1 n1 = [num for num in nums if num&amp;mask==0] n2 = [num for num in nums if num&amp;mask!=0] return get_single(n1), get_single(n2) 56.1数组中出现一次的数字，其余元素出现三次。LeetCode传送门12Input: [2,2,3,2]Output: 3 方法一：找出单独元素每一位的值。如果把所有数字的二进制每一位加起来，如果某一位可以被3整除，则表示单独元素的该位为0，否则为1。以下使用count来表示每一位1的个数。假设count%3!=0为True，说明该元素i位为1，然后是用|=更新ans在第i个位置的值，这里也可以使用+=，但是效率稍慢。convert的作用是因为python中的int是个对象，且没有最大限制，不是在第32位使用1来表示负数。 1234567891011121314def singleNumber(self, nums, n=3): ans = 0 for i in range(32): count = 0 for num in nums: if ((num &gt;&gt; i) &amp; 1): count += 1 ans |= ((count%n!=0) &lt;&lt; i) return self.convert(ans)def convert(self, x): if x &gt;= 2**31: x -= 2**32 return x 这里有个状态机的解法，不明觉厉，留坑。讨论1和讨论2 123456def singleNumber(self, nums): ones, twos = 0, 0; for i in range(len(nums)): ones = (ones ^ nums[i]) &amp; ~twos twos = (twos ^ nums[i]) &amp; ~ones return ones 57.和为s的数字牛客网传送门AcWing传送门看牛客网上的描述，如果有多对数字和为s，要求返回乘积最小的一对。乍一看以为牛客网又乱改题，但是仔细一想，如果两个和为s的数，而且是在递增数组中很明显，边缘的数字乘积要小，例如8X8&gt;1X15。所以还是和书中解法一样。 12345678910def FindNumbersWithSum(self, array, tsum): l, r = 0, len(array)-1 while l &lt; r: if array[l] + array[r] &lt; tsum: l += 1 elif array[l]+array[r] &gt; tsum: r -= 1 else: return array[l], array[r] return [] 57_1 和为s的连续正数序列牛客网传送门AcWing传送门1234567891011121314def findContinuousSequence(self, tsum): end = (tsum + 1) // 2 lo, hi, cur_sum = 1, 2, 3 ans = [] while lo &lt; end: if cur_sum &lt; tsum: hi += 1 cur_sum += hi else: if cur_sum == tsum: ans.append(list(range(lo, hi+1))) cur_sum -= lo lo += 1 return ans 58.翻转字符串。LeetCode传送门12Input: "the sky is blue",Output: "blue is sky the". 方法一：如果面试官是一个Pythoner，那么就让你过了。 12def reverse_words(s): return ' '.join(reversed(s.split())) 如果你的面试官是一个只写Java或者C，看见代码就不平衡了，凭啥可以写到一行，非要你实现reverse。 12345678910def reverseWords(self, s: str) -&gt; str: def hp_reversed(s): s = list(s) for i in range(len(s)//2): # s[i], s[-i-1] = s[-i-1], s[i] s[i], s[~i] = s[~i], s[i] return ''.join(s) s = hp_reversed(s) return ' '.join(hp_reversed(word) for word in s.split()) 实现split，hp_reverse， 1234567891011121314151617def reverseWords(self, s: str) -&gt; str: def hp_reversed(s): s = list(s) for i in range(len(s)//2): s[i], s[~i] = s[~i], s[i] return ''.join(s) s = hp_reversed(s) ans = word = '' for r, c in enumerate(s): if c != ' ': word += c if (c== ' ' or r==len(s)-1) and word: ans += hp_reversed(word) + ' ' word = '' return ans[:-1] 58_1 左旋转字符串牛客网传送门AcWing传送门切片，书中的方法个人觉得Python并不适用。 12345def LeftRotateString(self, s, n): if not s: return '' n = n % len(s) return s[n:] + s[:n] 59.滑动窗口的最大值。牛客网传送门AcWing传送门得益于python的切片。Time: O(n*k). k=n-size 123def maxInWindows(self, nums, size): return [max(nums[i:i+size]) for i in range(len(nums)-size+1) if size!=0 ] 方法二：常规写法，只是将书中的代码封装了一下，Time: O(n). 1234567891011121314151617181920def maxInWindows(self, nums, size): from collections import deque q = deque() ans = [] def pop_less(i): # nums[i] 索引和值都比队列尾的元素大，队列尾的元素就没有必要存在了 while q and nums[i]&gt;=nums[q[-1]]: q.pop() q.append(i) for i in range(size): pop_less(i) for i in range(size, len(nums)): ans.append(nums[q[0]]) pop_less(i) while q and q[0]&lt;= i-size: q.popleft() ans.append(nums[q[0]]) return ans 60.n个骰子的点数AcWing传送门1[[1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0], [0, 1, 2, 3, 4, 5, 6, 5, 4, 3, 2, 1]] dp[0][j]==1表示第一个骰子和为j+1的次数为1，因为数组下标从0开始。 12345678910111213141516def dice_probability(n, val=6): dp = [[0]*val*n for _ in range(n)] dp[0][:val] = [1] * val # 初始化第一个骰子 for i in range(n-1): # 根据第i个骰子更新第i+1个骰子 for j in range(i, len(dp[i+1])): # 第i+1个骰子和为j（实际为j+1，因为数组下标从0开始）的次数，等于第i个 # 骰子j-1 ~ j-6次数的总和 dp[i+1][j] = sum([dp[i][j-k] for k in range(1, val+1)]) # 整理数据成为dict，key表示和，value表示出现的次数 # count = &#123;i+1: times for i, times in enumerate(dp[-1])&#125; # 计算概率 count = &#123;i+1: round(float(times / (val**n)), 5) for i, times in enumerate(dp[-1]) if times!=0&#125; return count 感觉用dict来表示更加明确，没有数组下标从0开始的混淆。按照AcWing中的返回写出一种解法。 12345678910111213from collections import defaultdictfrom itertools import repeatdef numberOfDice(self, n): last_p = defaultdict(int) last_p.update(dict(zip(range(1, 7), repeat(1)))) for i in range(2, n+1): new_p = defaultdict(int) for j in range(i, i*6+1): new_p[j] = sum(last_p[j-k] for k in range(1, 7)) # print(new_p) last_p = new_p return list(last_p.values()) 61.扑克牌中的顺子牛客网传送门AcWing传送门开始以为还要用个dict来映射值，后来发现直接传得卡牌的值。思想就是先排序，然后查joker的数量，看剩下牌的差值加起来能不能用已有的joker连起来。 1234567891011def IsContinuous(self, numbers): if not numbers: return False joker_count = numbers.count(0) left_cards = sorted(numbers)[joker_count:] need_joker = 0 for i in range(len(left_cards)-1): if left_cards[i+1] == left_cards[i]: return False need_joker += (left_cards[i+1]-left_cards[i]-1) return need_joker &lt;= joker_count 使用标准库，更加优雅，原理相同。 123456789101112131415from itertools import teedef IsContinuous(self, numbers): if not numbers: return False joker_count = numbers.count(0) left_cards = sorted(numbers)[joker_count:] need_joker = 0 c1, c2 = tee(left_cards) next(c2, None) for s, g in zip(c1, c2): if g == s: return False need_joker += g - 1 - s return need_joker &lt;= joker_count 62.圆圈中最后剩下的数字方法一：其实不需要环形链表，使用一个list足矣，每次将其旋转rot位，一开始想将要把第m个数旋转到list首部，然后再pop(0)，后来想到直接可以通过切片取出来，节省了pop(0)的O(n)复杂度。 123456789def LastRemaining_Solution(self, n, m): # write code here if n&lt;=0 or m&lt;=0: return -1 seats = range(n) while seats: rot = (m-1) % len(seats) seats, last = seats[rot+1:] + seats[:rot], seats[rot] return last 方法二：书中的推导过程过于复杂，这里学到了一个稍微简单的推导过程。参考约瑟夫环问题。 解析Josephus-problem 1234567def LastRemaining_Solution(self, n, m): if n&lt;=0 or m&lt;=0: return -1 last_num = 0 for i in range(2, n+1): last_num = (last_num+m) % i return last_num 63.股票的最大利润LeetCode传送门方法一：Brute Force.其实就是求最高峰点和前面最低谷点的差。 123456def maxProfit(self, prices: List[int]) -&gt; int: profit, min_buy = 0, float('inf') for p in prices: min_buy = min(min_buy, p) profit = max(profit, p-min_buy) return profit 方法二：标准的卡登算法。此题为53.连续数组最大和的变形，如果价格比之前小，则舍弃，否则一起计算连续子数组的和。 1234567def maxProfit(self, prices: List[int]) -&gt; int: cur = sofar = 0 for i in range(1, len(prices)): cur += prices[i] - prices[i-1] cur = max(0, cur) sofar = max(cur, sofar) return sofar 方法三：使用标准库的卡登算法。 12345678910def maxProfit(self, prices: List[int]) -&gt; int: from itertools import tee cur = profit = 0 a, b = tee(prices) next(b, None) for before, today in zip(a, b): cur += today - before cur = max(0, cur) profit = max(profit, cur) return profit 64.求1+2+···+nAcWing传送门这题对python不是很友好，感觉and也属于条件判断语句。reduce`sum`之类的属于作弊行为，这里就不贴了。 123def Sum_Solution(self, n): # write code here return n and (n+self.Sum_Solution(n-1)) 65.不用加减乘除做加法LeetCode传送门此题由于Python中的int没有长度限制，在负数出现的情况，会导致结果与预期不同。详情见Python负数位运算 12345678910111213def getSum(self, a, b): # 32 bits integer max MAX = 0x7FFFFFFF # 2**31-1 # 32 bits interger min MIN = 0x80000000 # -2**31 # mask to get last 32 bits mask = 0xFFFFFFFF # 2*32-1 while b != 0: # ^ get different bits and &amp; gets double 1s, &lt;&lt; moves carry a, b = (a ^ b) &amp; mask, ((a &amp; b) &lt;&lt; 1) &amp; mask # if a is negative, get a's 32 bits complement positive first # then get 32-bit positive's Python complement negative return a if a &lt;= MAX else ~(a ^ mask) 或者可以将其转成32位整数。 1234567import numpy as npclass Solution(object): def getSum(self, a, b): while b != 0: a, b = np.int32(a ^ b), np.int32((a &amp; b) &lt;&lt; 1) return int(a) 66 构建乘积数组牛客网传送门AcWing传送门思路：不能使用除法。如书中所说，以i为分割点，将B拆成C，D两部分，左边是A[0] x A[1] x...x A[i-1]右边则为A[i+1] x ...x A[n-1] ，C[i] = C[i-1] * A[i-1] 使用accumulate，牛客网居然不能AC，老是说我语法错误或数组越界？AcWing是可以的。我在自己的testcase中使用随机生成的方式验证了是可以的。 123456789def multiply(self, A): from itertools import accumulate from operator import mul C = [1] # 第一个元素相当于没有 C += accumulate(A[:-1], mul) # `+=`支持右边生成器，`+`不支持 D = [1] D += accumulate(A[:0:-1], mul) D.reverse() return [C[i] * D[i] for i in range(len(A))] 不使用标准库的方法。 123456789def multiply(self, A): C = [1] # 第一个元素相当于没有 for i in range(len(A)-1): C.append(C[-1] * A[i]) D = [1] for j in range(len(A)-1, 0, -1): D.append(D[-1] * A[j]) D.reverse() return [C[i] * D[i] for i in range(len(A))]]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithm</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python排序算法]]></title>
    <url>%2FPython%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[快速排序 快排算是应用中广泛的排序算法了。由于实现简单，适用于不同的输入数据且在一般应用中比其他排序算法要快。快排的一个特点是原地排序，内循环比大多数排序算法要短小。它的主要缺点是非常脆弱，在实现中要非常小心才能避免低劣的性能。 快排是一种分治的排序算法。它将一个数组分成两个子数组，将两部分独立地排序。快排和归并排序是互补的：归并排序将数组分成两个子数组分别排序，并将有序的子数组归并以将整个数组排序，递归调用发生在处理整个数组之前；而快排将数组排序的方式则是当两个子数组都有序时整个数组自然也就有序了，递归调用发生在处理整个数组之后。 按照《算法第4版》中的例子，实现一个标准的python解法。 1234567891011121314151617181920212223242526import randomdef quick_sort(a): random.shuffle(a) # 消除输入依赖，保持随机性，也可使用随机选取切分元素 quick_sort_divide(a, 0, len(a)-1) def quick_sort_divide(a, lo, hi): if hi &lt;= lo: return j = partition(a, lo, hi) quick_sort_divide(a, lo, j-1) quick_sort_divide(a, j+1, hi) def partition(a, lo, hi): i, j = lo+1, hi pivot = a[lo] # 选取第一个元素作为切分元素 while True: while a[i]&lt;pivot and i&lt;hi: # 遇到大于等于pivot时停止，某些情况可以避免算法运行时间变为平方级别 i += 1 while a[j]&gt;pivot and j&gt;lo: j -= 1 if i &gt;= j: break a[i], a[j] = a[j], a[i] a[lo], a[j] = a[j], a[lo] return j 性能分析： 内循环使用一个递增的索引将数组元素和一个定值比较，相对于归并和希尔的在内循环中移动数据的方法更快，更简洁。 比较的次数很少。排序效率依赖切分数组的效果。 冒泡排序12345678910def bubble_sort(nums): n = len(nums) for i in range(n-1, 0, -1): flag = True for j in range(0, i): if nums[j] &gt; nums[j+1]: nums[j+1], nums[j] = nums[j], nums[j+1] flag = False if flag: return 选择排序12345678def select_sort(nums: list) -&gt; list: n = len(nums) for i in range(n-1): min_i = i for j in range(i+1, n): if nums[min_i] &gt; nums[j]: min_i = j nums[min_i], nums[i] = nums[i], nums[min_i] 插入排序 12345678910def insertion(ary: list) -&gt; list: for i in range(1, len(ary)): val, index = ary[i], i for j in range(i-1, -1, -1): if ary[j] &gt; val: ary[j+1] = ary[j] index = j else: break ary[index] = val 希尔排序一直觉得网上的希尔排序方式不够pythonic，这里写了一个调用插入排序的方法。 123456789def shell_sorted(nums): res = list(nums) n = len(res) step = round(n/2) while step &gt; 0: for i in range(step): res[i:n:step] = insert_sorted(res[i:n:step]) step = round(step/2) return res 归并排序 123456789101112131415161718def merge_sort(ary): if len(ary) &lt;= 1 : return ary num = len(ary) // 2 left = merge_sort(ary[:num]) right = merge_sort(ary[num:]) return merge(left, right) def merge(left, right): res, l, r = [], 0, 0 while l&lt;len(left) and r&lt;len(right) : if left[l] &lt; right[r]: res.append(left[l]) l += 1 else: res.append(right[r]) r += 1 res += left[l:] or right[r:] return res]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithm</tag>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode算法题整理（设计篇）Design]]></title>
    <url>%2FLeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E8%AE%BE%E8%AE%A1%E7%AF%87%EF%BC%89Design%2F</url>
    <content type="text"><![CDATA[155. Min Stack设计一个栈，要求在常数时间复杂度取出最小值。原题 12345678MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin(); --&gt; Returns -3.minStack.pop();minStack.top(); --&gt; Returns 0.minStack.getMin(); --&gt; Returns -2. 12345678910111213141516171819202122232425class MinStack: def __init__(self): self._stack = [] def push(self, x: int) -&gt; None: cur_min = self.getMin() if x &lt; cur_min: cur_min = x self._stack.append((x, cur_min)) def pop(self) -&gt; None: self._stack.pop() def top(self) -&gt; int: if not self._stack: return None else: return self._stack[-1][0] def getMin(self) -&gt; int: if not self._stack: return float('inf') else: return self._stack[-1][1] 232. Implement Queue using Stacks使用两个栈实现一个队列。原题1234567MyQueue queue = new MyQueue();queue.push(1);queue.push(2); queue.peek(); // returns 1queue.pop(); // returns 1queue.empty(); // returns false 方法一：push-O(1), pop-O(N). 1234567891011121314151617181920212223class MyQueue: def __init__(self): self.in_stack, self.out_stack = [], [] def push(self, x: int) -&gt; None: self.in_stack.append(x) def move(self) -&gt; None: if self.out_stack == []: while self.in_stack: self.out_stack.append(self.in_stack.pop()) def pop(self) -&gt; int: self.move() return self.out_stack.pop() def peek(self) -&gt; int: self.move() return self.out_stack[-1] def empty(self) -&gt; bool: return self.in_stack==self.out_stack==[] 方法二：push-O(N), pop-O(1). 123456789101112131415161718192021class MyQueue: def __init__(self): self.s1 = [] self.s2 = [] def push(self, x: int) -&gt; None: while self.s1: self.s2.append(self.s1.pop()) self.s1.append(x) while self.s2: self.s1.append(self.s2.pop()) def pop(self) -&gt; int: return self.s1.pop() def peek(self) -&gt; int: return self.s1[-1] def empty(self) -&gt; bool: return self.s1 == [] 225. Implement Stack using Queues使用队列实现栈。原题方法一：两个队列，push-O(1), pop/top O(n). 思想在于q2就是一个临时队列，无论是是top还是pop都是保持q1剩一个元素，然后再交换q1, q2. 1234567891011121314151617181920212223242526class MyStack: def __init__(self): from collections import deque self.q1, self.q2 = deque(), deque() def push(self, x: int) -&gt; None: self.q1.append(x) def pop(self) -&gt; int: while len(self.q1) != 1: self.q2.append(self.q1.popleft()) pop_val = self.q1.popleft() self.q1, self.q2 = self.q2, self.q1 return pop_val def top(self) -&gt; int: while len(self.q1) != 1: self.q2.append(self.q1.popleft()) val = self.q1[0] self.q2.append(self.q1.popleft()) self.q1, self.q2 = self.q2, self.q1 return val def empty(self) -&gt; bool: return not self.q1 方法二：两个队列，push-O(n), pop/top-O(1). 1234567891011121314151617181920class MyStack: def __init__(self): from collections import deque self.q1, self.q2 = deque(), deque() def push(self, x: int) -&gt; None: self.q2.append(x) while self.q1: self.q2.append(self.q1.popleft()) self.q1, self.q2 = self.q2, self.q1 def pop(self) -&gt; int: return self.q1.popleft() def top(self) -&gt; int: return self.q1[0] def empty(self) -&gt; bool: return not self.q1 方法三：一个队列旋转。 123456789101112131415161718192021class MyStack: def __init__(self): from collections import deque self.q = deque() def push(self, x: int) -&gt; None: self.q.append(x) # self.q.rotate(1) 这里是用了双端队列的特性 # self.q.rotate(1-len(self.q)) 这里和下面循环是一样的效果 for _ in range(len(self.q)-1): self.q.append(self.q.popleft()) def pop(self) -&gt; int: return self.q.popleft() def top(self) -&gt; int: return self.q[0] def empty(self) -&gt; bool: return not self.q 295. Find Median from Data Stream找出数据流中的中位数。原题思路：使用两个堆，最大堆存储较小的数据，最小堆存储较大的数据。添加数字时，先添加到最大堆，然后最大堆返回一个最大的数字给最小堆，最后为了平衡，可能需要最小堆还给最大堆一个最小值，以保证最大堆的长度&gt;=最小堆的长度。由于headpq是最小堆，所以使用取反实现最大堆。添加数字：Time-O(logn)，取出中位数：Time-O(1)。 1234567891011121314151617181920212223242526272829Adding number 41MaxHeap lo: [41] // MaxHeap stores the largest value at the top (index 0)MinHeap hi: [] // MinHeap stores the smallest value at the top (index 0)Median is 41=======================Adding number 35MaxHeap lo: [35]MinHeap hi: [41]Median is 38=======================Adding number 62MaxHeap lo: [41, 35]MinHeap hi: [62]Median is 41=======================Adding number 4MaxHeap lo: [35, 4]MinHeap hi: [41, 62]Median is 38=======================Adding number 97MaxHeap lo: [41, 35, 4]MinHeap hi: [62, 97]Median is 41=======================Adding number 108MaxHeap lo: [41, 35, 4]MinHeap hi: [62, 97, 108]Median is 51.5 12345678910111213141516171819import heapq as hqclass MedianFinder: def __init__(self): self.lo, self.hi = [], [] # lo is max_heap, hi is min_heap def addNum(self, num): hq.heappush(self.lo, -num) hq.heappush(self.hi, -hq.heappop(self.lo)) if len(self.lo) &lt; len(self.hi): hq.heappush(self.lo, -hq.heappop(self.hi)) def findMedian(self): if len(self.lo) == len(self.hi): return (-self.lo[0]+self.hi[0]) / 2.0 else: return float(-self.lo[0]) 535. Encode and Decode TinyURL设计一个短链接。原题1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class Codec: BASE = 62 UPPERCASE_OFFSET = 55 LOWERCASE_OFFSET = 61 DIGIT_OFFSET = 48 num_sender = 0 url = &#123;&#125; def encode(self, longUrl): """Encodes a URL to a shortened URL. :type longUrl: str :rtype: str """ if Codec.num_sender == 0: Codec.url[Codec.num_sender] = longUrl return '0' s_url = '' while Codec.num_sender &gt; 0: tail = Codec.num_sender % Codec.BASE s_url = self.parse_chr(tail) + s_url Codec.num_sender //= Codec.BASE Codec.url[Codec.num_sender] = longUrl Codec.num_sender += 1 return s_url def decode(self, shortUrl): """Decodes a shortened URL to its original URL. :type shortUrl: str :rtype: str """ num = 0 for i, char in enumerate(reversed(shortUrl)): num += self.parse_ord(char) * (Codec.BASE**i) return Codec.url[num] def parse_ord(self, char): if char.isdigit(): return ord(char) - Codec.DIGIT_OFFSET elif char.islower(): return ord(char) - Codec.LOWERCASE_OFFSET elif char.isupper(): return ord(char) - Codec.UPPERCASE_OFFSET else: raise ValueError('%s is not a valid character' % char) def parse_chr(self, integer): if integer &lt; 10: return chr(integer + DIGIT_OFFSET) elif 10 &lt;= integer &lt;= 35: return chr(integer + UPPERCASE_OFFSET) elif 36 &lt;= integer &lt; 62: return chr(integer + LOWERCASE_OFFSET) else: raise ValueError('%d is not a valid integer in the range of base %d' % (integer, Codec.BASE)) 方法二：使用字典保存。 123456789101112131415161718192021222324class Codec: BASE = 62 num_sender = 0 ALNUM = string.ascii_letters + '0123456789' d_map = &#123;c: i for i, c in enumerate(ALNUM)&#125; url = &#123;&#125; def encode(self, longUrl): pk = Codec.num_sender s_url = '' while pk &gt; 0: pk, tail = divmod(pk, Codec.BASE) s_url = Codec.ALNUM[tail] + s_url Codec.url[pk] = longUrl Codec.num_sender += 1 if pk == 0: s_url = Codec.ALNUM[0] return s_url def decode(self, shortUrl): pk = sum(Codec.d_map[c]*Codec.BASE**i for i, c in enumerate(reversed(shortUrl))) return Codec.url[pk] 707. Design Linked List设计一个链表。原题1234567MyLinkedList linkedList = new MyLinkedList();linkedList.addAtHead(1);linkedList.addAtTail(3);linkedList.addAtIndex(1, 2); // linked list becomes 1-&gt;2-&gt;3linkedList.get(1); // returns 2linkedList.deleteAtIndex(1); // now the linked list is 1-&gt;3linkedList.get(1); // returns 3 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class ListNode: def __init__(self, val): self.val = val self.next = None class MyLinkedList: def __init__(self): self.head = None self.size = 0 def get(self, index: 'int') -&gt; 'int': if index &lt; 0 or index &gt;= self.size or \ self.head is None: return -1 return self.findIndex(index).val def addAtHead(self, val: 'int') -&gt; 'None': self.addAtIndex(0, val) def addAtTail(self, val: 'int') -&gt; 'None': self.addAtIndex(self.size, val) def addAtIndex(self, index: 'int', val: 'int') -&gt; 'None': if index &gt; self.size: return -1 elif index == 0: head = ListNode(val) head.next, self.head = self.head, head else: pre = self.findIndex(index-1) cur = ListNode(val) cur.next, pre.next = pre.next, cur self.size += 1 def deleteAtIndex(self, index: 'int') -&gt; 'None': if index &lt; 0 or index &gt;= self.size: return -1 cur = self.findIndex(index-1) cur.next = cur.next.next self.size -= 1 def findIndex(self, index: 'int') -&gt; 'None': cur = self.head for _ in range(index): cur = cur.next return cur 146. LRU Cache1234567891011LRUCache cache = new LRUCache( 2 /* capacity */ );cache.put(1, 1);cache.put(2, 2);cache.get(1); // returns 1cache.put(3, 3); // evicts key 2cache.get(2); // returns -1 (not found)cache.put(4, 4); // evicts key 1cache.get(1); // returns -1 (not found)cache.get(3); // returns 3cache.get(4); // returns 4 方法一：使用OrderedDict. 开始有两个testcase没过，一个是{2: 3, 1: 1}更新2时，和{1: 1, 2: 3}更新2时，二者都可以使用先pop再更新的方式。remain的方式是从discuss学来的，之前还用len或额外的size来保存。 1234567891011121314151617181920class LRUCache: def __init__(self, capacity: 'int'): self.cache = collections.OrderedDict() self.remain = capacity def get(self, key: 'int') -&gt; 'int': if key not in self.cache: return -1 self.cache.move_to_end(key) return self.cache.get(key) def put(self, key: 'int', value: 'int') -&gt; 'None': if key not in self.cache: if self.remain &gt; 0: self.remain -= 1 else: self.cache.popitem(last=False) else: self.cache.pop(key) self.cache[key] = value 方法二：不使用OrderedDict 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class DLinkedNode: def __init__(self, key=0, value=0): self.key = key self.value = value self.next, self.prev = None, None class LRUCache: def __init__(self, capacity: int): self.cache = &#123;&#125; self.remain = capacity self.head = DLinkedNode() self.tail = DLinkedNode() self.head.next = self.tail self.tail.prev = self.head def _add_node(self, node): node.prev = self.head node.next = self.head.next self.head.next.prev = node self.head.next = node def _remove_node(self, node): node.prev.next = node.next node.next.prev = node.prev def _move_to_head(self, node): self._remove_node(node) self._add_node(node) def get(self, key: int) -&gt; int: node = self.cache.get(key, None) if not node: return -1 self._move_to_head(node) return node.value def put(self, key: int, value: int) -&gt; None: node = self.cache.get(key, None) if not node: if self.remain &gt; 0: self.remain -= 1 else: del self.cache[self.tail.prev.key] self._remove_node(self.tail.prev) new_node = DLinkedNode(key, value) self.cache[key] = new_node self._add_node(new_node) else: self._move_to_head(node) node.value = value]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
        <tag>Algorithm</tag>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode算法题整理（二叉树篇）Tree]]></title>
    <url>%2FLeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AF%87%EF%BC%89Tree%2F</url>
    <content type="text"><![CDATA[树的定义12345class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None 144. Binary Tree Preorder Traversal二叉树前序遍历12345678Input: [1,null,2,3] 1 \ 2 / 3Output: [1,2,3] 方法一：iteratively 123456789def preorderTraversal(self, root: 'TreeNode') -&gt; 'List[int]': ans, stack = [], root and [root] while stack: node = stack.pop() if node: ans.append(node.val) stack.append(node.right) stack.append(node.left) return ans 方法二：recursively 12345def preorder_traversal(root): if not root: return [] return [root.val] + self.preorderTraversal(root.left) + \ self.preorderTraversal(root.right) 589. N-ary Tree Preorder TraversalN-叉树的前序遍历。N叉树和二叉树有个区别，就是N叉树不需要考虑子节点知否为空，做单独的判断。原题方法一：recursively. 1234567def preorder(self, root): if not root: return [] res = [root.val] for child in root.children: res += self.preorder(child) return res 方法二：iteratively. 1234567def preorder(self, root): res, stack = [], root and [root] while stack: node = stack.pop() res.append(node.val) stack.extend(reversed(node.children)) return res 94. Binary Tree Inorder Traversal中序遍历二叉树12345678Input: [1,null,2,3] 1 \ 2 / 3Output: [1,3,2] 方法一：使用栈迭代。 12345678910def inorderTraversal(self, root: TreeNode) -&gt; List[int]: stack, ans = [], [] while stack or root: while root: stack.append(root) root = root.left root = stack.pop() ans.append(root.val) root = root.right return ans 方法二：Morris Traversal. 1234567891011121314151617181920212223def inorderTraversal(self, root: TreeNode) -&gt; List[int]: cur, ans = root, [] while cur: if not cur.left: ans.append(cur.val) cur = cur.right else: pre = cur.left # 找到当前节点左子树中最右的右节点 while pre.right and pre.right != cur: pre = pre.right if not pre.right: # 找到最右的节点，连接到根节点 pre.right = cur cur = cur.left # 恢复节点 else: pre.right = None ans.append(cur.val) cur = cur.right return ans 145. Binary Tree Postorder Traversal后序遍历二叉树12345678Input: [1,null,2,3] 1 \ 2 / 3Output: [3,2,1] 方法一：根右左，再倒序。 123456789def postorder_traversal(root): res, stack = [], [root] while stack: node = stack.pop() if node: res.append(node.val) stack.append(node.left) stack.append(node.right) return res[::-1] 方法二：思想: 使用last作为判断是否该节点的右子树完成遍历，如果一个node.right已经刚刚遍历完毕，那么将last==node.right，否则将会寻找node.right。 123456789101112131415def postorderTraversal(self, root): res, stack, node, last = [], [], root, None while stack or node: if node: stack.append(node) node = node.left else: node = stack[-1] if not node.right or last == node.right: node = stack.pop() res.append(node.val) last, node = node, None else: node = node.right return res 方法三：使用boolean判断一个节点是否被遍历过 123456789101112def postorderTraversal(self, root): res, stack = [], [(root, False)] while stack: node, visited = stack.pop() if node: if visited: res.append(node.val) else: stack.append((node, True)) stack.append((node.right, False)) stack.append((node.left, False)) return res 方法四：dfs. 123456789101112def postorderTraversal(self, root: 'TreeNode') -&gt; 'List[int]': ans = [] def dfs(node): if not node: return dfs(node.left) dfs(node.right) ans.append(node.val) dfs(root) return ans 590. N-ary Tree Postorder TraversalN-叉树的后序遍历。原题方法一：recursively. 1234def postorder(self, root): if not root: return [] return sum([self.postorder(child) for child in root.children], []) + [root.val] 方法二：iteratively and reversed. 1234567def postorder(self, root): res, stack = [], root and [root] while stack: node = stack.pop() res.append(node.val) stack.extend(node.children) return res[::-1] 方法三：iteratively and flag. 12345678910def postorder(self, root): res, stack = [], root and [(root, False)] while stack: node, visited = stack.pop() if visited: res.append(node.val) else: stack.append((node, True)) stack.extend((n, False) for n in reversed(node.children)) return res 100. Same Tree判断相同的二叉树。原题1234567Input: 1 1 / \ / \ 2 3 2 3 [1,2,3], [1,2,3]Output: true 方法一：recursively 123456def isSameTree(self, p: 'TreeNode', q: 'TreeNode') -&gt; 'bool': if p and q: return (p.val==q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)) else: return p is q 方法二：recursively, tuple 1234def is_same_tree(p, q): def t(n): return n and (n.val, t(n.left), t(n.right)) return t(p) == t(q) 方法三：iteratively. 12345678910111213def isSameTree(self, p: 'TreeNode', q: 'TreeNode') -&gt; 'bool': stack = [(p, q)] while stack: p1, p2 = stack.pop() if not p1 and not p2: continue if not p1 or not p2: return False if p1.val != p2.val: return False stack.append((p1.left, p2.left)) stack.append((p1.right, p2.right)) return True 101. Symmetric Tree判断二叉树是否对称。原题12345 1 / \ 2 2 / \ / \3 4 4 3 方法一：recursively. 123456789101112def isSymmetric(self, root: 'TreeNode') -&gt; 'bool': def symmetric(p1, p2): if p1 and p2: return (p1.val == p2.val and symmetric(p1.left, p2.right) and symmetric(p1.right, p2.left)) else: return p1 is p2 if not root: return True return symmetric(root.left, root.right) 方法二：iteratively. 12345678910def isSymmetric(self, root: 'TreeNode') -&gt; 'bool': stack = root and [(root.left, root.right)] while stack: p1, p2 = stack.pop() if not p1 and not p2: continue if not p1 or not p2: return False if p1.val != p2.val: return False stack.append((p1.left, p2.right)) stack.append((p1.right, p2.left)) return True 104. Maximum Depth of Binary Tree二叉树最大深度。原题123456 3 / \ 9 20 / \ 15 7return 3 方法一：recursively 1234def max_depth(root): if not root: return 0 return max(max_depth(root.left), max_depth(root.right)) + 1 方法二：iteratively. BFS with deque 12345678910def maxDepth(self, root: 'TreeNode') -&gt; 'int': q = root and collections.deque([(root, 1)]) d = 0 while q: node, d = q.popleft() if node.right: q.append((node.right, d+1)) if node.left: q.append((node.left, d+1)) return d 可以参考102分层遍历写法，最后求长度。 559. Maximum Depth of N-ary TreeN-叉树的最大深度。原题方法一：BFS with deque.同上题一样。 12345678def maxDepth(self, root: 'Node') -&gt; 'int': q = root and collections.deque([(root, 1)]) d = 0 while q: node, d = q.popleft() for child in node.children: q.append((child, d + 1)) return d 方法二：BFS. 12345def maxDepth(self, root): q, level = root and [root], 0 while q: q, level = [child for node in q for child in node.children], level+1 return level 方法三：recursively. 1234def maxDepth(self, root: 'Node') -&gt; 'int': if not root: return 0 return max(list(map(self.maxDepth, root.children)) or [0]) + 1 111. Minimum Depth of Binary Tree求根节点到叶子节点的最小深度。原题方法一：recursively 1234567def minDepth(self, root): if not root: return 0 if root.left and root.right: return min(self.minDepth(root.left), self.minDepth(root.right)) + 1 else: return self.minDepth(root.left) + self.minDepth(root.right) + 1 方法二：对上述方法修改，更加Pythonic. 注意一点，Python3中要加list,否则max因为空值报错。 1234def minDepth(self, root: 'TreeNode') -&gt; 'int': if not root: return 0 d = list(map(self.minDepth, (root.left, root.right))) return 1 + (min(d) or max(d)) 方法三：迭代法，BFS 123456789101112def minDepth(self, root: 'TreeNode') -&gt; 'int': q = root and collections.deque([(root, 1)]) d = 0 while q: node, d = q.popleft() if not node.left and not node.right: return d if node.left: q.append((node.left, d+1)) if node.right: q.append((node.right, d+1)) return d 105. Construct Binary Tree from Preorder and Inorder Traversal根据前序遍历和中序遍历重建二叉树。原题12preorder = [3,9,20,15,7]inorder = [9,3,15,20,7] 方法一：切片。 123456789def buildTree(preorder, inorder): if preorder == []: return None root_val = preorder[0] root = TreeNode(root_val) cut = inorder.index(root_val) root.left = buildTree(preorder[1:cut+1], inorder[:cut]) root.right = buildTree(preorder[cut+1:], inorder[cut+1:]) return root 方法二：上述方法在极端情况下，如只有左子树的情况，由于index会将时间复杂度上升到O(n²)，而且切片产生了一些不必要的内存。这个方法是setefan大神的方法，pop和reverse是为了增加效率。 1234567891011def buildTree(self, preorder: 'List[int]', inorder: 'List[int]') -&gt; 'TreeNode': def build(stop): if inorder and inorder[-1] != stop: root = TreeNode(preorder.pop()) root.left = build(root.val) inorder.pop() root.right = build(stop) return root preorder.reverse() inorder.reverse() return build(None) 572. Subtree of Another Tree判断是否是树的子结构。原题思路：这道题是遍历加判断相同树的结合。这里采用前序遍历和递归判断相同树。 123456789101112131415161718def isSubtree(self, s: 'TreeNode', t: 'TreeNode') -&gt; 'bool': def is_same(s, t): if s and t: return (s.val==t.val and is_same(s.left, t.left) and is_same(s.right, t.right)) else: return s is t stack = s and [s] while stack: node = stack.pop() if node: if is_same(node, t): return True stack.append(node.right) stack.append(node.left) return False 102. Binary Tree Level Order Traversal分层遍历二叉树。原题注意：循环条件要加上root，以防止root is None 123456def levelOrder(self, root: 'TreeNode') -&gt; 'List[List[int]]': ans, level = [], root and [root] while level: ans.append([n.val for n in level]) level = [k for n in level for k in (n.left, n.right) if k] return ans 103. Binary Tree Zigzag Level Order Traversal之字形打印二叉树。原题1234567def zigzagLevelOrder(self, root: 'TreeNode') -&gt; 'List[List[int]]': ans, level, order = [], root and [root], 1 while level: ans.append([n.val for n in level][::order]) order *= -1 level = [kid for n in level for kid in (n.left, n.right) if kid] return ans 107. Binary Tree Level Order Traversal II和102题不同的是，从下到上分层打印。原题方法一：将结果倒序输出。 123456def levelOrderBottom(self, root): res, level = [], [root] while root and level: res.append([n.val for n in level]) level = [kid for n in level for kid in (n.left, n.right) if kid] return res[::-1] 方法二：也可以从前面插入元素。 123456def levelOrderBottom(self, root): res, level = [], [root] while root and level: res.insert(0, [n.val for n in level]) level = [kid for n in level for kid in (n.left, n.right) if kid] return res 429. N-ary Tree Level Order Traversal分层打印N叉树。原题123456def levelOrder(self, root: 'Node') -&gt; 'List[List[int]]': ans, level = [], root and [root] while level: ans.append([n.val for n in level]) level = [k for n in level for k in n.children if k] return ans 637. Average of Levels in Binary Tree遍历一个二叉树，求每层节点的平均值，按照节点不为空的个数。原题123456789Input: 3 / \ 9 20 / \ 15 7Output: [3, 14.5, 11]Explanation:The average value of nodes on level 0 is 3, on level 1 is 14.5, and on level 2 is 11. Hence return [3, 14.5, 11]. 123456def averageOfLevels(self, root: 'TreeNode') -&gt; 'List[float]': ans, level = [], root and [root] while level: ans.append(sum(n.val for n in level) / len(level)) level = [k for n in level for k in (n.left, n.right) if k] return ans 515. Find Largest Value in Each Tree Row找到树每层的最大值。原题方法一：BFS. 此解法秒。 123456def largestValues(self, root: TreeNode) -&gt; List[int]: ans, levels = [], root and [root] while levels: ans.append(max(x.val for x in levels)) levels = [k for n in levels for k in (n.left, n.right) if k] return ans 987. Vertical Order Traversal of a Binary Tree垂直遍历二叉树，从左到右，从上到下，如果节点具有相同位置，按照值从小到大。原题 12345Input: [1,2,3,4,5,6,7]Output: [[4],[2],[1,5,6],[3],[7]]Explanation: The node with value 5 and the node with value 6 have the same position according to the given scheme.However, in the report &quot;[1,5,6]&quot;, the node value of 5 comes first since 5 is smaller than 6. 方法一：dfs. 通过建立一个字典数组，将对应的节点使用深度优先遍历初始化数组。然后按照x, y, val三个优先级进行排序。 12345678910111213141516171819def verticalTraversal(self, root: 'TreeNode') -&gt; 'List[List[int]]': seen = collections.defaultdict( lambda: collections.defaultdict(list) ) def dfs(node, x=0, y=0): if node: seen[x][y].append(node.val) dfs(node.left, x-1, y+1) dfs(node.right, x+1, y+1) dfs(root) ans = [] for x in sorted(seen): inner = [] for y in sorted(seen[x]): inner.extend(sorted(n for n in seen[x][y])) ans.append(inner) return ans 257. Binary Tree Paths打印二叉树从根节点到叶子节点全部路径。原题1234567891011Input: 1 / \2 3 \ 5Output: [&quot;1-&gt;2-&gt;5&quot;, &quot;1-&gt;3&quot;]Explanation: All root-to-leaf paths are: 1-&gt;2-&gt;5, 1-&gt;3 iteratively。思路：采用前序遍历二叉树，使用tuple保存节点当前路径，如果是叶子节点，则添加到结果中。开始老是想着用&#39;-&gt;&#39;.join()，这样反而麻烦，直接使用字符串保存就好。 1234567891011def binaryTreePaths(self, root: 'TreeNode') -&gt; 'List[str]': ans, stack = [], root and [(root, str(root.val))] while stack: n, p = stack.pop() if not n.left and not n.right: ans.append(p) if n.right: stack.append((n.right, p+'-&gt;'+str(n.right.val))) if n.left: stack.append((n.left, p+'-&gt;'+str(n.left.val))) return ans 方法二：dfs. 123456789101112def binaryTreePaths(self, root: 'TreeNode') -&gt; 'List[str]': ans = [] def dfs(n, path): if n: path.append(str(n.val)) if not n.left and not n.right: ans.append('-&gt;'.join(path)) dfs(n.left, path) dfs(n.right, path) path.pop() dfs(root, []) return ans recursively。参考了StefanPochmann大神的方法。最开始想到一半，中间那层循环想到了，但没想到用递归。 123456def binaryTreePaths(self, root): if not root: return [] return [str(root.val) + '-&gt;' + path for kid in (root.left, root.right) if kid for path in self.binaryTreePaths(kid)] or [str(root.val)] 988. Smallest String Starting From Leaf求字典顺序最小的路径，路径指叶子节点到根节点的路径。0对应a，1对应b。原题12Input: [0,1,2,3,4,3,4]Output: &quot;dba&quot; 方法一：先列出所有根到叶子的路径，再reverse求最小值。 12345678910111213def smallestFromLeaf(self, root: 'TreeNode') -&gt; 'str': OFFSET = ord('a') stack = root and [(root, chr(root.val+OFFSET))] ans = '~' while stack: n, p = stack.pop() if not n.left and not n.right: ans = min(ans, p[::-1]) if n.right: stack.append((n.right, p+chr(n.right.val+OFFSET))) if n.left: stack.append((n.left, p+chr(n.left.val+OFFSET))) return ans 方法二：dfs. 递归计算完左右节点，然后再将根节点pop掉。 1234567891011121314def smallestFromLeaf(self, root: 'TreeNode') -&gt; 'str': self.ans = '~' def dfs(node, A): if node: A.append(chr(node.val + ord('a'))) if not node.left and not node.right: self.ans = min(self.ans, ''.join(reversed(A))) dfs(node.left, A) dfs(node.right, A) A.pop() dfs(root, []) return self.ans 112. Path Sum判断是否具有从根节点到叶子节点上的值和为sum。原题方法一：recursively 123456789def hasPathSum(self, root: 'TreeNode', total: 'int') -&gt; 'bool': if not root: return False elif (not root.left and not root.right and root.val==total): return True else: return (self.hasPathSum(root.left, total-root.val) or self.hasPathSum(root.right, total-root.val)) 方法二：iteratively 1234567891011def hasPathSum(self, root: 'TreeNode', total: 'int') -&gt; 'bool': stack = root and [(root, total)] while stack: n, t = stack.pop() if not n.left and not n.right and n.val==t: return True if n.right: stack.append((n.right, t-n.val)) if n.left: stack.append((n.left, t-n.val)) return False 113. Path Sum II上题的升级版，要求二维数组返回所有路径。原题123456789sum = 22 5 / \ 4 8 / / \ 11 13 4 / \ / \7 2 5 1 1234[ [5,4,11,2], [5,8,4,5]] 方法一：iteratively. 举一反三。 123456789101112def pathSum(self, root: 'TreeNode', total: 'int') -&gt; 'List[List[int]]': stack = root and [(root, [root.val], total)] ans = [] while stack: n, v, t = stack.pop() if not n.left and not n.right and n.val==t: ans.append(v) if n.right: stack.append((n.right, v+[n.right.val], t-n.val)) if n.left: stack.append((n.left, v+[n.left.val], t-n.val)) return ans recursively. 先找出所有路径，再过滤，实际上和257题一样。不过这并没有把这道题的特性涵盖进去。 12345678910def pathSum(self, root, sum_val): paths = self.all_paths(root) return [path for path in paths if sum(path)==sum_val] def all_paths(self, root): if not root: return [] return [[root.val]+path for kid in (root.left, root.right) if kid for path in self.all_paths(kid)] or [[root.val]] 方法三：recursively. 123456789def pathSum(self, root, sum): if not root: return [] val, *kids = root.val, root.left, root.right if any(kids): return [[val] + path for kid in kids if kid for path in self.pathSum(kid, sum-val)] return [[val]] if val==sum else [] 297. Serialize and Deserialize Binary Tree序列化反序列化二叉树。原题1234567891011121314151617181920class Codec: def serialize(self, root): if not root: return '$' return (str(root.val) + ',' + self.serialize(root.left) + ',' + self.serialize(root.right)) def deserialize(self, data): nodes = data.split(',')[::-1] return self.deserialize_tree(nodes) def deserialize_tree(self, nodes): val = nodes.pop() if val == '$': return None root = TreeNode(val) root.left = self.deserialize_tree(nodes) root.right = self.deserialize_tree(nodes) return root 110. Balanced Binary Tree判断是否是平衡二叉树。原题方法一：递归+递归。 12345678910def isBalanced(self, root): if not root: return True return self.isBalanced(root.left) and self.isBalanced(root.right) and \ abs(self.max_depth(root.left)-self.max_depth(root.right)) &lt;= 1 def max_depth(self, root): if not root: return 0 return max(self.max_depth(root.left), self.max_depth(root.right)) + 1 方法二：上诉两种方法中都包含了一些无意义的重复遍历。这里采用后序遍历，边遍历边判断，不会重复节点。受此思想启发，添加一种后序遍历二叉树的方法。 12345678910111213141516171819def isBalanced(self, root): stack, node = [], root last, depths = None, collections.defaultdict(int) while stack or node: if node: stack.append(node) node = node.left else: node = stack[-1] if not node.right or last == node.right: node = stack.pop() left, right = depths[node.left], depths[node.right] if abs(left - right) &gt; 1: return False depths[node] = 1 + max(left, right) last, node = node, None else: node = node.right return True 方法三：dfs. 算深度的时候判断左右是否深度超过1. 这里变量不能把self去掉，否则[1,2,2,3,3,null,null,4,4]会错误的返回True而不是False。 1234567891011121314def isBalanced(self, root: 'TreeNode') -&gt; 'bool': self.balanced = True def dfs(node): if not node: return 0 left = dfs(node.left) right = dfs(node.right) if not self.balanced or abs(left - right) &gt; 1: self.balanced = False return max(left, right) + 1 dfs(root) return self.balanced 108. Convert Sorted Array to Binary Search Tree将有序数组转换成二叉搜索树。原题12345678Given the sorted array: [-10,-3,0,5,9],One possible answer is: [0,-3,9,-10,null,5], 0 / \ -3 9 / / -10 5 方法一：答案不唯一，居然一次就通过了。递归的思想还是简单一些的。 12345678def sortedArrayToBST(self, nums): if not nums: return None mid = len(nums) // 2 root = TreeNode(nums[mid]) root.left = self.sortedArrayToBST(nums[:mid]) root.right = self.sortedArrayToBST(nums[mid+1:]) return root 方法二：不使用切片。 123456789101112def sortedArrayToBST(self, nums: 'List[int]') -&gt; 'TreeNode': def convert(lo, hi): if lo &gt; hi: return None mid = (lo+hi) // 2 root = TreeNode(nums[mid]) root.left = convert(lo, mid-1) root.right = convert(mid+1, hi) return root return convert(0, len(nums)-1) 235. Lowest Common Ancestor of a Binary Search Tree寻找二叉搜索树的最小公共祖先。原题方法一：iteratively. 1234def lowestCommonAncestor(self, root, p, q): while (root.val-p.val) * (root.val-q.val) &gt; 0: root = (root.left, root.right)[root.val &lt; p.val] return root 方法二：recursively. 12345def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -&gt; 'TreeNode': if (root.val-p.val) * (root.val-q.val) &lt;= 0: return root return self.lowestCommonAncestor( (root.left, root.right)[root.val &lt; p.val], p, q) 404. Sum of Left Leaves求一个二叉树所有左叶子节点的和。原题方法一：iteratively.这里使用了tuple记录是否为左叶子节点。 12345678910def sumOfLeftLeaves(self, root: 'TreeNode') -&gt; 'int': ans, stack = 0, root and [(root, False)] while stack: n, isleft = stack.pop() if n: if not n.left and not n.right and isleft: ans += n.val stack.append((n.right, False)) stack.append((n.left, True)) return ans 方法二：recursively. 12345678def sumOfLeftLeaves(self, root: 'TreeNode') -&gt; 'int': if not root: return 0 if (root.left and not root.left.left and not root.left.right): return root.left.val + self.sumOfLeftLeaves(root.right) else: return (self.sumOfLeftLeaves(root.left) + self.sumOfLeftLeaves(root.right)) 938. Range Sum of BST给两个节点的值，求二叉搜索树在这两个值之间的节点和。每个节点的值唯一。原题1234Input: root = [10,5,15,3,7,null,18], L = 7, R = 15Output: 32Input: root = [10,5,15,3,7,13,18,1,null,6], L = 6, R = 10Output: 23 方法一：因为是竞赛题，所以没追求效率，所以这里先前序遍历了一下，再根据条件求和。 1234567891011def rangeSumBST(self, root, L, R): traverse, stack = [], [root] while stack: node = stack.pop() if node: traverse.append(node.val) if node.right: stack.append(node.right) if node.left: stack.append(node.left) return sum([x for x in traverse if L &lt;= x &lt;= R]) 方法二：利用二叉搜索树的特性。 1234567891011def rangeSumBST(self, root: 'TreeNode', L: 'int', R: 'int') -&gt; 'int': ans, stack = 0, root and [root] while stack: node = stack.pop() if node.val &gt; L and node.left: stack.append(node.left) if node.val &lt; R and node.right: stack.append(node.right) if L &lt;= node.val &lt;= R: ans += node.val return ans 530. Minimum Absolute Difference in BST求二叉搜索树任意两个节点的最小差。原题12345678910111213Input: 1 \ 3 / 2Output:1Explanation:The minimum absolute difference is 1, which is the difference between 2 and 1 (or between 2 and 3). 12345678910def getMinimumDifference(self, root: 'TreeNode') -&gt; 'int': def inorder(n): if not n: return [] return inorder(n.left) + [n.val] + inorder(n.right) nums = inorder(root) # return min(nums[i+1]-nums[i] for i in range(len(nums)-1)) return min(b-a for a, b in zip(nums, nums[1:])) 783. Minimum Distance Between BST Nodes二叉搜索树两个节点的最小值。和530是一道题。原题1234567891011121314Input: root = [4,2,6,1,3,null,null]Output: 1Explanation:Note that root is a TreeNode object, not an array.The given tree [4,2,6,1,3,null,null] is represented by the following diagram: 4 / \ 2 6 / \ 1 3 while the minimum difference in this tree is 1, it occurs between node 1 and node 2, also between node 3 and node 2. 方法一：递归 + 生成器， 遍历了两次。 123456789def minDiffInBST(self, root: 'TreeNode') -&gt; 'int': def inorder(node): if not node: return [] return inorder(node.left) + [node.val] + inorder(node.right) t = inorder(root) return min(t[x]-t[x-1] for x in range(1, len(t))) 方法二：一次遍历，没有保存整个遍历数组，效率高。 12345678910def minDiffInBST(self, root: TreeNode) -&gt; int: ans, last, stack = float('inf'), float('-inf'), [] while stack or root: while root: stack.append(root) root = root.left root = stack.pop() ans, last = min(ans, root.val-last), root.val root = root.right return ans 方法三：一次递归。 123456789101112class Solution: pre = float('-inf') ans = float('inf') def minDiffInBST(self, root: 'TreeNode') -&gt; 'int': if root.left: self.minDiffInBST(root.left) self.ans = min(self.ans, root.val-self.pre) self.pre = root.val if root.right: self.minDiffInBST(root.right) return self.ans 538. Convert BST to Greater Tree二叉搜索树转换。使得节点的值等于所有比它大的节点的和。原题123456789Input: The root of a Binary Search Tree like this: 5 / \ 2 13Output: The root of a Greater Tree like this: 18 / \ 20 13 方法一：recursively。这里使用了一个变量来保存当前的累加和，然后递归中采用先右后左的方式。 123456789101112def convertBST(self, root: 'TreeNode') -&gt; 'TreeNode': self.sum_val = 0 def convert(node): if node: convert(node.right) self.sum_val += node.val node.val = self.sum_val convert(node.left) convert(root) return root 方法二：iteratively。94题中的中序遍历迭代方式不能实现，因为迭代时改变了根节点。 1234567891011121314def convertBST(self, root): stack = [(root, False)] sum_val = 0 while stack: node, visited = stack.pop() if node: if visited: node.val += sum_val sum_val = node.val else: stack.append((node.left, False)) stack.append((node, True)) stack.append((node.right, False)) return root 958. Check Completeness of a Binary Tree判断二叉树是否是完整二叉树。完整二叉树为：除了最后一层所有节点不能为空，最后一层节点全部去靠左。原题Example 1: 123Input: [1,2,3,4,5,6]Output: trueExplanation: Every level before the last is full (ie. levels with node-values &#123;1&#125; and &#123;2, 3&#125;), and all nodes in the last level (&#123;4, 5, 6&#125;) are as far left as possible. Example 2: 123Input: [1,2,3,4,5,null,7]Output: falseExplanation: The node with value 7 isn&apos;t as far left as possible. 方法一：采用分层遍历的方式，判断每层的节点是否是2**level。最后一层采用切片的方式判断最左原则。 123456789101112131415161718192021class Solution: def isCompleteTree(self, root): if not root: return True levels = [root] last_full = True level = 0 while levels: value_nodes = [n for n in levels if n] if value_nodes != levels[:len(value_nodes)]: return False else: print(len(levels), 2**level) if len(levels) != 2**level: if not last_full: return False last_full = False levels = [kid for n in levels if n for kid in (n.left, n.right)] level += 1 return True 方法二：Lee神的写法，想明白一件事就是，遇见第一个None时，后面如果再有非None的值就不是玩整树了。 1234567def isCompleteTree(self, root: 'TreeNode') -&gt; 'bool': i, bfs = 0, [root] while bfs[i]: bfs.append(bfs[i].left) bfs.append(bfs[i].right) i += 1 return not any(bfs[i:]) 543. Diameter of Binary Tree求二叉树的最大直径，即任意两节点的长度。原题123456 1 / \ 2 3 / \ 4 5 Return **3**, which is the length of the path [4,2,1,3] or [5,2,1,3]. 方法一： recursively, 使用一个实例变量计算了最大值。 12345678910111213def diameterOfBinaryTree(self, root: 'TreeNode') -&gt; 'int': self.diameter = 0 def dfs(node): if not node: return 0 left = dfs(node.left) right = dfs(node.right) self.diameter = max(self.diameter, left+right) return max(left, right) + 1 dfs(root) return self.diameter 965. Univalued Binary Tree判断一个二叉树是否所有节点具有相同的值。原题方法一：recursively。 12345def isUnivalTree(self, root: 'TreeNode') -&gt; 'bool': def dfs(node): return (not node or root.val==node.val and dfs(node.left) and dfs(node.right)) return dfs(root) 方法二：iteratively.常规写法。 12345678910def isUnivalTree(self, root: 'TreeNode') -&gt; 'bool': r_val, stack = root.val, [root] while stack: n = stack.pop() if n: if n.val != r_val: return False stack.append(n.right) stack.append(n.left) return True 方法二：前序遍历，生成器方法。 1234567891011121314def isUnivalTree(self, root: 'TreeNode') -&gt; 'bool': def bfs(node): if node: yield node.val yield from bfs(node.left) yield from bfs(node.right) it = bfs(root) root_val = next(it) for val in it: if val != root_val: return False return True 563. Binary Tree Tilt返回一个二叉树整个树的倾斜度。所有节点倾斜度的总和。节点的倾斜度等于左子树和右子树所有和差的绝对值。原题12345678910Input: 1 / \ 2 3Output: 1Explanation: Tilt of node 2 : 0Tilt of node 3 : 0Tilt of node 1 : |2-3| = 1Tilt of binary tree : 0 + 0 + 1 = 1 方法一：recursively. 这里用tuple记录了节点总和和倾斜度总和。 12345678910111213def findTilt(self, root): self.res = 0 _, top_res = self.sum_and_diff(root) return self.res + top_resdef sum_and_diff(self, node): if not node: return 0, 0 l_sum, l_diff = self.sum_and_diff(node.left) r_sum, r_diff = self.sum_and_diff(node.right) self.res += l_diff + r_diff # print(node.val, node.val+l_sum+r_sum, abs(l_sum-r_sum)) return node.val+l_sum+r_sum, abs(l_sum-r_sum) 方法二: 想了一会后序遍历的迭代法，没想出来，貌似需要维护很多的变量。这里还是优化一下方法一。 1234567891011def findTilt(self, root: 'TreeNode') -&gt; 'int': def dfs(node): if not node: return 0, 0 l_sum, l_diff = dfs(node.left) r_sum, r_diff = dfs(node.right) return (node.val + l_sum + r_sum, abs(l_sum-r_sum) + l_diff + r_diff) return dfs(root)[1] 606. Construct String from Binary Tree根据二叉树重建字符串，使用()表示嵌套关系。原题123456789101112131415Input: Binary tree: [1,2,3,4] 1 / \ 2 3 / 4 Output: &quot;1(2(4))(3)&quot;Input: Binary tree: [1,2,3,null,4] 1 / \ 2 3 \ 4 Output: &quot;1(2()(4))(3)&quot; 方法一：recursively. 左右节点有一点区别，在于如果左节点为空，右节点不为空，要保留左节点的括号。 12345def tree2str(self, t): if not t: return '' left = '(&#123;&#125;)'.format(self.tree2str(t.left)) if (t.left or t.right) else '' right = '(&#123;&#125;)'.format(self.tree2str(t.right)) if t.right else '' return '&#123;&#125;&#123;&#125;&#123;&#125;'.format(t.val, left, right) 617. Merge Two Binary Trees合并两个二叉树，相同位置的节点值相加，空节点算0.原题方法一：recursively. 虽然这个方法AC了，但是感觉有点问题，返回的TreeNode中某个子节点可能包含原来的t1或t2的引用。 123456789def mergeTrees(self, t1, t2): if not t1: return t2 if not t2: return t1 t = TreeNode(t1.val+t2.val) t.left = self.mergeTrees(t1.left, t2.left) t.right = self.mergeTrees(t1.right, t2.right) return t 方法二：iteratively. 12345678910111213141516def mergeTrees(self, t1, t2): if not t1 and not t2: return [] t = TreeNode(0) stack = [(t, t1, t2)] while stack: n, n1, n2 = stack.pop() if n1 or n2: n.val = (n1.val if n1 else 0) + (n2.val if n2 else 0) if (n1 and n1.right) or (n2 and n2.right): n.right = TreeNode(None) stack.append((n.right, n1.right if n1 else None, n2.right if n2 else None)) if (n1 and n1.left) or (n2 and n2.left): n.left = TreeNode(None) stack.append((n.left, n1.left if n1 else None, n2.left if n2 else None)) return t 653. Two Sum IV - Input is a BST判断二叉树中是否有两个节点相加为k。原题12345678910Input: 5 / \ 3 6 / \ \2 4 7Target = 9Output: True 方法一：preorder + set. 1234567891011def findTarget(self, root, k): seen, stack = set(), root and [root] while stack: node = stack.pop() if node: if k-node.val in seen: return True seen.add(node.val) stack.append(node.right) stack.append(node.left) return False 669. Trim a Binary Search Tree根据范围修剪二叉搜索树，注意是二叉搜索树，不是普通的二叉树。原题123456789101112Input: 1 / \ 0 2 L = 1 R = 2Output: 1 \ 2 方法一：recursively. 12345678910111213def trimBST(self, root, L, R): def trim_node(node): if not node: return None elif node.val &gt; R: return trim_node(node.left) elif node.val &lt; L: return trim_node(node.right) else: node.left = trim_node(node.left) node.right = trim_node(node.right) return node return trim_node(root) 671. Second Minimum Node In a Binary Tree找出二叉树中第二小的节点值。左右子节点同时存在或同时不存在，根节点小于等于任意子节点。原题123456789Input: 2 / \ 2 5 / \ 5 7Output: 5Explanation: The smallest value is 2, the second smallest value is 5. 方法一：先放到set里. 123456789101112131415def findSecondMinimumValue(self, root: 'TreeNode') -&gt; 'int': self.uniques = set() def dfs(node): if node: self.uniques.add(node.val) dfs(node.left) dfs(node.right) dfs(root) min1, ans = root.val, float('inf') for v in self.uniques: if min1 &lt; v &lt; ans: ans = v return ans if ans &lt; float('inf') else -1 方法二： iteratively. 1234567891011def findSecondMinimumValue(self, root): min1 = root.val if root else -1 res = float('inf') stack = root and [root] while stack: node = stack.pop() if node: if min1 &lt; node.val &lt; res: res = node.val stack.extend([node.right, node.left]) return res if res &lt; float('inf') else -1 方法三：还没想出来，以上两种都没有利用到一些题中已知条件，我看Solution中给出的及一些Discuss中的答案也忽略了这个条件。想了想无论是哪个顺序遍历，或者深度广度优先，都没能很好的利用这个条件。 687. Longest Univalue Path相同节点最长路径，路径长度按照两个节点之间的边距，也就是节点数-1。原题123456 5 / \ 4 5 / \ \ 1 1 5output: 2 123456789101112def longestUnivaluePath(self, root): self.res = 0 def traverse(node): if not node: return 0 left_len, right_len = traverse(node.left), traverse(node.right) left = (left_len+1) if node.left and node.left.val==node.val else 0 right = (right_len+1) if node.right and node.right.val==node.val else 0 self.res = max(self.res, left + right) return max(left, right) traverse(root) return self.res 700. Search in a Binary Search Tree在二叉搜索树中搜索节点。原题12345678Given the tree: 4 / \ 2 7 / \ 1 3And the value to search: 2 方法一：recursively. 123456def searchBST(self, root: 'TreeNode', val: 'int') -&gt; 'TreeNode': if root: if val == root.val: return root return self.searchBST( (root.left, root.right)[root.val &lt; val], val) 方法二：iteratively. 12345def searchBST(self, root: 'TreeNode', val: 'int') -&gt; 'TreeNode': node = root while node and node.val != val: node = (node.left, node.right)[node.val &lt; val] return node 872. Leaf-Similar Trees叶子相近的树，只从左到右遍历叶子节点的顺序相同的两棵树。原题方法一：前序遍历+生成器。空间复杂度过高，beats 1%。 12345678910111213141516def leafSimilar(self, root1: 'TreeNode', root2: 'TreeNode') -&gt; 'bool': def leaves(root): stack = root and [root] while stack: node = stack.pop() if node: if not node.right and not node.left: yield node.val stack.append(node.right) stack.append(node.left) leaves1 = leaves(root1) leaves2 = leaves(root2) return all( a==b for a, b in itertools.zip_longest(leaves1, leaves2)) 方法二：dfs. 1234567891011def leafSimilar(self, root1: 'TreeNode', root2: 'TreeNode') -&gt; 'bool': def dfs(node): if node: if not node.left and not node.right: yield node.val yield from dfs(node.left) yield from dfs(node.right) return all( a==b for a, b in itertools.zip_longest(dfs(root1), dfs(root2))) 897. Increasing Order Search Tree根据中序遍历建立一个只有右子树的二叉树。要求在原树上修改。原题1234567891011121314151617181920Example 1:Input: [5,3,6,2,4,null,8,1,null,null,null,7,9] 5 / \ 3 6 / \ \ 2 4 8 / / \ 1 7 9Output: [1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9] 1 \ 2 \ 3 \ 4 方法一：iteratively. 1234567891011def increasingBST(self, root: TreeNode) -&gt; TreeNode: ans = head = TreeNode(0) stack = [] while stack or root: while root: stack.append(root) root = root.left root = stack.pop() head.right = TreeNode(root.val) root, head = root.right, head.right return ans.right 方法二：生成器。 12345678910111213def increasingBST(self, root: 'TreeNode') -&gt; 'TreeNode': def inorder(node): if node: yield from inorder(node.left) yield node.val yield from inorder(node.right) ans = head = TreeNode(0) for v in inorder(root): head.right = TreeNode(v) head = head.right return ans.right 方法三：题中有个要求在原树上修改，所以以上两种方法其实不符合要求，这里使用递归实现。 此答案由lee大神提供，非常巧妙。 123456def increasingBST(self, root: 'TreeNode', tail=None) -&gt; 'TreeNode': if not root: return tail res = self.increasingBST(root.left, root) root.left = None root.right = self.increasingBST(root.right, tail) return res 993. Cousins in Binary Tree表弟节点指两个节点在同一深度，并且父节点不同。判断两个节点是否是表弟节点。树中节点值唯一。原题方法一：用dict记录。 123456789101112def isCousins(self, root: 'TreeNode', x: 'int', y: 'int') -&gt; 'bool': parent, depth = &#123;&#125;, &#123;&#125; def dfs(node, par=None): if node: parent[node.val] = par depth[node.val] = depth[par] + 1 if par else 0 dfs(node.left, node.val) dfs(node.right, node.val) dfs(root) return depth[x] == depth[y] and parent[x] != parent[y] 230. Kth Smallest Element in a BST二叉搜索树的第K小节点值。原题1234567Input: root = [3,1,4,null,2], k = 1 3 / \ 1 4 \ 2Output: 1 方法一：生成器前序遍历。 12345678910111213def kthSmallest(self, root: TreeNode, k: int) -&gt; int: def inorder(node): if node: yield from inorder(node.left) yield node.val yield from inorder(node.right) for n in inorder(root): if k == 1: return n else: k -= 1 方法二：迭代。 1234567891011def kthSmallest(self, root: TreeNode, k: int) -&gt; int: stack = [] while root or stack: while root: stack.append(root) root = root.left root = stack.pop() k -= 1 if k == 0: return root.val root = root.right 98. Validate Binary Search Tree验证一个树是否是二叉搜索树。原题12345678 5 / \ 1 4 / \ 3 6Output: falseExplanation: The input is: [5,1,4,null,null,3,6]. The root node&apos;s value is 5 but its right child&apos;s value is 4. 方法一：中序遍历即可。 123456789101112def isValidBST(self, root: TreeNode) -&gt; bool: stack, last = [], float('-inf') while stack or root: while root: stack.append(root) root = root.left root = stack.pop() if root.val &lt;= last: return False last = root.val root = root.right return True 109. Convert Sorted List to Binary Search Tree将有序链表转成平衡二叉搜索树。原题123456789Given the sorted linked list: [-10,-3,0,5,9],One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST: 0 / \ -3 9 / / -10 5 方法一：先遍历链表，再二分递归创建树。 1234567891011121314151617def sortedListToBST(self, head: ListNode) -&gt; TreeNode: inorder = [] while head: inorder.append(head.val) head = head.next lo, hi = 0, len(inorder)-1 def build_tree(lo, hi): if lo &gt; hi: return None mid = (lo + hi) // 2 root = TreeNode(inorder[mid]) root.left = build_tree(lo, mid-1) root.right = build_tree(mid+1, hi) return root return build_tree(lo, hi) 方法二：这个方法很棒。先遍历一遍找到链表的长度；然后递归去构建树，共享一个head可变对象。 123456789101112131415161718192021222324def sortedListToBST(self, head: ListNode) -&gt; TreeNode: def find_size(head): h, count = head, 0 while h: h = h.next count += 1 return count lo, hi = 0, find_size(head) def form_bst(lo, hi): nonlocal head if lo &gt; hi: return None mid = (lo + hi) // 2 left = form_bst(lo, mid-1) root = TreeNode(head.val) head = head.next root.left = left right = form_bst(mid+1, hi) root.right = right return root return form_bst(lo, hi-1) 1008. Construct Binary Search Tree from Preorder Traversal根据前序遍历重建二叉搜索树。原题12Input: [8,5,1,7,10,12]Output: [8,5,10,1,7,null,12] 方法一：recursively. 1234567def bstFromPreorder(self, preorder: List[int]) -&gt; TreeNode: if not preorder: return None root = TreeNode(preorder[0]) i = bisect.bisect(preorder, root.val) root.left = self.bstFromPreorder(preorder[1:i]) root.right = self.bstFromPreorder(preorder[i:]) return root 236. Lowest Common Ancestor of a Binary Tree二叉树两个节点的最小公共祖先。原题方法一: 递归，是用mid表示当前节点是否是其中的一个。 1234567891011121314def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -&gt; 'TreeNode': self.ans = None def dfs(node): if not node: return False left = dfs(node.left) right = dfs(node.right) mid = node in (p, q) if mid + left + right &gt;= 2: self.ans = node return mid or left or right dfs(root) return self.ans 方法二：递归，思想如果是两个节点中的一个，就返回这个节点。 123456def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -&gt; 'TreeNode': if root in (None, p, q): return root left = self.lowestCommonAncestor(root.left, p, q) right = self.lowestCommonAncestor(root.right, p, q) return root if left and right else left or right 方法三：参考了257的dfs解法。需要注意的是一定要加list(path)，否则由于可变对象的问题，会导致最后结果为[]。 1234567891011121314def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -&gt; 'TreeNode': ans = [] def dfs(n, path): if n: path.append(n) if n in (p, q): ans.append(list(path)) # must use list, or you will get [] if len(ans) == 2: # optimized return dfs(n.left, path) dfs(n.right, path) path.pop() dfs(root, []) return next(a for a, b in list(zip(*ans))[::-1] if a==b) 654. Maximum Binary Tree根据数组建立一个树，要求根节点为数组最大的树。原题方法一：此题秒，不过感觉还有更优解，查了一圈没找到。 123456789def constructMaximumBinaryTree(self, nums: List[int]) -&gt; TreeNode: if not nums: return None v = max(nums) root = TreeNode(v) i = nums.index(v) root.left = self.constructMaximumBinaryTree(nums[:i]) root.right = self.constructMaximumBinaryTree(nums[i+1:]) return root 513. Find Bottom Left Tree Value寻找二叉树最底层的最左节点。原题方法一：根据分层遍历改编。 123456def findBottomLeftValue(self, root: TreeNode) -&gt; int: ans, levels = None, root and [root] while levels: ans = levels[0].val levels = [k for n in levels for k in (n.left, n.right) if k] return ans 方法二：双端队列，BFS. 123456789def findBottomLeftValue(self, root: TreeNode) -&gt; int: q = collections.deque([root]) while q: node = q.pop() if node.right: q.appendleft(node.right) if node.left: q.appendleft(node.left) return node.val 方法三：循环时改变迭代对象，这种方式个人觉得不好。不过好在是在遍历之前添加到末端。 12345def findBottomLeftValue(self, root: TreeNode) -&gt; int: queue = [root] for node in queue: queue += (x for x in (node.right, node.left) if x) return node.val 814. Binary Tree Pruning剪掉树中不包含1的子树。原题方法一：递归。 123456789101112131415def pruneTree(self, root: TreeNode) -&gt; TreeNode: def dfs(node): if not node: return True left = dfs(node.left) right = dfs(node.right) if left: node.left = None if right: node.right = None return node.val==0 and left and right dfs(root) return root 199. Binary Tree Right Side View二叉树从右向左看时，从上到下的节点。原题方法一：和分层遍历思想相同。 123456def rightSideView(self, root: TreeNode) -&gt; List[int]: ans, levels = [], root and [root] while levels: ans.append(levels[-1].val) levels = [k for n in levels for k in (n.left, n.right) if k] return ans 方法二：dfs. 从右到左深度遍历，用一个深度变量控制是否是第一个最右节点。 12345678910def rightSideView(self, root: TreeNode) -&gt; List[int]: ans = [] def dfs(n, depth): if n: if depth == len(ans): ans.append(n.val) dfs(n.right, depth+1) dfs(n.left, depth+1) dfs(root, 0) return ans 662. Maximum Width of Binary Tree二叉树的最大宽度。原题方法一：常规队列写法。需要注意的是，每层遍历要用最右边的减去最左边的才是宽度。 123456789101112def widthOfBinaryTree(self, root: TreeNode) -&gt; int: queue = [(root, 0, 0)] ans = cur_depth = left = 0 for node, depth, pos in queue: if node: queue.append((node.left, depth+1, pos*2)) queue.append((node.right, depth+1, pos*2+1)) if cur_depth != depth: cur_depth = depth left = pos ans = max(pos-left+1, ans) return ans 方法二：按照分层顺序将所有节点编号，从1开始，enumerate其实就是计算2*pos, 2*pos+1。 12345678910def widthOfBinaryTree(self, root: TreeNode) -&gt; int: levels = [(1, root)] width = 0 while levels: width = max(levels[-1][0] - levels[0][0] + 1, width) levels = [k for pos, n in levels for k in enumerate((n.left, n.right), 2 * pos) if k[1]] return width 222. Count Complete Tree Nodes统计完整树的节点个数。原题方法一：二分法。比较左子树的深度和右子树的深度，如果相同则表明左子树为满树，右子树为完整树。如果不同则表明左子树为完整树，右子树为满树。 12345678910111213def countNodes(self, root: TreeNode) -&gt; int: if not root: return 0 left, right = self.depth(root.left), self.depth(root.right) if left == right: return 2 ** left + self.countNodes(root.right) else: return 2 ** right + self.countNodes(root.left) def depth(self, node): if not node: return 0 return 1 + self.depth(node.left)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
        <tag>Algorithm</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode算法题整理（动态规划篇）Danymic Programming]]></title>
    <url>%2FLeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AF%87%EF%BC%89Danymic-Programming%2F</url>
    <content type="text"><![CDATA[70. Climbing Stairs爬楼梯，一次可以爬一阶或两阶楼梯，爬上n阶楼梯有多少种方法？原题 斐波那契问题 12345def fibonacci(n): a = b = 1 for _ in range(n-1): a, b = b, a+b return b 746. Min Cost Climbing Stairs楼梯上每层写了到达该层的卡路里，求上到顶层消耗的最小卡路里。原题1234567Input: cost = [10, 15, 20]Output: 15Explanation: Cheapest is start on cost[1], pay that cost and go to the top.Input: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]Output: 6Explanation: Cheapest is start on cost[0], and only step on 1s, skipping cost[3]. 方法一：the final cost f[i] to climb the staircase from some step iis f[i] = cost[i] + min(f[i+1], f[i+2])。到达一层有两种选择，一种是上一层，一种是上两层。 12345def minCostClimbingStairs(self, cost: List[int]) -&gt; int: f1 = f2 = 0 for x in reversed(cost): f1, f2 = min(f1, f2) + x, f1 return min(f1, f2) 121. Best Time to Buy and Sell Stock买入卖出最大收益。原题1234Input: [7,1,5,3,6,4]Output: 5Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5. Not 7-1 = 6, as selling price needs to be larger than buying price. 方法一：Brute Force.其实就是求最高峰点和前面最低谷点的差。 12345678def maxProfit(self, prices: List[int]) -&gt; int: ans, min_buy = 0, float('inf') for price in prices: if price &lt; min_buy: min_buy = price elif price-min_buy &gt; ans: ans = price - min_buy return ans 方法二：标准的卡登算法。此题为53.连续数组最大和的变形，如果价格比之前小，则舍弃，否则一起计算连续子数组的和。 1234567def maxProfit(self, prices: List[int]) -&gt; int: cur = sofar = 0 for i in range(1, len(prices)): cur += prices[i] - prices[i-1] cur = max(0, cur) sofar = max(cur, sofar) return sofar 122. Best Time to Buy and Sell Stock II买入卖出，允许多次交易。原题1234Input: [7,1,5,3,6,4]Output: 7Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4. Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3. 思路：比较每两天的价格，如果是涨价了，那就把收益计算进去，否则不出手交易。 123456def max_profit(prices): profit = 0 for i in range(1, len(prices)): if prices[i] &gt; prices[i-1]: profit += prices[i] - prices[i-1] return profit 方法二：pairwise. 12345678def maxProfit(self, prices: List[int]) -&gt; int: t, y = itertools.tee(prices) next(t, None) profit = 0 for p1, p2 in zip(t, y): if p1 &gt; p2: profit += p1-p2 return profit Best Time to Buy and Sell Stock III最多允许交易两次。原题先从左到右按照一次交易计算每天的利润。然后按照从右到左，判断如果进行第二次交易，最大的利润。 1234567891011121314151617def maxProfit(self, prices: List[int]) -&gt; int: min_buy = float('inf') profits = [] max_profit = 0 for p in prices: min_buy = min(min_buy, p) max_profit = max(max_profit, p-min_buy) profits.append(max_profit) max_profit = 0 total_profit = 0 max_sell = float('-inf') for i in range(len(prices)-1, -1, -1): max_sell = max(max_sell, prices[i]) max_profit = max(max_profit, max_sell-prices[i]) total_profit = max(total_profit, max_profit+profits[i]) return total_profit 198. House Robber抢劫房子问题。不能连续抢劫两个挨着的房间。原题1234Input: [2,7,9,3,1]Output: 12Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1). Total amount you can rob = 2 + 9 + 1 = 12. 123f(0) = nums[0]f(1) = max(num[0], num[1])f(k) = max( f(k-2) + nums[k], f(k-1) ) 方法一：递归，超时。 1234567def rob(self, nums): if not nums: return 0 if len(nums) &lt;= 1: return nums[0] return max(nums[0]+self.rob(nums[2:]), self.rob(nums[1:])) 方法二： 12345def rob(self, nums): last, now = 0, 0 for num in nums: last, now = now, max(last+num, now) return now 213. House Robber II与上题不同的是，所有的房子连成一个环。原题1234nput: [2,3,2]Output: 3Explanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses. 方法一：注意nums长度为1的情况。 12345678def rob(self, nums: List[int]) -&gt; int: def robber(nums): last = now = 0 for num in nums: last, now = now, max(last+num, now) return now return max(robber(nums[:-1]), robber(nums[len(nums)!=1:])) 303. Range Sum Query - Immutable给定一个数组，计算索引i, j之间的和。原题12345Given nums = [-2, 0, 3, -5, 2, -1]sumRange(0, 2) -&gt; 1sumRange(2, 5) -&gt; -1sumRange(0, 5) -&gt; -3 思路：如果单纯采用切片计算，效率过低，题中要求sumRange调用多次。所以这里采用动态规划。 12345678910111213class NumArray: def __init__(self, nums): # self.sum_item = [0] # for num in nums: # self.sum_item.append(self.sum_item[-1] + num) from itertools import accumulate from operator import add self.sum_item = list(accumulate(nums, add)) def sumRange(self, i, j): # return self.sum_item[j+1] - self.sum_item[i] return self.sum_item[j] - self.sum_item[i-1] if i &gt; 0 else self.sum_item[j] 91. Decode Ways将数字翻译成字母有多少种方式。原题123Input: &quot;226&quot;Output: 3Explanation: It could be decoded as &quot;BZ&quot; (2 26), &quot;VF&quot; (22 6), or &quot;BBF&quot; (2 2 6). 123456789def numDecodings(self, s: str) -&gt; int: # w tells the number of ways # v tells the previous number of ways # d is the current digit # p is the previous digit v, w, p = 0, int(s&gt;''), '' for d in s: v, w, p = w, int(d&gt;'0')*w + (9&lt;int(p+d)&lt;27)*v, d return w 62. Unique Paths一个矩阵中，从左上走到右下有多少种不同走法，每次只能向右或向下移动。原题 方法一：构建二维矩阵。 12345678910def uniquePaths(self, m: int, n: int) -&gt; int: g = [[0] * m for _ in range(n)] for i in range(n): for j in range(m): if i==0 or j==0: g[i][j] = 1 else: g[i][j] = g[i-1][j] + g[i][j-1] return g[-1][-1] 方法二：二维数组时没有必要的，仔细观察发现每层都是累计的关系，accumulate为此而生。 123[1, 1, 1, 1, 1, 1, 1][1, 2, 3, 4, 5, 6, 7][1, 3, 6, 10, 15, 21, 28] 12345def uniquePaths(self, m: int, n: int) -&gt; int: row = [1] * m for _ in range(n-1): row = itertools.accumulate(row) return list(row)[-1] 63. Unique Paths II和62一样，不同的是中间加了障碍1。原题1234567Input:[ [0,0,0], [0,1,0], [0,0,0]]Output: 2 方法一：首次AC的方法，这里采用先遍历一次记录障碍，然后初始化首行和首列，最后再求解的过程。 123456789101112131415161718192021222324252627282930def uniquePathsWithObstacles(self, g: List[List[int]]) -&gt; int: R, C = len(g), len(g[0]) for i in range(R): for j in range(C): if g[i][j] == 1: g[i][j] = -1 for i in range(R): if g[i][0] != -1: g[i][0] = 1 else: break for j in range(C): if g[0][j] != -1: g[0][j] = 1 else: break for i in range(1, R): for j in range(1, C): if g[i][j] == -1: continue else: up = g[i-1][j] if g[i-1][j]!=-1 else 0 left = g[i][j-1] if g[i][j-1]!=-1 else 0 g[i][j] = up + left # print(g) return g[-1][-1] if g[-1][-1] != -1 else 0 方法二：想错了一件事情，我根本不需要去单独的设置障碍值，在遍历的时候就可以根据0来判断。 123456789101112131415161718def uniquePathsWithObstacles(self, g: List[List[int]]) -&gt; int: R, C = len(g), len(g[0]) if g[0][0] == 1: return 0 g[0][0] = 1 for i in range(1, C): g[0][i] = int(g[0][i-1]==1 and g[0][i]==0) for j in range(1, R): g[j][0] = int(g[j-1][0]==1 and g[j][0]==0) for i in range(1, R): for j in range(1, C): if g[i][j] == 0: g[i][j] = g[i-1][j] + g[i][j-1] else: g[i][j] = 0 return g[-1][-1] 120. Triangle三角形从上到下最小路径。原题1234567[ [2], [3,4], [6,5,7], [4,1,8,3]]i.e., 2 + 3 + 5 + 1 = 11 方法一：我这里使用了一个嵌套的字典保存每一行的累计最小值。 12345678910def minimumTotal(self, t: List[List[int]]) -&gt; int: if not t: return 0 from collections import defaultdict dp = defaultdict(lambda: defaultdict(lambda: float('inf'))) dp[0][0] = t[0][0] for i, row in enumerate(t[1:], 1): for j, num in enumerate(row): dp[i][j] = min(dp[i-1][j-1], dp[i-1][j]) + t[i][j] return min(dp[len(t)-1].values()) 方法二：在原数组上修改，空间复杂度O(1). 1234567891011121314def minimumTotal(self, t: List[List[int]]) -&gt; int: if not t: return 0 for i, row in enumerate(t[1:], 1): for j, num in enumerate(row): # if j == 0: # t[i][j] = t[i-1][j] + t[i][j] # elif j == len(row)-1: # t[i][j] = t[i-1][j-1] + t[i][j] # else: # t[i][j] = min(t[i-1][j-1], t[i-1][j]) + t[i][j] path = slice(max(0, j-1), min(len(t[i-1]), j+1)) t[i][j] += min(t[i-1][path]) return min(t[-1]) 方法三：错位相加大法。 1234567def minimumTotal(self, triangle: List[List[int]]) -&gt; int: from functools import reduce def combine_rows(lower_row, upper_row): return [upper + min(lower_left, lower_right) for upper, lower_left, lower_right in zip(upper_row, lower_row, lower_row[1:])] return reduce(combine_rows, triangle[::-1])[0] 931. Minimum Falling Path Sum和120相似，不过形状变成了矩形。原题1234Input: [[1,2,3],[4,5,6],[7,8,9]]Output: 12Explanation: The possible falling paths are: 方法一：常规写法。 1234567def minFallingPathSum(self, A: List[List[int]]) -&gt; int: R, C = len(A), len(A[0]) for i in range(R-2, -1, -1): for j in range(C): path = slice(max(0, j-1), min(C, j+2)) A[i][j] += min(A[i+1][path]) return min(A[0]) 方法二：错位计算的方式，这个比120三角形的要复杂一点。需要填充无穷大来使生效。 12345678def minFallingPathSum(self, A: List[List[int]]) -&gt; int: from functools import reduce padding = [float('inf')] def combine_rows(lower_row, upper_row): return [upper + min(lower_left, lower_mid, lower_right) for upper, lower_left, lower_mid, lower_right in zip(upper_row, lower_row[1:]+padding, lower_row, padding+lower_row[:-1])] return min(reduce(combine_rows, A[::-1])) 279. Perfect Squares完美平方，找出n的最少的能被几个平方数相加。原题123Input: n = 13Output: 2Explanation: 13 = 4 + 9. f(n)表示n最少的个数。f(n)=min(f(n-1²), f(n-2²)...f(0)) + 1 12345678class Solution: _dp = [0] def numSquares(self, n: int) -&gt; int: dp = self._dp while len(dp) &lt;= n: # dp.append(min(dp[len(dp)-i*i] for i in range(1, int(len(dp)**0.5+1))) + 1) dp.append(min(dp[-i*i] for i in range(1, int(len(dp)**0.5+1))) + 1) return dp[n] 5. Longest Palindromic Substring最长回文子字符串。原题123Input: &quot;babad&quot;Output: &quot;bab&quot;Note: &quot;aba&quot; is also a valid answer. 方法一：O(n²)的方法。非常低效的一个做法。 123456789101112131415161718def longestPalindrome(self, s: str) -&gt; str: def helper(i, j): while i &gt;=0 and j &lt; len(s) and s[i]==s[j]: i -= 1 j += 1 return s[i+1:j] # 因为i, j是不相等的。 # ans = '' # for i, c in enumerate(s): # tmp = helper(i, i) # if len(tmp) &gt; len(ans): # ans = tmp # tmp = helper(i, i+1) # if len(tmp) &gt; len(ans): # ans = tmp # return ans return s and max((a for i in range(len(s)) for a in (helper(i, i), helper(i, i+1))), key=len) or '' 方法二：这个方法很好。从前到后遍历字符，一种是奇数长度的回文串，是增加两个长度，另一种是偶数长度的回文串，是增加一个长度。每次从当前字符向前做切片，并根据当前的最大长度控制切片长度。 12345678910111213141516def longestPalindrome(self, s: str) -&gt; str: if not s: return '' maxLen = 1 start = 0 for i in range(len(s)): if i-maxLen&gt;=1 and s[i-maxLen-1:i+1]==s[i-maxLen-1:i+1][::-1]: start = i - maxLen - 1 maxLen += 2 continue if i-maxLen&gt;=0 and s[i-maxLen:i+1]==s[i-maxLen:i+1][::-1]: # print(s[i-maxLen:i+1], s[i-maxLen:i+1][::-1]) start = i - maxLen maxLen += 1 return s[start:start+maxLen] 方法三：马拉车算法。Time: O(n). 算法详解。这里是把一些情况做了整合。整个代码非常优雅。 12345678910111213141516171819202122def longestPalindrome(self, s: str) -&gt; str: # Transform S into T. # For example, S = "abba", T = "^#a#b#b#a#$". # ^ and $ signs are sentinels appended to each end to avoid bounds checking T = '#'.join('^&#123;&#125;$'.format(s)) n = len(T) P = [0] * n C = R = 0 for i in range (1, n-1): P[i] = (R &gt; i) and min(R - i, P[2*C - i]) # equals to i' = C - (i-C) # Attempt to expand palindrome centered at i while T[i + 1 + P[i]] == T[i - 1 - P[i]]: P[i] += 1 # If palindrome centered at i expand past R, # adjust center based on expanded palindrome. if i + P[i] &gt; R: C, R = i, i + P[i] # Find the maximum element in P. maxLen, centerIndex = max((n, i) for i, n in enumerate(P)) return s[(centerIndex - maxLen)//2: (centerIndex + maxLen)//2]]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
        <tag>Algorithm</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode算法题整理（字符串篇）String]]></title>
    <url>%2FLeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AF%87%EF%BC%89String%2F</url>
    <content type="text"><![CDATA[14. Longest Common Prefix返回最长公共前缀字符串。原题 12Input: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]Output: &quot;fl&quot; 123456def longest_common_prefix(strs): if not strs: return '' from itertools import takewhile max_pre_len = len(list(takewhile(lambda x: len(set(x))==1, zip(*strs)))) return strs[0][:max_pre_len] 20. Valid Parentheses判断括号是否成对出现，并且嵌套正确。原题 1234Input: &quot;()[]&#123;&#125;&quot;Output: trueInput: &quot;&#123;[]&#125;&quot;Output: true 12345678910111213def is_valid(s): pairs = &#123;')': '(', '&#125;': '&#123;', ']': '['&#125; stack = [] for paren in s: if paren in pairs.values(): stack.append(paren) elif paren in pairs.keys(): if stack == [] or stack.pop() != pairs[paren]: return False else: return False return stack == [] 921. Minimum Add to Make Parentheses Valid给定一个只包含小括号的字符串。返回需要多少个”(“或”)”使其成为完整的括号表达式。原题12345678Input: &quot;())&quot;Output: 1Input: &quot;()))((&quot;Output: 4Input: &quot;()&quot;Output: 0Input: &quot;(((&quot;Output: 3 方法一：平衡问题。 12345678def minAddToMakeValid(self, S: str) -&gt; int: ans = bal = 0 for symbol in S: bal += 1 if symbol=='(' else -1 if bal == -1: ans += 1 bal += 1 return ans + bal 28. Implement strStr()实现index。原题12Input: haystack = &quot;hello&quot;, needle = &quot;ll&quot;Output: 2 12345678def str_index(haystack, needle): h = len(haystack) n = len(needle) for i in range(h-n+1): if haystack[i:i+n] == needle: return i else: return -1 38. Count and Say原题123451. 12. 113. 214. 12115. 111221 123456def countAndSay(self, n: int) -&gt; str: ans = '1' for _ in range(n-1): ans = ''.join(str(len(list(c)))+d for d, c in itertools.groupby(ans)) return ans 443. String Compression字符串压缩，实际是要将重复的字符串以个数来表示。要求O(1)空间复杂度，就地修改原数组。原题思路：看上去和38题差不多，但是有些不同，不同的地方在于如果个数为1，则不显示。个数为两位数，要显示两个元素。 123456Input = [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;,&quot;b&quot;,&quot;c&quot;,&quot;c&quot;,&quot;c&quot;]Output = [&quot;a&quot;,&quot;2&quot;,&quot;b&quot;,&quot;2&quot;,&quot;c&quot;,&quot;3&quot;]Input = [&quot;a&quot;]Output = [&quot;a&quot;]Input = [&quot;a&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;]Output = [&quot;a&quot;,&quot;b&quot;,&quot;1&quot;,&quot;2&quot;] 123456789101112def compress(self, chars: List[str]) -&gt; int: anchor, write = 0, 0 # anchor为每组连续的第一个位置。 for r, char in enumerate(chars): if r == len(chars)-1 or char != chars[r+1]: chars[write] = chars[anchor] write += 1 if r &gt; anchor: for digit in str(r - anchor + 1): chars[write] = digit write += 1 anchor = r + 1 return write 125. Valid Palindrome验证回文字符串，只判断字母数字，忽略大小写。原题12Input: &quot;A man, a plan, a canal: Panama&quot;Output: true 方法一：切片 123def is_palindrome(s): s_alnum = filter(str.isalnum, s.lower()) return s_alnum == s_alnum[::-1] 方法二：双指针 1234567def is_palindrome(s): s_alnum = list(filter(str.isalnum, s.lower())) mid = len(s_alnum) // 2 for i in range(mid): if s_alnum[i] != s_alnum[-i-1]: return False return True 680. Valid Palindrome II验证是否是回文数，只包含小写字母，但是允许最多去掉一个字母之后是回文数。原题123Input: &quot;abca&quot;Output: TrueExplanation: You could delete the character &apos;c&apos;. 方法一：一开始想的方法。切片由于可能i=0，所以必须反序切片再倒置。 12345678910111213141516171819def validPalindrome(self, s): i, res = self.is_palindrome(s) if res: return True else: _, s1 = self.is_palindrome(s[:i]+s[i+1:]) left = slice(0, -i-1) right = slice(-1, -i-1, -1) _, s2 = self.is_palindrome(s[left]+s[right][::-1]) return s1 or s2 def is_palindrome(self, s): mid = len(s) // 2 # print(s) for i in range(mid): if s[i] != s[-i-1]: # print('&#123;&#125; [&#123;&#125;] != [&#123;&#125;]'.format(s, s[i], s[-i-1])) return i, False return None, True 方法二：双指针方法。 12345678def validPalindrome(self, s): l, r = 0, len(s)-1 while l &lt; r: if s[l] != s[r]: one, two = s[l:r], s[l+1:r+1] return one==one[::-1] or two==two[::-1] l, r = l+1, r-1 return True 方法三：贪心解法，留坑。 151. Reverse Words in a String倒置一句话中的单词。原题12Input: &quot;the sky is blue&quot;,Output: &quot;blue is sky the&quot;. 12def reverse_words(s): return ' '.join(s.split()[::-1]) 344. Reverse String倒置字符串。原题12Input: &quot;A man, a plan, a canal: Panama&quot;Output: &quot;amanaP :lanac a ,nalp a ,nam A&quot; 123456def reverse_str(s): n = len(s) res = list(s) for i in range(n//2): res[i], res[-i-1] = res[-i-1], res[i] return ''.join(res) 242. Valid Anagram验证回文构词法，即两个字符串由同样个数的字符组成。原题12Input: s = &quot;anagram&quot;, t = &quot;nagaram&quot;Output: true 方法一： sort 12def is_anagram(s, t): return sorted(s) == sorted(t) 方法二：Counter 12345def is_anagram(s, t): from collections import Counter c1 = Counter(s) c2 = Counter(t) return c1 == c2 438. Find All Anagrams in a String找出字符串中所有的回文构词。原题方法一：有个小地方注意就是，如果计数为0要删除，否则等式将不成立。 1234567891011121314def findAnagrams(self, s, p): from collections import Counter ns, np = len(s), len(p) cur_c = Counter(s[:np-1]) c_p = Counter(p) res = [] for i in range(np-1, ns): cur_c[s[i]] += 1 if cur_c == c_p: res.append(i-np+1) cur_c[s[i-np+1]] -= 1 if cur_c[s[i-np+1]] == 0: del cur_c[s[i-np+1]] return res 3. Longest Substring Without Repeating Characters最长不含重复字符的子字符串。原题方法一：暴力法，果然超时了。 1234567def lengthOfLongestSubstring(self, s): max_len, n = 0, len(s) for i in range(n): for j in range(i+1, n+1): if len(s[i:j]) == len(set(s[i:j])): max_len = max(max_len, len(s[i:j])) return max_len 方法二：找到重复值时，更新start的值，为什么使用max，因为start有可能大于dic[s[end]]+1，比如当s=&#39;abba&#39;，end走到最后的时候，上一次start因为b做了更新变为了2。 12345678910def lengthOfLongestSubstring(self, s): res, start = 0, 0 dic = &#123;&#125; for end in range(len(s)): if s[end] in dic: start = max(start, dic[s[end]]+1) # start = dic[s[end]] + 1 dic[s[end]] = end res = max(res, end-start+1) return res 也可以把max判断放到条件里。 12345678910def lengthOfLongestSubstring(self, s): res, start = 0, 0 dic = &#123;&#125; for end in range(len(s)): if s[end] in dic and start &lt;= dic[s[end]]: start = dic[s[end]] + 1 else: res = max(res, end-start+1) dic[s[end]] = end return res 387. First Unique Character in a String返回第一个不重复的字符。原题1234s = &quot;leetcode&quot;return 0.s = &quot;loveleetcode&quot;,return 2. Time-O(N), Space-O(N)。暂时没发现更快的算法了。 1234567def firstUniqChar(self, s): from collections import Counter c = Counter(s) for i, ch in enumerate(s): if c[ch] == 1: return i return -1 58. Length of Last Word输入一个字符串，通过空格分割，然后返回最后一个单词的长度，空串不算。原题123456s = &quot;Hello World&quot;return 5s = &quot;a &quot;return 1s = &quot; &quot;return 0 方法一：直观的方法。 123456def lengthOfLastWord(self, s): ss = s.split(' ') for ch in ss[::-1]: if ch: return len(ch) return 0 方法二：使用列表生成式，理论上时间复杂度比上述方法稍微高一点，不过实际时间差不多，估计是list comprehension做了优化。 123def lengthOfLastWord(self, s): ss =[x for x in s.split(' ') if x] return len(ss[-1]) if ss else 0 205. Isomorphic Strings判断两个字符串是否具有一样的形式。s和t长度一样。原题12345678Input: s = &quot;egg&quot;, t = &quot;add&quot;Output: trueInput: s = &quot;foo&quot;, t = &quot;bar&quot;Output: falseInput: s = &quot;paper&quot;, t = &quot;title&quot;Output: true 方法一：使用dict保存每个字母的位置。这里使用了OrderedDict保存了values的顺序，也可以使用sorted对values排序。最后说明一下在Python3中需要使用list格式化一下，因为values()返回一个dict_values对象，而这个对象如果直接使用==判断，会返回False，即使有相同的值，这里还不清楚内部的__eq__方法是如何实现的。而在Python2中可以直接比较。 12345678def isIsomorphic(self, s, t): from collections import OrderedDict d1, d2 = OrderedDict(), OrderedDict() for i, val in enumerate(s): d1[val] = d1.get(val, []) + [i] for i, val in enumerate(t): d2[val] = d2.get(val, []) + [i] return list(d1.values()) == list(d2.values()) 方法二：使用zip并行输出。 12&gt;&gt;&gt; list(zip('paper', 'title'))[('p', 't'), ('a', 'i'), ('p', 't'), ('e', 'l'), ('r', 'e')] 12def isIsomorphic(self, s, t): return len(set(zip(s, t))) == len(set(s)) == len(set(t)) 方法三：两个字符串每个位置的字符，第一次出现的index是否相同。 123def isIsomorphic(self, s, t): # return [s.find(i) for i in s] == [t.find(j) for j in t] return list(map(s.find, s)) == list(map(t.find, t)) 290. Word Pattern匹配字符串和空格分隔的字符串是否具有相同形式，此题和上一题相似，只不过将其中一个换成了数组。另一个区别是长度不一定相等。原题12Input: pattern = &quot;abba&quot;, str = &quot;dog cat cat dog&quot;Output: true 1234def wordPattern(self, pattern, str): s = pattern t = str.split() return list(map(s.find, s)) == list(map(t.index, t)) 12345def wordPattern(self, pattern, str): s = pattern t = str.split() return len(set(zip(s, t))) == len(set(s)) == len(set(t)) \ and len(s) == len(t) 917. Reverse Only Letters倒置一个字符串的字母。原题12345Input: &quot;ab-cd&quot;Output: &quot;dc-ba&quot;Input: &quot;a-bC-dEf-ghIj&quot;Output: &quot;j-Ih-gfE-dCba&quot; 注意：不能使用l &lt;= r作为条件，因为会打乱正确结果的排序。输出&quot;dcb-a&quot;。 123456789101112def reverseOnlyLetters(self, S): l, r = 0, len(S)-1 res = list(S) while l &lt; r: while l&lt;r and not res[l].isalpha(): l += 1 while l&lt;r and not res[r].isalpha(): r -= 1 res[l], res[r] = res[r], res[l] l += 1 r -= 1 return ''.join(res) 345.Reverse Vowels of a String倒置一个字符串中的元音字母。原题1234Example 2:Input: &quot;leetcode&quot;Output: &quot;leotcede&quot; 方法一：和917题一样，换汤不换药。只需定义一个vowels={&#39;a&#39;, &#39;e&#39;, &#39;i&#39;, &#39;o&#39;, &#39;u&#39;}然后条件改成while l&lt;r and res[l].lower() not in vowels:，提交了一下beat有68%左右，应该还有更效率的方法。 方法二：改了一下，不再使用lower方法了，把大写字母加上，beat变为99.88%。 12345678910111213def reverseVowels(self, s): l, r = 0, len(s)-1 vowels = set(list('aeiouAEIOU')) res = list(s) while l &lt; r: while l&lt;r and res[l] not in vowels: l += 1 while l&lt;r and res[r] not in vowels: r -= 1 res[l], res[r] = res[r], res[l] l += 1 r -= 1 return ''.join(res) 方法三：正则 1234def reverseVowels(self, s): vowels = re.findall('(?i)[aeiou]', s) # (?i)表示忽略大小写 # repl参数每次返回一个值，用来替换s匹配pattern的字符。 return re.sub('(?i)[aeiou]', lambda m: vowels.pop(), s) 383. Ransom Note判断是否magazine可以构成ransomNote。原题123canConstruct(&quot;a&quot;, &quot;b&quot;) -&gt; falsecanConstruct(&quot;aa&quot;, &quot;ab&quot;) -&gt; falsecanConstruct(&quot;aa&quot;, &quot;aab&quot;) -&gt; true 方法一：使用count。 12345def canConstruct(self, ransomNote, magazine): for item in set(ransomNote): if magazine.count(item) &lt; ransomNote.count(item): return False return True 方法二：one-liner. 123def canConstruct(self, ransomNote, magazine): return all(ransomNote.count(char) &lt;= magazine.count(char) for char in set(ransomNote)) 方法三：Counter。时间复杂度比二稍高。 123def canConstruct(self, ransomNote, magazine): from collections import Counter return not Counter(ransomNote) - Counter(magazine) 925. Long Pressed Name说有这么一个破键盘，老是连键，有时候打一个字母c，出来好几个。给定一个目标字符串和打出来的字符串，判断是否是这个破键盘输出的。原题1234567Input: name = "alex", typed = "aaleex"Output: trueExplanation: 'a' and 'e' in 'alex' were long pressed.Input: name = "saeed", typed = "ssaaedd"Output: falseExplanation: 'e' must have been pressed twice, but it wasn't in the typed output. 思路：一开始还想用Counter，后来发现不对，因为它将所有的一样的字符聚合到了一起。所以此题可以使用groupby 1234567891011def isLongPressedName(self, name, typed): from itertools import groupby name_groups = [(ch, len(list(g))) for ch, g in groupby(name)] typed_groups = [(ch, len(list(g))) for ch, g in groupby(typed)] if len(typed_groups) &lt; len(name_groups): return False for i in range(len(name_groups)): if typed_groups[i][0] != name_groups[i][0] or \ typed_groups[i][1] &lt; name_groups[i][1]: return False return True 方法二：简单的写法。 12345678def isLongPressedName(self, name: str, typed: str) -&gt; bool: ngroups = itertools.groupby(name) tgroups = itertools.groupby(typed) for (nl, nc), (tl, tc) in itertools.zip_longest( ngroups, tgroups, fillvalue=('~', [])): if nl != tl or len(list(nc)) &gt;len(list(tc)): return False return True 929. Unique Email Addresses统计不同的email地址。原题123456789def numUniqueEmails(self, emails): res = set() for email in emails: local, domain = email.split('@') if '+' in local: local = local[:local.index('+')] local = local.replace('.', '') res.add((local, domain)) return len(res) 409. Longest Palindrome给你一堆字符串，返回用它组成的最长的回文串的长度，可以不使用所有的字符。原题方法一：每对一样的数字可以放在两边来组成回文。 1234567def longestPalindrome(self, s): from collections import Counter c = Counter(s) res = 0 for count in c.values(): res += count // 2 return res*2 + (len(s) &gt; res*2) 方法二：从奇数的角度考虑。 1234def longestPalindrome(self, s): from collections import Counter odds = sum(v &amp; 1 for v in Counter(s).values()) return len(s) - odds + bool(odds) # 如果有奇数，总能将其放到中间 434. Number of Segments in a String统计字符串中有多少个以空格分割的字符串。原题方法一：Time-O(n), Space-O(1) 123456def countSegments(self, s): segment_count = 0 for i in range(len(s)): if (i == 0 or s[i-1] == ' ') and s[i] != ' ': segment_count += 1 return segment_count 方法二： 12def countSegments(self, s): return len(s.split()) 500. Keyboard Row输入一个字符串数组，返回字符在键盘同一行的字符串。原题12Input: [&quot;Hello&quot;, &quot;Alaska&quot;, &quot;Dad&quot;, &quot;Peace&quot;]Output: [&quot;Alaska&quot;, &quot;Dad&quot;] 1234567891011class Solution: def findWords(self, words): self.first = &#123;'Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'I', 'O', 'P'&#125; self.second = &#123;'A', 'S', 'D', 'F', 'G', 'H', 'J', 'K', 'L'&#125; self.third = &#123;'Z', 'X', 'C', 'V', 'B', 'N', 'M'&#125; return list(filter(self.same_line, words)) def same_line(self, word): return set(word.upper()) &lt;= set(self.first) or \ set(word.upper()) &lt;= set(self.second) or \ set(word.upper()) &lt;= set(self.third) 520. Detect Capital判断一个字符串的大写是否使用正确。要么全大写，要么全小写，或者首字母大写。原题12Input: &quot;USA&quot;Output: True 方法一：太简单了，一下子就写出来了，看评论居然好多人不知道istitle。 12def detectCapitalUse(self, word): return word.islower() or word.isupper() or word.istitle() 541. Reverse String II按照2k的长度划分一个字符串，把其中每段前k个字符倒置。原题12Input: s = &quot;abcdefg&quot;, k = 2Output: &quot;bacdfeg&quot; 方法一：比较简单的一题，使用Python的切片。 12345678def reverseStr(self, s, k): letters = list(s) n = len(letters) # for i in range(n//(2*k)+1): # letters[2*k*i:k+2*k*i] = reversed(letters[2*k*i:k+2*k*i]) for i in range(0, n, 2*k): letters[i:k+i] = reversed(letters[i:k+i]) return ''.join(letters) 551. Student Attendance Record I判断一个学生是否有奖励，缺席次数小于等于一天，没有三次连续的迟到。原题12Input: &quot;PPALLP&quot;Output: True 12def checkRecord(self, s): return s.count('A')&lt;= 1 and 'LLL' not in s 557. Reverse Words in a String III倒置一句话中的每个单词。所有单词均已一个空格分隔。原题12Input: &quot;Let&apos;s take LeetCode contest&quot;Output: &quot;s&apos;teL ekat edoCteeL tsetnoc&quot; 12def reverseWords(self, s): return ' '.join([word[::-1] for word in s.split()]) 657. Robot Return to Origin机器人是否能回到原点。’UDLR’分别表示上下左右，每次移动的距离一样。原题123Input: &quot;UD&quot;Output: true Explanation: The robot moves up once, and then down once. All moves have the same magnitude, so it ended up at the origin where it started. Therefore, we return true. 方法一：就是看上下和左右的次数是否一样。此题过于简单。 123def judgeCircle(self, moves): return moves.count('L') == moves.count('R') and \ moves.count('U') == moves.count('D') 1234def judgeCircle(self, moves): from collections import Counter c = Counter(moves) return c['U'] == c['D'] and c['L'] == c['R'] 696. Count Binary Substrings二进制字符串计数，有多少个连续的子字符串，由相同的0和1组成，如’10’，’1100’。原题1234567Input: &quot;00110011&quot;Output: 6Explanation: There are 6 substrings that have equal number of consecutive 1&apos;s and 0&apos;s: &quot;0011&quot;, &quot;01&quot;, &quot;1100&quot;, &quot;10&quot;, &quot;0011&quot;, and &quot;01&quot;.Notice that some of these substrings repeat and are counted the number of times they occur.Also, &quot;00110011&quot; is not a valid substring because all the 0&apos;s (and 1&apos;s) are not grouped together. 方法一：正则要比groupby快. 12345def countBinarySubstrings(self, s): from itertools import groupby # groups = [len(list(v)) for _, v in groupby(s)] groups = list(map(len, re.findall('0+|1+', s))) return sum(min(a, b) for a, b in zip(groups, groups[1:])) 方法二：变量，常数空间复杂度。 123456789def countBinarySubstrings(self, s): res, prev, cur = 0, 0, 1 for i in range(1, len(s)): if s[i] != s[i-1]: res += min(prev, cur) prev, cur = cur, 1 else: cur += 1 return res + min(prev, cur) 709. To Lower Case实现字符串的lower方法。原题12Input: &quot;Hello&quot;Output: &quot;hello&quot; 123def toLowerCase(self, str): return ''.join(chr(ord(c)+32) if 65&lt;=ord(c)&lt;=90 else c for c in str) 771. Jewels and Stones判断S里有多少个在J里，J为不重复元素。原题12Input: J = &quot;aA&quot;, S = &quot;aAAbbbb&quot;Output: 3 方法一：使用set. 123def numJewelsInStones(self, J: 'str', S: 'str') -&gt; 'int': jewels = set(J) return sum(s in jewels for s in S) 方法二：count. count的值只会是0和1，因为J没有重复元素。由于这个特性，所以反过来也是一样。 123def numJewelsInStones(self, J: 'str', S: 'str') -&gt; 'int': # return sum(map(J.count, S)) return sum(map(S.count, J)) 784. Letter Case Permutation字母组合，给定一个字符串，其中的字母可大写可小写，返回所有可能的字符串。原题123456789Examples:Input: S = &quot;a1b2&quot;Output: [&quot;a1b2&quot;, &quot;a1B2&quot;, &quot;A1b2&quot;, &quot;A1B2&quot;]Input: S = &quot;3z4&quot;Output: [&quot;3z4&quot;, &quot;3Z4&quot;]Input: S = &quot;12345&quot;Output: [&quot;12345&quot;] 方法一：提取字母，然后format。 1234567def letterCasePermutation(self, S: 'str') -&gt; 'List[str]': letters = ''.join(x for x in S if x.isalpha()) s = re.sub(r'[A-Za-z]', '&#123;&#125;', S) ans = [''] for l in letters: ans = [pre+x for pre in ans for x in (l.lower(), l.upper())] return [s.format(*f) for f in ans] 方法二：一开始被题目误导了，以为是排列，后来想到了笛卡尔乘积，但是没想到可以这样写。 1234def letterCasePermutation(self, S: 'str') -&gt; 'List[str]': L = ((s.lower(), s.upper()) if s.isalpha() else s for s in S) # [('a', 'A'), '1', ('b', 'B'), '2'] return [''.join(c) for c in itertools.product(*L)] 788. Rotated Digits可旋转的数字，说把一个数的所有数字旋转180度，是一个正确的数字。并且和原来不同。给定一个N，返回1~N所有这样的数的个数。原题123456Example:Input: 10Output: 4Explanation: There are four good numbers in the range [1, 10] : 2, 5, 6, 9.Note that 1 and 10 are not good numbers, since they remain unchanged after rotating. 12345def rotatedDigits(self, N: 'int') -&gt; 'int': changed = &#123;'2', '5', '6', '9'&#125; valid = changed | &#123;'0', '1', '8'&#125; return sum(bool(set(str(i))&lt;=valid and set(str(i))&amp;changed) for i in range(1, N+1)) 796. Rotate String判断一个字符串A是否可以旋转成B。原题1234567Example 1:Input: A = &apos;abcde&apos;, B = &apos;cdeab&apos;Output: trueExample 2:Input: A = &apos;abcde&apos;, B = &apos;abced&apos;Output: false 方法一：Brute Force. Time: O(N²), Space: O(N²). 12345def rotateString(self, A: 'str', B: 'str') -&gt; 'bool': for k in range(len(A)): if A[-k:] + A[:-k] == B: return True return False if A else A==B 方法二：Time O(N²). Space O(N). 12def rotateString(self, A: 'str', B: 'str') -&gt; 'bool': return len(A)==len(B) and B in A*2 方法三：KMP算法。留坑。 方法四：Rolling Hash算法。留坑。 804. Unique Morse Code Words不重复的莫斯密码，给定一句话，求不重复的单词的莫斯密码个数。原题1234567891011Example:Input: words = [&quot;gin&quot;, &quot;zen&quot;, &quot;gig&quot;, &quot;msg&quot;]Output: 2Explanation: The transformation of each word is:&quot;gin&quot; -&gt; &quot;--...-.&quot;&quot;zen&quot; -&gt; &quot;--...-.&quot;&quot;gig&quot; -&gt; &quot;--...--.&quot;&quot;msg&quot; -&gt; &quot;--...--.&quot;There are 2 different transformations, &quot;--...-.&quot; and &quot;--...--.&quot;. 1234567def uniqueMorseRepresentations(self, words: 'List[str]') -&gt; 'int': codes = [".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."] # morse = dict(zip(string.ascii_lowercase, codes)) # seen = &#123;''.join(morse[c] for c in word) for word in words&#125; seen = &#123;''.join(codes[ord(c)-ord('a')] for c in word) for word in words&#125; return len(seen) 806. Number of Lines To Write String单词换行，已知每个字母的宽度，每100一换行，写不下一个字母时，换行，最一个字符串需要多少行和末尾行的宽度。原题12345678Example :Input: widths = [10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10]S = &quot;abcdefghijklmnopqrstuvwxyz&quot;Output: [3, 60]Explanation: All letters have the same length of 10. To write all 26 letters,we need two full lines and one line with 60 units. 123456789def numberOfLines(self, widths: 'List[int]', S: 'str') -&gt; 'List[int]': width = dict(zip(string.ascii_letters, widths)) lines, line = 1, 0 for s in S: if line + width[s] &gt; 100: lines += 1 line = 0 line += width[s] return lines, line 819. Most Common Word最常见的单词，从输入的段落中找到出现频率最高并且不在banned列表中的单词。原题12345678910Input: paragraph = &quot;Bob hit a ball, the hit BALL flew far after it was hit.&quot;banned = [&quot;hit&quot;]Output: &quot;ball&quot;Explanation: &quot;hit&quot; occurs 3 times, but it is a banned word.&quot;ball&quot; occurs twice (and no other word does), so it is the most frequent non-banned word in the paragraph. Note that words in the paragraph are not case sensitive,that punctuation is ignored (even if adjacent to words, such as &quot;ball,&quot;), and that &quot;hit&quot; isn&apos;t the answer even though it occurs more because it is banned. 方法一：一开始写的方法。 12345678def mostCommonWord(self, paragraph: 'str', banned: 'List[str]') -&gt; 'str': words = re.split(r'[!?\',;. ]', paragraph.lower()) c = collections.Counter(words) banned = set(banned) for word, count in c.most_common(): if word and word not in banned: return word return '' 方法二：上述方法的优化。 12345def mostCommonWord(self, paragraph: 'str', banned: 'List[str]') -&gt; 'str': words = re.findall(r'\w+', paragraph.lower()) banset = set(banned) return collections.Counter( (w for w in words if w not in banset)).most_common(1)[0][0] 821. Shortest Distance to a Character根据已知字符串S, 求目标字符C和左右index最近的距离。原题12Input: S = &quot;loveleetcode&quot;, C = &apos;e&apos;Output: [3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0] 方法一：前后遍历两次，分别求距离。本想通过一次，结果实现过于繁琐。 12345678def shortestToChar(self, S: 'str', C: 'str') -&gt; 'List[int]': n = len(S) ans = [0 if x == C else n for x in S] pos = -n for i in list(range(n)) + list(range(n)[::-1]): if ans[i] == 0: pos = i ans[i] = min(ans[i], abs(pos-i)) return ans 824. Goat Latin山羊拉丁口音，把一句话中的每个单词根据规则，生成一句新的话。原题12Input: &quot;The quick brown fox jumped over the lazy dog&quot;Output: &quot;heTmaa uickqmaaa rownbmaaaa oxfmaaaaa umpedjmaaaaaa overmaaaaaaa hetmaaaaaaaa azylmaaaaaaaaa ogdmaaaaaaaaaa&quot; 123456789def toGoatLatin(self, S: 'str') -&gt; 'str': vowels = set('aeiouAEIOU') words = [] for i, word in enumerate(S.split(), start=1): if word[0] not in vowels: word = word[1:] + word[0] word += 'ma'+'a'*i words.append(word) return ' '.join(words) 844. Backspace String Compare退格键字符串比较。比较两个带有退格#的字符串，判断最后输出是否一致。原题123Input: S = &quot;ab#c&quot;, T = &quot;ad#c&quot;Output: trueExplanation: Both S and T become &quot;ac&quot;. 方法一：首先想到stack. 123456789101112def backspaceCompare(self, S: 'str', T: 'str') -&gt; 'bool': def type_text(s): stack = [] for c in s: if c != '#': stack.append(c) elif stack: stack.pop() return stack return type_text(S) == type_text(T) 方法二：two pointers. Space Complexity: O(1). 12345678910111213def backspaceCompare(self, S: 'str', T: 'str') -&gt; 'bool': def type_c(s): skip = 0 for x in reversed(s): if x == '#': skip += 1 elif skip: skip -= 1 else: yield x return all(x==y for x, y in itertools.zip_longest(type_c(S), type_c(T))) 方法三：这个方法也很有意思，理论上效率不高，但实际上也并无差别。使用reduce然后切片去掉上次结果的末尾元素。最后一个空串的参数表明了一个初始化参数。如果没有它，#a#c的结果会变成#c。因为第一次循环相当于back(&#39;#&#39;, &#39;a&#39;)所以第一个#会一直保留。 1234def backspaceCompare(self, S: 'str', T: 'str') -&gt; 'bool': from functools import reduce back = lambda res, c: res[:-1] if c == '#' else res + c return reduce(back, S, '') == reduce(back, T, '') 查看文档中reduce实现： 123456789def reduce(function, iterable, initializer=None): it = iter(iterable) if initializer is None: value = next(it) else: value = initializer for element in it: value = function(value, element) return value 859. Buddy Strings好友字符串。指A通过一次交换两个字符变成B。判断是否是好友字符串。原题1234Input: A = &quot;ab&quot;, B = &quot;ba&quot;Output: trueInput: A = &quot;ab&quot;, B = &quot;ab&quot;Output: false 方法一：Brute Force. 效率很低。 12345678910111213def buddyStrings(self, A: 'str', B: 'str') -&gt; 'bool': if len(A) != len(B) or set(A) != set(B): return False seen = set() for i in range(len(A)): if A[i] not in seen: seen.add(A[i]) else: continue for j in range(i+1, len(A)): if A[:i] + A[j] + A[i+1:j] + A[i] + A[j+1:] == B: return True return False 方法二：此题分为两种情况，一种是A==B，此时判断是否有重复元素；另一种找到不相等的对，有且只能有一对。结尾len(pairs)的判断虽然显得有些重复，不过可以在某些情况提前退出提高效率，所以没有写成列表生成式的形式。 1234567891011def buddyStrings(self, A: 'str', B: 'str') -&gt; 'bool': if len(A) != len(B): return False if A == B: return len(A) != len(set(A)) else: pairs = [] for a, b in zip(A, B): if a != b: pairs.append((a, b)) if len(pairs) &gt;= 3: return False return len(pairs) == 2 and pairs[0] == pairs[1][::-1] 893. Groups of Special-Equivalent Strings特殊等价字符串组。这题Contest就没做出来，描述有问题，讨论区一堆diss的评论。总的来说就是把A的字符串分组，能够改变偶数位的字符，或奇数位的字符能使之相等的为一组，求一共有多少个组。原题1234567891011Input: [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;a&quot;,&quot;c&quot;,&quot;c&quot;]Output: 3Explanation: 3 groups [&quot;a&quot;,&quot;a&quot;], [&quot;b&quot;], [&quot;c&quot;,&quot;c&quot;,&quot;c&quot;]Input: [&quot;abc&quot;,&quot;acb&quot;,&quot;bac&quot;,&quot;bca&quot;,&quot;cab&quot;,&quot;cba&quot;]Output: 3Explanation: 3 groups [&quot;abc&quot;,&quot;cba&quot;], [&quot;acb&quot;,&quot;bca&quot;], [&quot;bac&quot;,&quot;cab&quot;]Input: [&quot;abcd&quot;,&quot;cdab&quot;,&quot;adcb&quot;,&quot;cbad&quot;]Output: 1Explanation: 1 group [&quot;abcd&quot;,&quot;cdab&quot;,&quot;adcb&quot;,&quot;cbad&quot;] 方法一：数组保留索引。 12345678def numSpecialEquivGroups(self, A: 'List[str]') -&gt; 'int': def count(A): ans = [0] * 52 for i, letter in enumerate(A): ans[ord(letter) - ord('a') + 26 * (i%2)] += 1 return tuple(ans) return len(&#123;count(word) for word in A&#125;) 方法二：切片字符串排序。 123def numSpecialEquivGroups(self, A: 'List[str]') -&gt; 'int': return len(&#123;''.join(sorted(s[0::2])) + ''.join(sorted(s[1::2])) for s in A&#125;) 1003. Check If Word Is Valid After Substitutions判断字符串是否由abc无限插入得到。原题12345Input: &quot;aabcbc&quot;Output: trueExplanation: We start with the valid string &quot;abc&quot;.Then we can insert another &quot;abc&quot; between &quot;a&quot; and &quot;bc&quot;, resulting in &quot;a&quot; + &quot;abc&quot; + &quot;bc&quot; which is &quot;aabcbc&quot;. 12345678def isValid(self, S: str) -&gt; bool: while len(S) &gt;= 3: if 'abc' in S: i = S.index('abc') S = S[:i] + S[i+3:] else: return False return S == '' 17. Letter Combinations of a Phone Number电话的数字可以组成的字符串组合。原题12Input: &quot;23&quot;Output: [&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;]. 方法一：recursive. 123456789101112def letterCombinations(self, digits: str) -&gt; List[str]: phone = &#123;'2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'&#125; if not digits: return [] def helper(digits): if not digits: return [''] return [c + suffix for c in phone[digits[0]] for suffix in helper(digits[1:])] return helper(digits) 方法二：使用product。 12345def letterCombinations(self, digits: str) -&gt; List[str]: phone = &#123;'2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'&#125; from itertools import product return digits and list(map(''.join, product(*(phone[d] for d in digits)))) or [] 方法三：实现product。 12345678def letterCombinations(self, digits: str) -&gt; List[str]: phone = &#123;'2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'&#125; ans = [''] letters = (phone[d] for d in digits) for key in letters: ans = [x+char for x in ans for char in key] return digits and ans or [] 方法四：评论里看到的reduce方法。 123456def letterCombinations(self, digits: str) -&gt; List[str]: from functools import reduce phone = &#123;'2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'&#125; if not digits: return [] return reduce(lambda acc, digit: [x + y for x in acc for y in phone[digit]], digits, ['']) 方法五：Solution中的回溯法。 1234567891011121314def letterCombinations(self, digits: str) -&gt; List[str]: phone = &#123;'2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'&#125; def backtrack(combination, digits): if not digits: ans.append(combination) else: for letter in phone[digits[0]]: backtrack(combination + letter, digits[1:]) ans = [] if digits: backtrack('', digits) return ans 1023. Binary String With Substrings Representing 1 To N二进制子串，从1到N。原题12Input: S = &quot;0110&quot;, N = 3Output: true 方法一：暴力法。 12def queryString(self, S: str, N: int) -&gt; bool: return all(bin(n)[2:] in S for n in range(1, N+1)) 方法二：对于任意的i&lt;N/2的数i*2的二进制表示形式一定包含i。因为左移一位。 12def queryString(self, S: str, N: int) -&gt; bool: return all(bin(n)[2:] in S for n in range(N, N//2, -1)) 482. License Key Formatting根据要求格式化字符串。原题12Input: S = &quot;5F3Z-2e-9-w&quot;, K = 4Output: &quot;5F3Z-2E9W&quot; 方法一：使用内置方法。 123def licenseKeyFormatting(self, S: str, K: int) -&gt; str: s = S.replace('-', '').upper()[::-1] return '-'.join(s[i:i+K] for i in range(0, len(s), K))[::-1] 方法二：完整实现。one-pass. 12345678def licenseKeyFormatting(self, S: str, K: int) -&gt; str: s = S.replace('-', '').upper() ans, n = '', len(s) f = n % K ans += s[:f] for i in range(f, n, K): ans += '-' + s[i:i+K] return ans.strip('-')]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
        <tag>Algorithm</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode算法题整理（数学篇）Math]]></title>
    <url>%2FLeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E6%95%B0%E5%AD%A6%E7%AF%87%EF%BC%89Math%2F</url>
    <content type="text"><![CDATA[7. Reverse Integer倒置一个整数， 此答案忽略了原题中的范围判断。原题12Input: -123Output: -321 方法一：str 12345def reverse_int(x): if x &gt;= 0: return int(str(x)[::-1]) else: return -int(str(x)[:0:-1]) 方法二：math 1234567def reverse(self, x: int) -&gt; int: sign = 1 if x &gt;= 0 else -1 ans, tail = 0, abs(x) while tail: ans = ans*10 + tail%10 tail //= 10 return ans * sign if ans &lt; 2**31 else 0 9. Palindrome Number判断一个数是否是回文数，这里把负数认为是不符合条件的。原题方法一：str 12def is_palindrome(x): return str(x) == str(x)[::-1] 方法二：math 123456def is_palindrome(x): l, r = x, 0 while l &gt; 0: r = r*10 + l%10 l //= 10 return r == x 13. Roman to Integer罗马数字转换整型。原题12345678910def roman_to_int(s): roman = &#123;'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000&#125; total = 0 for i in range(len(s)): if i == len(s)-1 or roman[s[i]] &gt;= roman[s[i+1]] total += roman[s[i]] else: total -= roman[s[i]] return total 69. Sqrt(x)实现开方，返回整数部分。原题1234Input: 8Output: 2Explanation: The square root of 8 is 2.82842..., and since the decimal part is truncated, 2 is returned. 牛顿迭代法 12345def my_sqrt(x): r = x while r**2 &gt; x: r = (r+x//r) // 2 return r 367. Valid Perfect Square判断一个数是不是某个数的平方。原题12Input: 16Output: true 方法一：牛顿迭代法。同69。 12345def isPerfectSquare(self, num): r = num while r**2 &gt; num: r = (r + num // r) // 2 return r**2 == num 171. Excel Sheet Column Numberexcel表格列表数字转换，二十六进制。原题1234567A -&gt; 1B -&gt; 2C -&gt; 3...Z -&gt; 26AA -&gt; 27AB -&gt; 28 A -&gt; 1 123def titleToNumber(self, s: str) -&gt; int: OFFSET = ord('A')-1 return sum((ord(x)-OFFSET)*26**i for i, x in enumerate(s[::-1])) 168. Excel Sheet Column Titleexcel转换，数字转字母。十进制-&gt;26进制。原题1234567def convertToTitle(self, n): res = '' while n: res = chr((n-1)%26+65) + res # n //= 26 n = (n-1) // 26 return res 172. Factorial Trailing Zeroes求n的阶乘末尾有几个0。原题123Input: 5Output: 1Explanation: 5! = 120, one trailing zero. 思路：每一对2和5可以产生一个0，在n的阶乘中，5比2多，所以问题变成求5的个数，而25这种数有两个5，所以递归求解 12def trailing_zeroes(n): return 0 if n == 0 else n//5 + trailing_zeroes(n//5) 204. Count Primes求小于n的整数中，有多少个质数。原题123456def countPrimes(self, n): is_prime = [False]*2 + [True]*(n-2) for i in range(2, int(n ** 0.5)+1): if is_prime[i]: is_prime[i*i:n:i] = [False] * len(is_prime[i*i:n:i]) return sum(is_prime) 50. Pow(x, n)实现pow函数。原题12345Input: 2.00000, 10Output: 1024.00000Input: 2.00000, -2Output: 0.25000 . 说明：常规方法在Leetcode 上内存会爆掉。 123456789101112131415161718192021class Solution(object): def myPow(self, x, n): if n &lt; 0: return 1 / self.pow_with_unsigned(x, -n) else: return self.pow_with_unsigned(x, n) def pow_with_unsigned(self, x, n): if n == 1: return x if n == 0: return 1 res = self.pow_with_unsigned(x, n &gt;&gt; 1) res *= res if n &amp; 1 == 1: res *= x return res 233. Number of Digit One1~n数字中1的个数。原题1234567def countDigitOne(self, n): countr, i = 0, 1 while i &lt;= n: divider = i * 10 countr += (n // divider) * i + min(max(n % divider - i + 1, 0), i) i *= 10 return countr 263. Ugly Number判断一个数是否是丑数。原题方法一：根据定义实现。&lt; num是为了判断num=0的情况。 12345def isUgly(self, num): for f in 2, 3, 5: while num % f == 0 &lt; num: num //= f return num == 1 264. Ugly Number II输出第n个丑数。原题书中的方法 1234567891011121314def nthUglyNumber(self, n): q = [1] t2, t3, t5 = 0, 0, 0 for i in range(n-1): a2, a3, a5 = q[t2]*2, q[t3]*3, q[t5]*5 to_add = min(a2, a3, a5) q.append(to_add) if a2 == to_add: t2 += 1 if a3 == to_add: t3 += 1 if a5 == to_add: t5 += 1 return q[-1] 67.Add Binary实现二进制加法。原题12Input: a = &quot;11&quot;, b = &quot;1&quot;Output: &quot;100&quot; 方法一：按照加法的二进制思想来计算，不过Runtime大约100ms。后来试着将list comprehension拆成一个for循环，也并没有提高速度。居然beats只有4%，难道大部分人都用的bin。讨论区简单翻了了一下，没有找到一个高效的pythonic的方法。 1234567891011def addBinary(self, a, b): if len(a) &gt; len(b): b = b.zfill(len(a)) else: a = a.zfill(len(b)) while int(b): sum_not_carry = ''.join([str(int(a[i]) ^ int(b[i])) for i in range(len(a))]) carry = ''.join([str(int(a[i]) &amp; int(b[i])) for i in range(len(a))]) a, b = "0"+sum_not_carry, carry+'0' return a.lstrip('0') if a != '0' else '0' 202. Happy Number判断是否是欢乐数。进行所有位的平方和运算，最后为1的是欢乐数。原题1234567Input: 19Output: trueExplanation: 1**2 + 9**2 = 828**2 + 2**2 = 686**2 + 8**2 = 1001**2 + 0**2 + 0**2 = 1 方法一：思路，使用一个字典映射0~9的平方值，然后如果死循环的话，各位数的和一定存在着一种循环，所以用一个set来判断是否重复。 12345678910def isHappy(self, n): squares = &#123;str(k): k**2 for k in range(0, 10)&#125; sum_digit = set() while n != 1: n = sum(squares[digit] for digit in str(n)) if n in sum_digit: return False else: sum_digit.add(n) return True 231. Power of Two判断一个数是否是2的n次方。思路也就是判断这个数的二进制形式是否只有一个’1’。原题方法一：可以用作通用方法。 12345def isPowerOfTwo(self, n, power=2): if n == 0: return False while n % power == 0: n //= power return n == 1 方法二：二进制统计1。 12def isPowerOfTwo(self, n): return n &gt; 0 and bin(n).count('1') == 1 方法三：如果一个数n的二进制只有一个1，那么n&amp;(n-1)一定为0。 12def isPowerOfTwo(self, n): return n &gt; 0 and (n&amp;n-1) == 0 342. Power of Four判断一个数是否是4的n次方。原题方法一：从简单入手通过231题，了解到了2的n次方特点是，二进制形式只有一个’1’，那么4的n次方就是不但只有一个’1’，后面还跟了偶数个’0’。 1234567891011def isPowerOfFour(self, num): single_1 = num &gt; 0 and not (num &amp; num-1) if single_1: while num &gt; 0: if num == 1: return True else: num &gt;&gt;= 2 return False else: return False 方法二：上述代码看起来更像是java代码，我们使用count来判断0的个数是否为偶数个。 123def isPowerOfFour(self, num): # return num &gt; 0 and (num &amp; num-1)==0 and bin(num)[2:].count('0')&amp;1==0 return num &gt; 0 and (num &amp; num-1)==0 and len(bin(num))&amp;1==1 方法三：也可以使用正则。 123def isPowerOfFour(self, num): import re return bool(re.match(r'^0b1(00)*$',bin(num))) 292. Nim Game说，有这么一堆石头，一次只能拿1~3个，拿到最后一个石头的人获胜。求n堆石头，你先拿是否可以获胜。原题思路：找规律，发现只有最后剩4个石头的时候，此时轮到谁，谁输。 12def canWinNim(self, n): return n % 4 != 0 400. Nth Digit找出无限整数序列中的第n个数字。原题123456Input:11Output:0Explanation:The 11th digit of the sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... is a 0, which is part of the number 10. 思路，根据n的位数，将无限序列分为几个范围。 size of n step start ~ stop 1 9 1 ~ 9 2 90 10 ~ 99 3 900 100 ~ 999 寻找范围。寻找n处于哪个范围，是1~9，还是10~99，例如n=15。则需要跳过1~9的范围，而这个范围有size*step个数字，所以问题变成在10~99范围上寻找第15-1*9=6个数。 定位数字。10~99范围中是从10开始的，每一个数都有两位数字，所以最终数字为10+(6-1)//2，因为索引从0开始，所以需要-1。 定位数字的位。上一步找到了数字为12，对size求余就可以知道，&#39;12&#39;[(6-1)%2]=&#39;2&#39;。 12345def findNthDigit(self, n): start, step, size = 1, 9, 1 while n &gt; size * step: n, start, step, size = n-size*step, start*10, step*10, size+1 return int(str(start + (n-1)//size)[(n-1) % size]) 415. Add Stings给定两个字符串表示的数字，把它们相加，这两个数的长度小于5100，不能使用任何BitIntegr库或是直接将其转换为整数。ps: 题中要求不将输入直接转换成int，所以我个人认为int还是可以使用的，有一些答案中是使用了ord来做运算。原题方法一：不使用标准库。 1234567891011121314151617def addStrings(self, num1, num2): if len(num1) &gt; len(num2): num2 = num2.zfill(len(num1)) else: num1 = num1.zfill(len(num2)) res, carry = '', 0 n1, n2 = len(num1)-1, len(num2)-1 while (n1 &gt;= 0 and n2 &gt;= 0) or carry: v1 = int(num1[n1]) if n1 &gt;= 0 else 0 v2 = int(num2[n2]) if n2 &gt;= 0 else 0 carry, val = divmod(v1+v2+carry, 10) res = str(val) + res n1 -= 1 n2 -= 1 return res 方法二：使用zip_longest。 12345678910def addStrings(self, num1, num2): from itertools import zip_longest nums = list(zip_longest(num1[::-1], num2[::-1], fillvalue='0')) carry, res = 0, '' for digits in nums: d1, d2 = map(int, digits) carry, val = divmod(d1+d2+carry, 10) res = res + str(val) res = res if carry==0 else res+str(carry) return res[::-1] 492. Construct the Rectangle给定一个面积，求组成这个面积的长高差最小。原题1234Input: 4Output: [2, 2]Explanation: The target area is 4, and all the possible ways to construct it are [1,4], [2,2], [4,1]. But according to requirement 2, [1,4] is illegal; according to requirement 3, [4,1] is not optimal compared to [2,2]. So the length L is 2, and the width W is 2. 方法一：一开始我居然这样写。结果超时了，后来发现L+=1，循环次数要比L-=1要多。 12345678910def constructRectangle(self, area): import math squre = math.sqrt(area) if int(squre) == squre: return [int(squre), int(squre)] else: L = int(squre) + 1 while area % L != 0: L += 1 return [L, area//L] 方法二：整理一下思路其实很简单，之前想多了还以为有二分的方法。递减肯定是会优先退出循环的，但是我还不知道怎么证明这个结论。 123456def constructRectangle(self, area): import math w = int(math.sqrt(area)) while area % w != 0: w -= 1 return [area//w, w] 504. Base 710进制转7进制。原题1234Input: 100Output: &quot;202&quot;Input: -7Output: &quot;-10&quot; 方法一：需要注意负数。 1234567def convertToBase7(self, num: int) -&gt; str: if num == 0: return '0' n, ans = abs(num), '' while n: n, val = divmod(n, 7) ans = str(val) + ans return ans if num &gt; 0 else '-'+ans 970. Powerful Integers求满足x^i+y^j &lt;= bound的所有和。原题12345678910Input: x = 2, y = 3, bound = 10Output: [2,3,4,5,7,9,10]Explanation: 2 = 2^0 + 3^03 = 2^1 + 3^04 = 2^0 + 3^15 = 2^1 + 3^17 = 2^2 + 3^19 = 2^3 + 3^010 = 2^0 + 3^2 方法一：这题难得地方在于两个循环的临界值，貌似我这样写也不是最优解，原题的Solution中给定了2**18&gt;bound的最大值。所以两个范围都是18。 123456789101112131415def powerfulIntegers(self, x, y, bound): res = set() imax = self.get_max(x, bound) + 1 jmax = self.get_max(y, bound) + 1 for i in range(imax): for j in range(jmax): if x**i + y**j &lt;= bound: res.add(x**i+y**j) return list(res) def get_max(self, n, bound): for i in range(bound//n + 1): if n ** i &gt;= bound: return i return bound//n + 1 973. K Closest Points to Origin求离原点最近的K个坐标点。原题1234567Input: points = [[1,3],[-2,2]], K = 1Output: [[-2,2]]Explanation: The distance between (1, 3) and the origin is sqrt(10).The distance between (-2, 2) and the origin is sqrt(8).Since sqrt(8) &lt; sqrt(10), (-2, 2) is closer to the origin.We only want the closest K = 1 points from the origin, so the answer is just [[-2,2]]. 方法一：很简单。 123def kClosest(self, points, K): res = sorted(points, key=lambda x: x[0]**2 + x[1]**2) return res[:K] 976. Largest Perimeter Triangle给定一个边长数组，求能组成的三角形的最长周长。原题方法一：这个也不难，就是长度为3的滑动窗口。 123456def largestPerimeter(self, A): res = sorted(A, reverse=True) for i in range(len(res)-2): if sum(res[i+1:i+3]) &gt; res[i]: return sum(res[i:i+3]) return 0 628. Maximum Product of Three Numbers数组中三个数的最大乘积。元素范围[-1000, 1000]。原题12Input: [1,2,3,4]Output: 24 方法一：排序。在正数个数大于等于3的时候，显然最大的三个数就可以产生最大的乘积。而当正数个数不够的时候，那么必须需要两个最小的负数（即绝对值最大），和一个最大的正数。 123def maximumProduct(self, nums): ary = sorted(nums) return max((ary[0]*ary[1]*ary[-1], ary[-3]*ary[-2]*ary[-1])) 方法二：使用heapq. 1234567def maximumProduct(self, nums): import heapq from operator import mul from functools import reduce three_max = heapq.nlargest(3, nums) two_min = heapq.nsmallest(2, nums) return max(reduce(mul, three_max), reduce(mul, two_min + three_max[:1])) 728. Self Dividing Numbers自整除数字，一个数字能够被本身的每个数字整除，并且不能有0，求某个范围内所有的数。原题123Input: left = 1, right = 22Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22] 方法一：Brute Force. 此题强行使用列表生成式没有意义。 123456789def selfDividingNumbers(self, left, right): res = [] for i in range(left, right+1): for char in str(i): if int(char)==0 or i % int(char)!=0: break else: res.append(i) return res 836. Rectangle Overlap矩形是否重叠，矩形的边平行于坐标轴。原题12Input: rec1 = [0,0,2,2], rec2 = [1,1,3,3]Output: true 方法一：通过画图找出的规律。 1234def isRectangleOverlap(self, rec1: 'List[int]', rec2: 'List[int]') -&gt; 'bool': x_overlap = (rec2[0]-rec1[2]) * (rec2[2]-rec1[0]) &lt; 0 y_overlap = (rec2[1]-rec1[3]) * (rec2[3]-rec1[1]) &lt; 0 return x_overlap and y_overlap 方法二：方法一还是想复杂了。 Given 2 segment (left1, right1), (left2, right2), how can we check whether they overlap?If these two intervals overlap, it should exist an number x, 123left1 &lt; x &lt; right1 &amp;&amp; left2 &lt; x &lt; right2left1 &lt; x &lt; right2 &amp;&amp; left2 &lt; x &lt; right1left1 &lt; right2 &amp;&amp; left2 &lt; right1 123def isRectangleOverlap(self, rec1: 'List[int]', rec2: 'List[int]') -&gt; 'bool': return rec2[0] &lt; rec1[2] and rec1[0] &lt; rec2[2] and \ rec2[1] &lt; rec1[3] and rec1[1] &lt; rec2[3] 991. Broken Calculator坏掉的计算器，只能*2或者-1，使X变为Y。原题123Input: X = 5, Y = 8Output: 2Explanation: Use decrement and then double &#123;5 -&gt; 4 -&gt; 8&#125;. 解析：如果从X到Y问题会变得复杂，不确定什么时候该*2或者是-1。所以逆向思维从Y变成X。 If Y &lt;= X, we won’t do Y / 2 anymore.We will increase Y until it equals to X So before that, while Y &gt; X, we’ll keep reducing Y, until it’s smaller than X.If Y is odd, we can do only Y = Y + 1If Y is even, if we plus 1 to Y, then Y is odd, we need to plus another 1.And because (Y + 1 + 1) / 2 = (Y / 2) + 1, 3 operations are more than 2.We always choose Y / 2 if Y is even. 方法一：iteratively. 123456789def brokenCalc(self, X: 'int', Y: 'int') -&gt; 'int': ans = 0 while X &lt; Y: ans += 1 if Y &amp; 1 == 1: Y += 1 else: Y //= 2 return ans + X - Y 方法二：方法一变形。因为如果Y是奇数，那么必定在+1操作后要/2，这里将其合并 123456789def brokenCalc(self, X: 'int', Y: 'int') -&gt; 'int': ans = 0 while X &lt; Y: ans += 1 if Y &amp; 1 == 1: Y += 1 ans += 1 Y = Y // 2 return ans + X - Y 方法三：方法二再变形，看到Y是奇数时，ans + 2，所以可以用ans += (Y&amp;1) + 1表示，而Y在是奇数时先+1再//2即Y = (Y + 1) // 2，偶数时Y = Y // 2，其实，对于偶数来说Y=(Y+1)//2和Y=Y//2结果一样。所以可以写成。 123456def brokenCalc(self, X: 'int', Y: 'int') -&gt; 'int': ans = 0 while X &lt; Y: ans += (Y &amp; 1) + 1 Y = (Y + 1) // 2 return ans + X - Y 方法四：递归写法。Y&amp;1必须括号 12def brokenCalc(self, X: 'int', Y: 'int') -&gt; 'int': return X - Y if X &gt;= Y else 1+(Y&amp;1)+self.brokenCalc(X, (Y+1)//2) 908. Smallest Range I给定一个数组，和一个K，数组里的数加上-k&lt;=x&lt;=k的任意一个数字后，求数组最大数和最小数的，最小差。原题123Input: A = [0,10], K = 2Output: 6Explanation: B = [2,8] 12def smallestRangeI(self, A: 'List[int]', K: 'int') -&gt; 'int': return max(max(A) - min(A) - 2*K, 0) 949. Largest Time for Given Digits给定四个数字，返回能生成的最大时间。24小时制。原题12Input: [1,2,3,4]Output: &quot;23:41&quot; 方法一：排序。 123456def largestTimeFromDigits(self, A: 'List[int]') -&gt; 'str': p = itertools.permutations(A) for a, b, c, d in sorted(p, reverse=True): if 0 &lt;= a*10+b &lt;= 23 and 0 &lt;= 10*c+d &lt;= 59: return '&#123;&#125;&#123;&#125;:&#123;&#125;&#123;&#125;'.format(a, b, c, d) return '' 1234def largestTimeFromDigits(self, A: 'List[int]') -&gt; 'str': p = itertools.permutations(A) return max(['&#123;&#125;&#123;&#125;:&#123;&#125;&#123;&#125;'.format(*d) for d in p if d[:2] &lt; (2, 4) and d[2] &lt; 6] or ['']) 914. X of a Kind in a Deck of Cards有这样一堆数字卡牌，问是否存在一个X&gt;=2，使得将同样数字的卡牌分为每X个一组，并且刚好所有的卡牌分完。原题思路：使用Counter来统计每个数字的个数，然后求这些数字的最大公约数是否大于等于2，这里思路卡了一下，因为没想到最大公约数可以通过reduce来计算，没考虑到是可以累积的。 12345def hasGroupsSizeX(self, deck): from collections import Counter from math import gcd from functools import reduce return reduce(gcd, Counter(deck).values()) &gt;= 2 470. Implement Rand10() Using Rand7()使用rand7实现rand10原题12Input: 3Output: [8,1,10] 12345def rand10(self): while True: x = (rand7()-1)*7 + rand7()-1 if x &lt; 40: return x%10 + 1 1006. Clumsy Factorial将一个阶乘的式子用*/+-替代，给出结果。原题123Input: 10Output: 12Explanation: 12 = 10 * 9 / 8 + 7 - 6 * 5 / 4 + 3 - 2 * 1 方法一：python此题有作弊的方法，我看排行榜中大神有的特意切到python做这道题，不过没我写得好。 1234def clumsy(self, N: int) -&gt; int: op = itertools.cycle(['*', '//', '+', '-']) return eval(''.join(str(n)+next(op) if n!=1 else str(n) for n in range(N, 0, -1))) 1022. Smallest Integer Divisible by K最小的由1组成的能被K整除。原题123Input: 2Output: -1Explanation: There is no such positive integer N divisible by 2. 如果有2或5的质因数，那么不能整除。 123456def smallestRepunitDivByK(self, K: int) -&gt; int: if K % 2 == 0 or K % 5 == 0: return -1 r = 0 for N in range(1, K + 1): r = (r * 10 + 1) % K if not r: return N 1028. Convert to Base -210进制转成-2进制。原题方法一：负数进制时，如果余数为负数，那么商+1。 12345678910def baseNeg2(self, N: int) -&gt; str: if not N: return '0' ans = '' while N: remainder = N % (-2) ans += str(abs(remainder)) N //= -2 N += (remainder &lt; 0) return ans[::-1] 方法二：在二进制上加一个负号。 123456def baseNeg2(self, N: int) -&gt; str: ans = [] while N: ans.append(N &amp; 1) N = -(N &gt;&gt; 1) return ''.join(map(str, ans[::-1] or [0]))]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
        <tag>Algorithm</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode算法题整理（数组篇）Array]]></title>
    <url>%2FLeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E6%95%B0%E7%BB%84%E7%AF%87%EF%BC%89Array%2F</url>
    <content type="text"><![CDATA[26. Remove Duplicates from Sorted Array删除排序数组中重复的元素, 在原数组上操作，返回一个长度，标识前n个元素为目标数组。原题 12345Given nums = [0,0,1,1,1,2,2,3,3,4],Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.It doesn&apos;t matter what values are set beyond the returned length. 123456789def remove_duplicates(nums): if not nums: return 0 index = 1 for i in range(len(nums)-1): if nums[i] != nums[i+1]: nums[index] = nums[i+1] index += 1 return index 66. Plus One给数组加一，元素为非负整数，不以0开头，每个元素只有一个数字。原题123Input: [4,3,2,1]Output: [4,3,2,2]Explanation: The array represents the integer 4321. 方法一：转成字符串再转成数字 123def plusOne(self, digits: 'List[int]') -&gt; 'List[int]': num = int(''.join(map(str, digits))) return [int(d) for d in str(num + 1)] 方法二：Math 进位 123456789101112def plus_one(digits): d = digits[:] plused = [] carry = 1 while d or carry: if d: v = d.pop() else: v = 0 carry, val = divmod(carry+v, 10) plused.append(val) return plused[::-1] 方法三：数组进位。 123456789def plusOne(self, digits: 'List[int]') -&gt; 'List[int]': d = digits[:] d[-1] += 1 for i in range(len(d)-1, -1, -1): carry, d[i] = divmod(d[i], 10) if i: d[i-1] += carry if carry: d.insert(0, carry) return d 989. Add to Array-Form of Integer和66题很相似。不同的是这个K会大于10，以至于余数也会大于10。原题123Input: A = [2,7,4], K = 181Output: [4,5,5]Explanation: 274 + 181 = 455 方法一：竞赛写法。 123def addToArrayForm(self, A: 'List[int]', K: 'int') -&gt; 'List[int]': a = int(''.join(map(str, A))) return [int(c) for c in str(a + K)] 方法二：原理实现。 12345678def addToArrayForm(self, A: 'List[int]', K: 'int') -&gt; 'List[int]': A[-1] += K for i in range(len(A)-1, -1, -1): carry, A[i] = divmod(A[i], 10) if i: A[i-1] += carry if carry: A = list(map(int, str(carry))) + A return A 88. Merge Sorted Array合并两个有序数组，在nums1上修改。原题12345Input:nums1 = [1,2,3,0,0,0], m = 3nums2 = [2,5,6], n = 3Output: [1,2,2,3,5,6] 12345678910def merge(self, nums1, m, nums2, n): while m&gt;0 and n&gt;0: if nums1[m-1] &gt; nums2[n-1]: nums1[n+m-1] = nums1[m-1] m -= 1 else: nums1[n+m-1] = nums2[n-1] n -= 1 if n &gt; 0: nums1[:n] = nums2[:n] 118. Pascal’s Triangle杨辉三角。原题123456789Input: 5Output:[ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1]] 方法一: 错位相加。这里也可以使用zip，值得注意的是，res需要➕一个二维数组，而不是一维。结尾的切片是为了0的情况。 123456def generate(self, numRows: 'int') -&gt; 'List[List[int]]': ans = [[1]] for _ in range(numRows-1): ans += [[a+b for a, b in zip([0]+ans[-1], ans[-1]+[0])]] # ans.append(list(map(lambda x, y: x + y, [0]+ans[-1], ans[-1]+[0]))) return ans[:numRows] 方法二 123456789def generate(num): triangle = [] inner = [1] for _ in range(num): triangle.append(list(inner)) inner.append(0) right = [inner[i]+inner[i+1] for i in range(len(inner)-1)] inner = [1] + right return triangle 119.Pascal’s Triangle II杨辉三角，只打印一层。原题12345def getRow(self, rowIndex: 'int') -&gt; 'List[int]': ans = [1] for _ in range(rowIndex): ans = [a+b for a, b in zip([0]+ans, ans+[0])] return ans 169. Majority Element找出数组中出现次数超过一半的元素。原题方法一：排序. Time-O(nlogn), Space-O(n) 12def majority_element(nums): return sorted(nums)[len(nums)//2] 方法二：Counter Time-O(n), Space-O(n) 12345def majority_element(nums): from collections import Counter c = Counter(nums) # return max(c.keys(), key=c.get) return c.most_common(1)[0][0] 方法三：Boyer-Moore Voting Algorithm. 书中的算法说的就是这个，这里附上自己的见解。 波义尔摩尔投票算法 12345678def majorityElement(self, nums): count = 0 candidate = None for num in nums: if count == 0: candidate = num count += (1 if num == candidate else -1) return candidate 189. Rotate Array旋转数组。原题123456Input: [1,2,3,4,5,6,7] and k = 3Output: [5,6,7,1,2,3,4]Explanation:rotate 1 steps to the right: [7,1,2,3,4,5,6]rotate 2 steps to the right: [6,7,1,2,3,4,5]rotate 3 steps to the right: [5,6,7,1,2,3,4] 方法一：slicing。 123def rotate(nums, k): k = k % len(nums) nums[:] = nums[-k:] + nums[:-k] 方法二：这个方法不是很高效 123def rotate(nums, k): for _ in range(k): nums.insert(0, nums.pop()) 方法三：deque实现。 1234def rotate(self, nums: 'List[int]', k: 'int') -&gt; 'None': q = collections.deque(nums) q.rotate(k) nums[:] = q 217. Contains Duplicate数组中是否包含重复元素。原题12Input: [1,2,3,1]Output: true 方法一：set 12def contains_duplicate(nums): return len(set(nums)) &lt; len(nums) 方法二：hash 12345678def containsDuplicate(self, nums: 'List[int]') -&gt; 'bool': seen = set() for num in nums: if num in seen: return True else: seen.add(num) return False 219. Contains Duplicate II数组中是否包含重复元素，且元素下标差小于等于k。原题1234Input: nums = [1,2,3,1], k = 3Output: trueInput: nums = [1,0,1,1], k = 1Output: true 思路：开始想用set作切片来判断，同上题方法一，但是效率太低。故使用字典。 123456789def containsNearbyDuplicate(self, nums, k): n = len(nums) seen = &#123;&#125; for i, num in enumerate(nums): if num in seen: if i-seen[num] &lt;= k: return True seen[num] = i return False 283. Move Zeroes将数组0元素移动到末尾，保证其他元素顺序。原题12Input: [0,1,0,3,12]Output: [1,3,12,0,0] 方法一：two pointers 12345678def move_zero(nums): l, r = 0, len(nums)-1 while l &lt; r: if nums[l] == 0: nums[:] = nums[:l] + nums[l+1:] + [0] r -= 1 else: l += 1 方法二： slicing 12def move_zero(nums): nums[:] = [x for x in nums if x != 0] + [x for x in nums if x == 0] 方法三：最后0的位置，感觉像冒泡。 123456def moveZeroes(self, nums: 'List[int]') -&gt; 'None': p = 0 for i, num in enumerate(nums): if num != 0: nums[p], nums[i] = nums[i], nums[p] p += 1 方法四：排序。时间复杂度略高。 12def moveZeroes(self, nums: 'List[int]') -&gt; 'None': nums.sort(key=lambda x: 1 if x==0 else 0) 54. Spiral Matrix螺旋矩阵，顺时针打印矩阵。原题这里注意一点matrix.pop(0)需要转成list，因为zip函数中的每个元素是一个tuple，如果不转变成了一个tuple+list，会抛出异常。 ps: 此题解法为LeetCode一位大神，经常能看到此人的答案，不过这个是我认为最pythonic的一个，没有为了强行one-line而one-line。brilliant! 1TypeError: can only concatenate tuple (not &quot;list&quot;) to tuple 12def spiralOrder(self, matrix): return matrix and list(matrix.pop(0))+self.spiralOrder(list(zip(*matrix))[::-1]) 此题有个变形，如果逆时针该如何打印。这样的话情况稍微复杂一些。 1234567def anti_clock_wise(self, matrix) if not matrix: return [] clock_wise = list(zip(*(matrix[::-1]))) a = list(clock_wise.pop(0))[::-1] b = self.anti_clock_wise(clock_wise) return a + b 46. Permutations数组全排列。原题12345678910Input: [1,2,3]Output:[ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]] 方法一：recursively. 锁定头部法。思想为拿出一个数字作为头部，剩下的递归。 1234def permute(self, nums): return [[n] + p for i, n in enumerate(nums) for p in self.permute(nums[:i]+nums[i+1:])] or [[]] 方法二：到处插入法。 1234def permute(self, nums: 'List[int]') -&gt; 'List[List[int]]': return nums and [p[:i] + [nums[0]] + p[i:] for p in self.permute(nums[1:]) for i in range(len(nums))] or [[]] 方法二：iteratively. 思想为拿出一个数字插入到现有排序中的各个位置。 1234567def permute(self, nums): ans = [[]] for n in nums: ans = [l[:i] + [n] + l[i:] for l in ans for i in range(len(l)+1)] return ans 47. Permutations II全排列并去重。原题1234567Input: [1,1,2]Output:[ [1,1,2], [1,2,1], [2,1,1]] 思路：当然可以使用set来去重，或者考虑一种迭代的方式。 展开。拿着每个数字向上一个结果中插入到每一个位置。 123456789101112131415def permuteUnique(self, nums): ans = [[]] for j, n in enumerate(nums): new_ans = [] for l in ans: for i in range(len(l)+1): new_ans.append(l[:i]+[n]+l[i:]) print('\t j &#123;0&#125; - &#123;3&#125; + [&#123;2&#125;] + &#123;4&#125;'.format(j, i, n, l[:i], l[i:])) # if i&lt;len(l) and l[i]==n: break #handles duplication if i&lt;len(l) and l[i]==n: print('\t \t l[&#123;&#125;] == &#123;&#125;'.format(i, n)) break #handles duplication ans = new_ans print('j &#123;&#125; afer inner ans &#123;&#125;'.format(j, ans)) return ans 输入nums=[1, 2, 3] 123456789101112 j 0 - [] + [1] + []j 0 afer inner ans [[1]] j 1 - [] + [2] + [1] j 1 - [1] + [2] + []j 1 afer inner ans [[2, 1], [1, 2]] j 2 - [] + [3] + [2, 1] j 2 - [2] + [3] + [1] j 2 - [2, 1] + [3] + [] j 2 - [] + [3] + [1, 2] j 2 - [1] + [3] + [2] j 2 - [1, 2] + [3] + []j 2 afer inner ans [[3, 2, 1], [2, 3, 1], [2, 1, 3], [3, 1, 2], [1, 3, 2], [1, 2, 3]] 理解一下是如何去重的，我们输入nums=[1, 2, 1] 123456789101112 j 0 - [] + [1] + []j 0 afer inner ans [[1]] j 1 - [] + [2] + [1] j 1 - [1] + [2] + []j 1 afer inner ans [[2, 1], [1, 2]] j 2 - [] + [1] + [2, 1] j 2 - [2] + [1] + [1] l[1] == 1 j 2 - [] + [1] + [1, 2] l[0] == 1j 2 afer inner ans [[1, 2, 1], [2, 1, 1], [1, 1, 2]][[1, 2, 1], [2, 1, 1], [1, 1, 2]] 列表生成式整合。Stefan大神的写法。使用index来找非重复的临界值。 1234567def permuteUnique(self, nums): ans = [[]] for n in nums: ans = [l[:i]+[n]+l[i:] for l in ans for i in range((l+[n]).index(n)+1)] return ans 215. Kth Largest Element in an Array找出数组中最大的第K个数。原题快排的思想，没有通过LeetCode测试用例，因为内存超出了限制。 12345678910111213141516171819def findKthLargest(self, nums, k): if not nums: return pivot = nums[0] left, medium, right = [], [], [] for num in nums: if num &lt; pivot: left.append(num) elif num == pivot: medium.append(num) else: right.append(num) if k &lt;= len(right): return self.findKthLargest(right, k) elif k-len(right) &lt;= len(medium): return pivot else: return self.findKthLargest(left, k-len(right)-len(medium)) 考虑在原数组上进行修改。Time-O(n) 12345678910111213141516171819def findKthLargest(self, nums: List[int], k: int) -&gt; int: random.shuffle(nums) l, r = 0, len(nums)-1 def partition(l, r): for i, v in enumerate(nums[l:r+1], l): if nums[i] &gt;= nums[r]: nums[i], nums[l] = nums[l], nums[i] l += 1 return l-1 # return the index of pivot while True: pos = partition(l, r) # pos是索引，所以要与k-1比较 if pos &lt; k-1: l = pos + 1 elif pos &gt; k-1: r = pos - 1 else: return nums[pos] 使用堆。Time-O(nlogk) 12345678def findKthLargest(self, nums: List[int], k: int) -&gt; int: import heapq as hq heap = nums[:k] hq.heapify(heap) for num in nums[k:]: if num &gt; heap[0]: hq.heapreplace(heap, num) return heap[0] 703. Kth Largest Element in a Stream流中第K个大的数。原题12345678int k = 3;int[] arr = [4,5,8,2];KthLargest kthLargest = new KthLargest(3, arr);kthLargest.add(3); // returns 4kthLargest.add(5); // returns 5kthLargest.add(10); // returns 5kthLargest.add(9); // returns 8kthLargest.add(4); // returns 8 方法一：还是使用堆，一开始没想到切分，所以超时了。注意是heapreplace。 12345678910111213141516class KthLargest: def __init__(self, k, nums): import heapq self.heap = list(nums) self.k = k heapq.heapify(self.heap) while len(self.heap) &gt; k: heapq.heappop(self.heap) def add(self, val): if len(self.heap) &lt; self.k: heapq.heappush(self.heap, val) elif val &gt; self.heap[0]: heapq.heapreplace(self.heap, val) return self.heap[0] 53. Maximum Subarray连续子数组的最大和。原题123Input: [-2,1,-3,4,-1,2,1,-5,4],Output: 6Explanation: [4,-1,2,1] has the largest sum = 6. 方法一：书中的思想。 123456def maxSubArray(self, nums): cp_nums = nums[:] for i in range(1, len(nums)): if cp_nums[i-1] &gt; 0: cp_nums[i] += cp_nums[i-1] return max(cp_nums) 方法二：one-liner。注意accumulate是把函数放到后面的。 123def maxSubArray(self, nums): from itertools import accumulate return max(accumulate(nums, lambda x, y: x+y if x &gt; 0 else y)) 904. Fruit Into Baskets实际上该题抽象为求最大滑动窗口的长度，滑动窗口不同元素最多不超过两个。原题1234tree = [3,3,3,1,2,1,1,2,3,3,4] # 5tree = [1,0,1,4,1,4,1,2,3] # 5tree = [1,2,3,2,2] # 4tree = [0,1,6,6,4,4,6] # 5 一开始没有找到滑动窗口的左边界，老是想直接删除一个key，后来看别人代码受到启发，可以用一个内循环来解决，可以逐个删除，然后判断是否为空。 12345678910111213def totalFruit(self, tree): from collections import Counter basket = Counter() l, res = 0, 0 for r in range(len(tree)): basket[tree[r]] += 1 while len(basket) &gt; 2: basket[tree[l]] -= 1 if basket[tree[l]] == 0: basket.pop(tree[l]) l += 1 res = max(res, r-l+1) return res 27. Remove Element从数组中删除元素，在原数组修改，要求返回一个长度。原题12Given nums = [0,1,2,2,3,0,4,2], val = 2,Your function should return length = 5, 方法一：前后指针，r要从n开始，以n-1作比较，这里r不是从n-1开始是因为nums=[]的情况，否则l+1将超出数组范围。 123456789def removeElement(self, nums, val): l, r = 0, len(nums) while l &lt; r: if nums[l] == val: nums[l], nums[r-1] = nums[r-1], nums[l] r -= 1 else: l += 1 return l 方法二：快慢指针，几乎和283题中的方法一样。 1234567def removeElement(self, nums, val): i = 0 for j in range(len(nums)): if nums[j] != val: nums[i] = nums[j] i += 1 return i 349. Intersection of Two Arrays求两个数组的交集。返回的数组必须元素唯一，可以无序。原题思路：一开始看到这题以为是两个链表求相交点。最后发现Intersection不应该理解为“十字路口”而应该是“交集”。这里翻了一下discuss，大部分都是使用方法一，其它方法要么太繁琐，要么效率低。值得注意的是，此题的相关话题还有一项是Binary Search也就是说，可能会有一个较为高效的二分搜索法的实现方式。 123Example 2:Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]Output: [9,4] 方法一：最快的方法。 12def intersection(self, nums1, nums2): return list(set(nums1) &amp; set(nums2)) 方法二：Sort &amp; Two Pointers. 123456789101112131415161718def intersection(self, nums1: 'List[int]', nums2: 'List[int]') -&gt; 'List[int]': nums1.sort() nums2.sort() i, n1 = 0, len(nums1) j, n2 = 0, len(nums2) ans, last = [], None while i &lt; n1 and j &lt; n2: if nums1[i] == nums2[j]: if nums1[i] != last: ans.append(nums1[i]) last = nums1[i] i += 1 j += 1 elif nums1[i] &gt; nums2[j]: j += 1 elif nums1[i] &lt; nums2[j]: i += 1 return ans 350. Intersection of Two Arrays II和上题不同的是要返回所有的交集元素。原题1234Example 1:Input: nums1 = [1,2,2,1], nums2 = [2,2]Output: [2,2] 方法一：Counter实现了&amp;操作可以直接取交集。 1234def intersect(self, nums1, nums2): from collections import Counter a, b = map(Counter, (nums1, nums2)) return list((a &amp; b).elements()) 方法二：不使用Counter。 1234567891011def intersect(self, nums1, nums2): from collections import defaultdict counter = defaultdict(int) res = [] for num1 in nums1: counter[num1] += 1 for num2 in nums2: if counter[num2] != 0: res.append(num2) counter[num2] -= 1 return res 方法三：可以采用上题349的方法，只需要去掉last即可。 905. Sort Array By Parity将一个数组重新排列，是偶数在前奇数在后。原题123Input: [3,1,2,4]Output: [2,4,3,1]The outputs [4,2,3,1], [2,4,1,3], and [4,2,1,3] would also be accepted. 方法一：双指针。 123456789def sortArrayByParity(self, A): l, r = 0, len(A)-1 while l &lt; r: while l&lt;r and A[l]&amp;1==0: l += 1 while l&lt;r and A[r]&amp;1==1: r -= 1 A[l], A[r] = A[r], A[l] return A 方法二：列表生成式。 1234def sortArrayByParity(self, A): even = [num for num in A if num &amp; 1 == 0] odd = [num for num in A if num &amp; 1 == 1] return even + odd 922. Sort Array By Parity II输入一个奇数偶数数量相同的数组，返回下标和其对应的值都是奇数或偶数，即奇偶交叉。和905相似。原题方法一：使用切片的特性赋值。 12345def sortArrayByParityII(self, A): res = [None] * len(A) res[::2] = (num for num in A if num &amp; 1 == 0) res[1::2] = (num for num in A if num &amp; 1 == 1) return res 方法二：双指针。 12345678def sortArrayByParityII(self, A: 'List[int]') -&gt; 'List[int]': j = 1 for i in range(0, len(A), 2): if A[i] &amp; 1 == 1: while A[j] &amp; 1 == 1: j += 2 A[i], A[j] = A[j], A[i] return A 933. Number of Recent Calls输入一个时间t，返回3000毫秒内所有的请求个数。原题方法一：deque. 12345678910class RecentCounter: def __init__(self): self.q = collections.deque() def ping(self, t: 'int') -&gt; 'int': self.q.append(t) while self.q[0] &lt; t - 3000: self.q.popleft() return len(self.q) 937. Reorder Log Files按照规则将log文件排序。原题12Input: [&quot;a1 9 2 3 1&quot;,&quot;g1 act car&quot;,&quot;zo4 4 7&quot;,&quot;ab1 off key dog&quot;,&quot;a8 act zoo&quot;]Output: [&quot;g1 act car&quot;,&quot;a8 act zoo&quot;,&quot;ab1 off key dog&quot;,&quot;a1 9 2 3 1&quot;,&quot;zo4 4 7&quot;] 方法一：列表生成式。 12345def reorderLogFiles(self, logs): letter_logs = [l for l in logs if l.split()[1].isalpha()] digit_logs = [l for l in logs if not l.split()[1].isalpha()] letter_logs.sort(key=lambda x: x.split()[1:]) return letter_logs + digit_logs 方法二：sort. 12345def reorderLogFiles(self, logs: 'List[str]') -&gt; 'List[str]': def f(log): pk, text = log.split(" ", 1) return (0, text) if text[0].isalpha() else (1, ) return sorted(logs, key=f) 485. Max Consecutive Ones输入一个二进制数组，返回最大的连续1的长度。原题1234Input: [1,1,0,1,1,1]Output: 3Explanation: The first two digits or the last three digits are consecutive 1s. The maximum number of consecutive 1s is 3. 方法一：不使用标准库。末尾补0是因为，如果原数组末尾是1的情况下，还需要计算一次max的值。缺点是改变了原数组。也可以使用再计算一次的方式。 123456789def findMaxConsecutiveOnes(self, nums: 'List[int]') -&gt; 'int': ans = count = 0 for num in nums+[0]: if num == 1: count += 1 else: ans = max(ans, count) count = 0 return ans 方法二：使用groupby。 1234567def findMaxConsecutiveOnes(self, nums): from itertools import groupby max_con = 0 for d, group in groupby(nums): if d == 1: max_con = max(max_con, len(list(group))) return max_con 方法三：split。不过这个效率不高。 1234def findMaxConsecutiveOnes(self, nums): nums_str = ''.join(map(str, nums)) ones = nums_str.split('0') return len(max(ones)) 方法四：使用accumulate。Space-complex O(n)。 123def findMaxConsecutiveOnes(self, nums): from itertools import accumulate return max(accumulate(nums, lambda x, y: x+y if y==1 else y)) 1004. Max Consecutive Ones III与上题不同的是，有K次机会可以将0变成1. 原题12345Input: A = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K = 3Output: 10Explanation: [0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]Bolded numbers were flipped from 0 to 1. The longest subarray is underlined. 方法一：这题竞赛时没想出来，受上题影响，思路跑到了groupby那里，想着怎么分组后操作。实际上此题完全不同，应该使用滑动窗口。 123456789def longestOnes(self, A: List[int], K: int) -&gt; int: ans = i = 0 for j in range(len(A)): K -= A[j]==0 while K &lt; 0: K += A[i]==0 i += 1 ans = max(ans, j-i+1) return ans 946. Validate Stack Sequences给定一个入栈和出栈的顺序，判断是否最后可以清空该栈。原题123456789Input: pushed = [1,2,3,4,5], popped = [4,5,3,2,1]Output: trueExplanation: We might do the following sequence:push(1), push(2), push(3), push(4), pop() -&gt; 4,push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1Input: pushed = [1,2,3,4,5], popped = [4,3,5,1,2]Output: falseExplanation: 1 cannot be popped before 2. 123456789def validateStackSequences(self, pushed: 'List[int]', popped: 'List[int]') -&gt; 'bool': stack = [] j = 0 for num in pushed: stack.append(num) while stack and stack[-1] == popped[j]: stack.pop() j += 1 return j == len(popped) 496. Next Greater Element I找出数组nums2中对应的nums1元素的位置之后的第一个比nums1大的元素。nums1是nums2的子集，二者均无重复的元素。原题123456789101112Input: nums1 = [4,1,2], nums2 = [1,3,4,2].Output: [-1,3,-1]Explanation: For number 4 in the first array, you cannot find the next greater number for it in the second array, so output -1. For number 1 in the first array, the next greater number for it in the second array is 3. For number 2 in the first array, there is no next greater number for it in the second array, so output -1. Input: nums1 = [2,4], nums2 = [1,2,3,4].Output: [3,-1]Explanation: For number 2 in the first array, the next greater number for it in the second array is 3. For number 4 in the first array, there is no next greater number for it in the second array, so output -1. 方法一：暴力法，因为题中给了范围数组长度小于1000，所以也没有超时。 1234567891011121314def nextGreaterElement(self, nums1, nums2): res = [] for num1 in nums1: index = nums2.index(num1) if not nums2[index+1:]: res.append(-1) else: for num2 in nums2[index+1:]: if num2 &gt; num1: res.append(num2) break else: res.append(-1) return res 方法二：one-liner，生成器一开始想到了，没想到next函数还可以设默认值。 123def nextGreaterElement(self, nums1, nums2): return [next((y for y in nums2[nums2.index(x):] if y &gt; x), -1) for x in nums1] 方法三：Time: O(n). 1234567def nextGreaterElement(self, nums1, nums2): st, d = [], &#123;&#125; for n in nums2: while st and st[-1] &lt; n: d[st.pop()] = n st.append(n) return list(map(lambda x: d.get(x, -1), nums1)) 953. Verifying an Alien Dictionary判断一个字符串数组是否按照特定的字典顺序排序。原题123456789Input: words = [&quot;hello&quot;,&quot;leetcode&quot;], order = &quot;hlabcdefgijkmnopqrstuvwxyz&quot;Output: trueExplanation: As &apos;h&apos; comes before &apos;l&apos; in this language, then the sequence is sorted.Input: words = [&quot;word&quot;,&quot;world&quot;,&quot;row&quot;], order = &quot;worldabcefghijkmnpqstuvxyz&quot;Output: falseExplanation: As &apos;d&apos; comes after &apos;l&apos; in this language, then words[0] &gt; words[1], hence the sequence is unsorted.Input: words = [&quot;apple&quot;,&quot;app&quot;], order = &quot;abcdefghijklmnopqrstuvwxyz&quot;Output: falseExplanation: The first three characters &quot;app&quot; match, and the second string is shorter (in size.) According to lexicographical rules &quot;apple&quot; &gt; &quot;app&quot;, because &apos;l&apos; &gt; &apos;∅&apos;, where &apos;∅&apos; is defined as the blank character which is less than any other character (More info). 方法一：这道题想了很久，最后还是没有做出来，一开始想用zip来自己实现，也想到了sort，但是key里面的匿名函数一直没有想对，关键是二维数组也能排序这点没有想到。 123def isAlienSorted(self, words: 'List[str]', order: 'str') -&gt; 'bool': d = dict(zip(order, range(26))) return words == sorted(words, key=lambda w: [d[c] for c in w]) 方法二：传统方法，优点在于提前退出。 123456789101112131415def isAlienSorted(self, words: 'List[str]', order: 'str') -&gt; 'bool': d = dict(zip(order, range(26))) for i in range(len(words)-1): word1, word2 = words[i:i+2] for c1, c2 in zip(word1, word2): if c1 != c2: if d[c1] &gt; d[c2]: return False break else: if len(word1) &gt; len(word2): return False return True 506. Relative Ranks根据得分，返回排名。前三要用奖牌表示。原题1234Input: [5, 4, 3, 2, 1]Output: [&quot;Gold Medal&quot;, &quot;Silver Medal&quot;, &quot;Bronze Medal&quot;, &quot;4&quot;, &quot;5&quot;]Explanation: The first three athletes got the top three highest scores, so they got &quot;Gold Medal&quot;, &quot;Silver Medal&quot; and &quot;Bronze Medal&quot;. For the left two athletes, you just need to output their relative ranks according to their scores. 方法一：先生成一个排行榜单，再根据每个得分把排序映射上去。 12345def findRelativeRanks(self, nums): ranks = list(map(str,range(1, len(nums)+1))) ranks[:3] = ["Gold Medal", "Silver Medal", "Bronze Medal"] sorted_nums = sorted(nums, reverse=True) return [ranks[sorted_nums.index(num)] for num in nums] # slow 方法二：使用map映射。 1234567def findRelativeRanks(self, nums): ranks = list(map(str,range(1, len(nums)+1))) ranks[:3] = ["Gold Medal", "Silver Medal", "Bronze Medal"] sorted_nums = sorted(nums, reverse=True) # map_rank = &#123;num: ranks[i] for i, num in enumerate(sorted_nums)&#125; # return list(map(map_rank.get, nums)) return list(map(dict(zip(sorted_nums, ranks)).get, nums)) 532. K-diff Pairs in an Array找出差为k的不重复的成对元素的个数。原题1234Input: [3, 1, 4, 1, 5], k = 2Output: 2Explanation: There are two 2-diff pairs in the array, (1, 3) and (3, 5).Although we have two 1s in the input, we should only return the number of unique pairs. 方法一：Counter，一开始没想到，想sort或是set，然后实现不了。 12345678def findPairs(self, nums, k): from collections import Counter c = Counter(nums) res = 0 for num, count in c.items(): if (k == 0 and count &gt; 1) or (k &gt; 0 and num+k in c): res += 1 return res 961. N-Repeated Element in Size 2N Array找出2N长的数组中重复N次的数字，其它数字均只出现一次。此题不能用波义尔摩尔投票因为数量没有大于半数。原题12Input: [2,1,2,5,3,2]Output: 2 方法一：这题本意我看是哈希表，所以大部分答案都是Counter之类的，我看排行榜签名的Python选手也是这么用的，我是灵机一动一动动想出了一个数学方法。看上去迭代了两次数组，并使用了一些空间，但其实速度很快。 12def repeatedNTimes(self, A): return (sum(A)-sum(set(A))) // (len(A)//2-1) 方法二：其实是找重复的数字，那么就数量是一定的话，其他数字的相邻两位中可能会有重复，其他一种不重复情况，2234和2342。此方法不能用于169题，因为169题中的其它元素是可能重复的。 12345def repeatedNTimes(self, A: 'List[int]') -&gt; 'int': for i in range(2, len(A)): if A[i] == A[i-1] or A[i] == A[i-2]: return A[i] return A[0] 967. Numbers With Same Consecutive Differences根据规则生成一组数组，数字长度为N，每两位的差为K。原题方法一：迭代生成，其实此题本是一道动态规划题，但由于解法不是，暂时归到数组里。 1234567891011121314def numsSameConsecDiff(self, N, K): ans = &#123;x for x in range(1, 10)&#125; for _ in range(N-1): ans2 = set() for digit in ans: d = digit % 10 if d - K &gt;= 0: ans2.add(digit*10 + d - K) if d + K &lt;= 9: ans2.add(digit*10 + d + K) ans = ans2 if N == 1: ans.add(0) return list(ans) 方法二：简化。 123456def numsSameConsecDiff(self, N, K): ans = range(10) for _ in range(N-1): ans = &#123;x*10+y for x in ans for y in (x%10-K, x%10+K) if x and 0&lt;=y&lt;10&#125; return list(ans) 561. Array Partition I将数组两两分成一组，累加每组的最小值，使之尽量大。原题1234Input: [1,4,3,2]Output: 4Explanation: n is 2, and the maximum sum of pairs is 4 = min(1, 2) + min(3, 4). 12def arrayPairSum(self, nums): return sum(sorted(nums)[::2]) 566. Reshape the Matrix改变矩阵的形状，如果元素超出或不足，返回原矩阵。原题123456789Input: nums = [[1,2], [3,4]]r = 1, c = 4Output: [[1,2,3,4]]Explanation:The row-traversing of nums is [1,2,3,4]. The new reshaped matrix is a 1 * 4 matrix, fill it row by row by using the previous list. 方法一：扁平化后重组。 123456def matrixReshape(self, nums, r, c): a = [x for row in nums for x in row] n = len(a) if r*c != n: return nums return [a[i*c:i*c+c] for i in range(r)] 方法二：使用itertools. 123456def matrixReshape(self, nums, r, c): if r*c != len(nums)*len(nums[0]): return nums from itertools import islice, chain it = chain(*nums) return [list(islice(it, c)) for _ in range(r)] 575. Distribute Candies给姐姐弟弟分糖，两人数量一样，保证姐姐的种类最多，求姐姐最多能分到多少种。原题123456Input: candies = [1,1,2,2,3,3]Output: 3Explanation:There are three different kinds of candies (1, 2 and 3), and two candies for each kind.Optimal distribution: The sister has candies [1,2,3] and the brother has candies [1,2,3], too. The sister has three different kinds of candies. 12def distributeCandies(self, candies): return min(len(candies)//2, len(set(candies))) 594. Longest Harmonious Subsequence最长的和谐子数组，即元素的最大值和最小值正好相差一的子数组，元素顺序无关，求最大子数组长度。原题123Input: [1,3,2,2,5,2,3,7]Output: 5Explanation: The longest harmonious subsequence is [3,2,2,2,3]. 方法一：开始想错了，后来发现子数组只能包含两个元素。 12345678def findLHS(self, nums): from collections import Counter res = 0 c = Counter(nums) for num, count in c.items(): sum_count = count+c[num+1] if c[num+1] else 0 res = max(res, sum_count) return res 方法二：one-liner. 12345def findLHS(self, nums): from collections import Counter c = Counter(nums) return max([count+c[num+1] for num, count in c.items() if num+1 in c] or [0]) 598. Range Addition II这题看上去挺长，其实抽象起来很简单，把整个矩阵想象成一个积木，然后每次往上叠加，每次叠放的矩形都会和左上角对齐，所以最后完成的时候，左上角的一小块一定是最“厚”的，问题就变成和左上一样的厚度的面积。实际上等于叠放的所有矩形的最小长度和最小宽度的乘积。原题123456789101112131415161718192021Input: m = 3, n = 3operations = [[2,2],[3,3]]Output: 4Explanation: Initially, M = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]After performing [2,2], M = [[1, 1, 0], [1, 1, 0], [0, 0, 0]]After performing [3,3], M = [[2, 2, 1], [2, 2, 1], [1, 1, 1]]So the maximum integer in M is 2, and there are four of it in M. So return 4. 12345def maxCount(self, m, n, ops): if not ops: return m*n length, width = list(zip(*ops)) return min(length) * min(width) 599. Minimum Index Sum of Two Lists找出两个人共同最喜欢的餐厅。如果有多个输出多个。原题1234Input:[&quot;Shogun&quot;,&quot;Tapioca Express&quot;,&quot;Burger King&quot;,&quot;KFC&quot;][&quot;Piatti&quot;,&quot;The Grill at Torrey Pines&quot;,&quot;Tapioca Express&quot;,&quot;Shogun&quot;]Output: [&apos;Shogun&apos;, &apos;Tapioca Express&apos;] 方法一：这里做了一个优化，以原list1的顺序输出数组，如果索引太大超出了最小索引和，这样即使是map2使用第一个元素也无法满足条件，直接退出。 1234567891011121314def findRestaurant(self, list1, list2): map2 = &#123;x: i for i, x in enumerate(list2)&#125; res, min_sum = [], float('inf') for i, rest in enumerate(list1): # optimize if i &gt; min_sum: break if rest in map2: if i+map2[rest] &lt; min_sum: res = [rest] min_sum = i+map2[rest] elif i+map2[rest] == min_sum: res += [rest] return res 605. Can Place Flowers是否可以种下给定数量的花。两颗花不能挨着，给定的数组中满足这一条件。原题12Input: flowerbed = [1,0,0,0,1], n = 2Output: False 123456789def canPlaceFlowers(self, flowerbed, n): plots = [0] + flowerbed + [0] p = 1 while p &lt;= len(flowerbed) and n &gt; 0: if plots[p] == 0 and plots[p-1] == 0 and plots[p+1] == 0: plots[p] = 1 n -= 1 p += 1 return n == 0 974. Subarray Sums Divisible by K连续的子数组的和能被K整除的个数。原题1234Input: A = [4,5,0,-2,-3,1], K = 5Output: 7Explanation: There are 7 subarrays with a sum divisible by K = 5:[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3] 方法一：这道题没有在规定时间内完成，此答案参考了排名第一的大佬，然后使用defaultdict进行了改进。 这里有一个详细的解答。不过那里给出的答案没有这个简单，不过思路大体相同。 假设通过sum(i, j)表示切片[i: j]的总和，如果sum(i, j)能被K整除，则说明sum(0, j) - sum(0, i)也能被K整除，即对sum(0, j) % K == sum(0, i) % K。下面的解法使用一个字典记录了余数的个数。当余数第二次出现的时候，开始计数，但0的时候除外，因为整除了就产生结果了。 然后再看累加的方法以下文第3行log为例，mod又为4，这时它和之前余数为4的的数组都可以产生一个结果即[4, 5, 0] - [4] = [5, 0] 和[4 , 5, 0] - [4, 5] = [0]所以要累加原来的和。 1234567891011121314def subarraysDivByK(self, A, K): from collections import defaultdict m = defaultdict(int) m[0] = 1 total, ans = 0, 0 for i, num in enumerate(A): total += num sum_p = total % K ans += m[sum_p] m[sum_p] += 1 print('sum subarray &#123;&#125; total is &#123;&#125;, mod is &#123;&#125;, ans is &#123;&#125;, &#123;&#125;'.format( A[:i+1], total, sum_p, ans, m )) return ans 123456sum subarray [4] total is 4, mod is 4, ans is 0, defaultdict(&lt;class &apos;int&apos;&gt;, &#123;0: 1, 4: 1&#125;)sum subarray [4, 5] total is 9, mod is 4, ans is 1, defaultdict(&lt;class &apos;int&apos;&gt;, &#123;0: 1, 4: 2&#125;)sum subarray [4, 5, 0] total is 9, mod is 4, ans is 3, defaultdict(&lt;class &apos;int&apos;&gt;, &#123;0: 1, 4: 3&#125;)sum subarray [4, 5, 0, -2] total is 7, mod is 2, ans is 3, defaultdict(&lt;class &apos;int&apos;&gt;, &#123;0: 1, 4: 3, 2: 1&#125;)sum subarray [4, 5, 0, -2, -3] total is 4, mod is 4, ans is 6, defaultdict(&lt;class &apos;int&apos;&gt;, &#123;0: 1, 4: 4, 2: 1&#125;)sum subarray [4, 5, 0, -2, -3, 1] total is 5, mod is 0, ans is 7, defaultdict(&lt;class &apos;int&apos;&gt;, &#123;0: 2, 4: 4, 2: 1&#125;) 643. Maximum Average Subarray I最大的连续的长度为k的子数组的平均值。原题123Input: [1,12,-5,-6,50,3], k = 4Output: 12.75Explanation: Maximum average is (12-5-6+50)/4 = 51/4 = 12.75 方法一：参考了stefen大神的答案，自己写的滑动窗口居然超时了。accumulate也不是想不到，此答案厉害的地方在于 补0 和map操作。像这种固定长度的滑动窗口使用补0的accumulate，可以用到其他的题上。 123def findMaxAverage(self, nums, k): sums = [0] + list(itertools.accumulate(nums)) return max(map(operator.sub, sums[k:], sums)) / k 645. Set Mismatch1~n数组中包含一个重复的元素和一个缺失的元素。找出这两个元素。原题12Input: nums = [1,2,2,4]Output: [2,3] 方法一：开始还想着用Counter实现，有些愚蠢。 123def findErrorNums(self, nums): diff_sum = sum(set(nums)) return sum(nums)-diff_sum, sum(range(1, len(nums)+1))-diff_sum 方法二：在原数组元素*-1记录。空间复杂度为常数，但是改变了原数组，时间复杂度稍微高一点，因为迭代两次。 12345678910111213def findErrorNums(self, nums: 'List[int]') -&gt; 'List[int]': dup, miss = -1, 1 for num in nums: if nums[abs(num)-1] &lt; 0: dup = abs(num) else: nums[abs(num)-1] *= -1 for i in range(len(nums)): if nums[i] &gt; 0: miss = i + 1 return dup, miss 方法三：XOR。 661. Image Smoother使图片平滑模糊，一个矩阵使每个点的值为周围所有点的平均值，包括自己。原题123456789101112Input:[[1,1,1], [1,0,1], [1,1,1]]Output:[[0, 0, 0], [0, 0, 0], [0, 0, 0]]Explanation:For the point (0,0), (0,2), (2,0), (2,2): floor(3/4) = floor(0.75) = 0For the point (0,1), (1,0), (1,2), (2,1): floor(5/6) = floor(0.83333333) = 0For the point (1,1): floor(8/9) = floor(0.88888889) = 0 方法一：参考了评论区一位朋友的写法，不过效率不是很高，800ms，Solution给出的方法也是这个速度，看来如果优化的话，可能使用numpy会好一点。 1234567891011def imageSmoother(self, M): import itertools R, C = len(M), len(M[0]) res = [[0]*C for _ in range(R)] offset = list(itertools.product([-1, 0, 1], [-1, 0, 1])) for i in range(R): for j in range(C): points = [M[i+x][j+y] for x, y in offset if 0&lt;=i+x&lt;R and 0&lt;=j+y&lt;C] res[i][j] = sum(points) // len(points) return res 665. Non-decreasing Array判断是否改变一个数，可使其变成单调递增数组。原题123Input: [4,2,3]Output: TrueExplanation: You could modify the first 4 to 1 to get a non-decreasing array. 12345678910def checkPossibility(self, nums): n = len(nums) p = None for i in range(n-1): if nums[i] &gt; nums[i+1]: if p is not None: return False p = i return (not p) or p == n-2 or nums[p-1] &lt;= nums[p+1] or \ nums[p] &lt;= nums[p+2] If p = 0, then we could make the array good by setting A[p] = A[p+1] if p = len(A) - 2, then we could make the array good by setting A[p+1] = A[p] Otherwise, A[p-1], A[p], A[p+1], A[p+2] all exist, and: change A[p] to be between A[p-1] and A[p+1] if possible, or: [4, 8, 6] change A[p+1] to be between A[p] and A[p+2] if possible. [4, 5, 3, 6] 674. Longest Continuous Increasing Subsequence最长连续递增子数组长度。原题1234Input: [1,3,5,4,7]Output: 3Explanation: The longest continuous increasing subsequence is [1,3,5], its length is 3. Even though [1,3,5,7] is also an increasing subsequence, it&apos;s not a continuous one where 5 and 7 are separated by 4. 12345678def findLengthOfLCIS(self, nums: 'List[int]') -&gt; 'int': ans = anchor = 0 for i in range(len(nums)): if i and nums[i] &lt;= nums[i-1]: anchor = i else: ans = max(ans, i-anchor+1) return ans 682. Baseball Game棒球游戏，给了一些积分规则。原题12345678Input: [&quot;5&quot;,&quot;2&quot;,&quot;C&quot;,&quot;D&quot;,&quot;+&quot;]Output: 30Explanation: Round 1: You could get 5 points. The sum is: 5.Round 2: You could get 2 points. The sum is: 7.Operation 1: The round 2&apos;s data was invalid. The sum is: 5. Round 3: You could get 10 points (the round 2&apos;s data has been removed). The sum is: 15.Round 4: You could get 5 + 10 = 15 points. The sum is: 30. 123456789101112def calPoints(self, ops): stack = [] for op in ops: if op == 'C': stack.pop() elif op == 'D': stack.append(stack[-1]*2) elif op == '+': stack.append(stack[-1] + stack[-2]) else: stack.append(int(op)) return sum(stack) 690. Employee Importance员工重要值。原题1234Input: [[1, 5, [2, 3]], [2, 3, []], [3, 3, []]], 1Output: 11Explanation:Employee 1 has importance value 5, and he has two direct subordinates: employee 2 and employee 3. They both have importance value 3. So the total importance value of employee 1 is 5 + 3 + 3 = 11. 方法一：iteratively. 12345678def getImportance(self, employees, id): emp_dict = &#123;ep.id: (ep.importance, ep.subordinates) for ep in employees&#125; res, stack = 0, [id] while stack: value, subs = emp_dict.get(stack.pop()) res += value stack += subs return res 方法二：recursively. 12345def getImportance(self, employees, id): emp_dict = &#123;ep.id: (ep.importance, ep.subordinates) for ep in employees&#125; def dfs(pk): return emp_dict[pk][0] + sum(dfs(sub) for sub in emp_dict[pk][1]) return dfs(id) 697. Degree of an Arraydegree这里表示数组最常见的元素的频率，然后在连续的子数组中寻找同样的degree，求最小子数组的长度。原题1234567Input: [1, 2, 2, 3, 1]Output: 2Explanation: The input array has a degree of 2 because both elements 1 and 2 appear twice.Of the subarrays that have the same degree:[1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2]The shortest length is 2. So return 2. 方法一：使用Counter 和index. 600ms有点慢。 12345678910111213def findShortestSubArray(self, nums): from collections import Counter c = Counter(nums) degree = None res = n = len(nums) for num, count in c.most_common(): if degree and count != degree: break min_len = n - nums[::-1].index(num) - 1 - nums.index(num) + 1 # print(min_len, num) res = min(res, min_len) degree = count return res 方法二：使用dict记录索引。 1234567891011121314def findShortestSubArray(self, nums): c = collections.defaultdict(int) left, right = &#123;&#125;, &#123;&#125; for i, num in enumerate(nums): if num not in left: left[num] = i right[num] = i c[num] += 1 res = len(nums) degree = max(c.values()) for num, count in c.items(): if count == degree: res = min(res, right[num]-left[num]+1) return res 方法三：使用Counter + dict. 1234567891011121314def findShortestSubArray(self, nums: 'List[int]') -&gt; 'int': c = collections.Counter(nums) left, right = &#123;&#125;, &#123;&#125; for i, num in enumerate(nums): if num not in left: left[num] = i right[num] = i degree, res = 0, len(nums) for num, count in c.most_common(): if degree and count != degree: break res = min(res, right[num]-left[num]+1) degree = count return res 724. Find Pivot Index找到中心索引，使得左右两边和相等。左右求和时均不包含该索引。原题12345678910Input: nums = [1, 7, 3, 6, 5, 6]Output: 3Explanation: The sum of the numbers to the left of index 3 (nums[3] = 6) is equal to the sum of numbers to the right of index 3.Also, 3 is the first index where this occurs.Input:nums = [1,0]Output: 0 方法一：指针。 123456789def pivotIndex(self, nums): left, right, i = 0, sum(nums), 0 while i &lt; len(nums): left += nums[i-1] if i &gt; 0 else 0 right -= nums[i] if left == right: return i i += 1 return -1 方法二：不使用指针。 1234567def pivotIndex(self, nums): S, left = sum(nums), 0 for i, num in enumerate(nums): if left == S-left-num: return i left += num return -1 985. Sum of Even Numbers After Queries计算Queries后，累加所有的偶数。原题12345678Input: A = [1,2,3,4], queries = [[1,0],[-3,1],[-4,0],[2,3]]Output: [8,6,2,4]Explanation: At the beginning, the array is [1,2,3,4].After adding 1 to A[0], the array is [2,2,3,4], and the sum of even values is 2 + 2 + 4 = 8.After adding -3 to A[1], the array is [2,-1,3,4], and the sum of even values is 2 + 4 = 6.After adding -4 to A[0], the array is [-2,-1,3,4], and the sum of even values is -2 + 4 = 2.After adding 2 to A[3], the array is [-2,-1,3,6], and the sum of even values is -2 + 6 = 4. 1234567891011def sumEvenAfterQueries(self, A: 'List[int]', queries: 'List[List[int]]') -&gt; 'List[int]': res = [] sum_even = sum(x for x in A if x &amp; 1 == 0) for v, i in queries: if A[i] &amp; 1 == 0: sum_even -= A[i] A[i] += v if A[i] &amp; 1 == 0: sum_even += A[i] res.append(sum_even) return res 986. Interval List Intersections两个区间列表求相交。原题 123Input: A = [[0,2],[5,10],[13,23],[24,25]], B = [[1,5],[8,12],[15,24],[25,26]]Output: [[1,2],[5,5],[8,10],[15,23],[24,24],[25,25]]Reminder: The inputs and the desired output are lists of Interval objects, and not arrays or lists. 12345678910111213def intervalIntersection(self, A: 'List[Interval]', B: 'List[Interval]') -&gt; 'List[Interval]': i = j = 0 res = [] while i &lt; len(A) and j &lt; len(B): lo = max(A[i].start, B[j].start) hi = min(A[i].end, B[j].end) if lo &lt;= hi: res.append(Interval(lo, hi)) if A[i].end &gt; B[j].end: j += 1 else: i += 1 return res 733. Flood Fill“洪水填充”，给定一个二维数组表示一张图片的像素，然后指定一个点和一个颜色，将这个点和上下左右四个点使用新的颜色填充，和这个点原来相同的颜色的点也受到影响，依次扩散，返回新的图片数组。原题123456789Input: image = [[1,1,1],[1,1,0],[1,0,1]]sr = 1, sc = 1, newColor = 2Output: [[2,2,2],[2,2,0],[2,0,1]]Explanation: From the center of the image (with position (sr, sc) = (1, 1)), all pixels connected by a path of the same color as the starting pixel are colored with the new color.Note the bottom corner is not colored 2, because it is not 4-directionally connectedto the starting pixel. 方法一：dfs. 需要注意的是，如果目标点与颜色相同，则原图不变。 1234567891011121314151617def floodFill(self, image, sr, sc, newColor): rows, cols = len(image), len(image[0]) old_val = image[sr][sc] def spread(x, y): if old_val == image[x][y]: image[x][y] = newColor if x-1 &gt;= 0: spread(x-1, y) if x+1 &lt; rows: spread(x+1, y) if y-1 &gt;= 0: spread(x, y-1) if y+1 &lt; cols: spread(x, y+1) if old_val != newColor: spread(sr, sc) return image 方法二：上述方法的变形。看起来更优雅。 1234567891011def floodFill(self, image, sr, sc, newColor): def dfs(x, y): image[x][y] = newColor for x, y in ((x-1, y), (x+1, y), (x, y+1), (x, y-1)): if 0&lt;=x&lt;rows and 0&lt;=y&lt;cols and image[x][y]==old_val: dfs(x, y) old_val, rows, cols = image[sr][sc], len(image), len(image[0]) if old_val != newColor: dfs(sr, sc) return image 747. Largest Number At Least Twice of Others最大的数是否大于等于所有其它数的两倍。原题1234Input: nums = [3, 6, 1, 0]Output: 1Explanation: 6 is the largest integer, and for every other number in the array x,6 is more than twice as big as x. The index of value 6 is 1, so we return 1. 12345def dominantIndex(self, nums: 'List[int]') -&gt; 'int': max_v = max(nums) if all(max_v &gt;= 2*x for x in nums if x!=max_v): return nums.index(max_v) return -1 766. Toeplitz MatrixToeplitz矩阵，即对角矩阵，斜角具有相同的值，判断一个矩阵是否是对角矩阵。原题1234567891011Input:matrix = [ [1,2,3,4], [5,1,2,3], [9,5,1,2]]Output: TrueExplanation:In the above grid, the diagonals are:&quot;[9]&quot;, &quot;[5, 5]&quot;, &quot;[1, 1, 1]&quot;, &quot;[2, 2, 2]&quot;, &quot;[3, 3]&quot;, &quot;[4]&quot;.In each diagonal all elements are the same, so the answer is True. 方法一：嵌套循环。 1234def isToeplitzMatrix(self, matrix: 'List[List[int]]') -&gt; 'bool': return all(x==0 or y==0 or matrix[x-1][y-1]==val for x, rows in enumerate(matrix) for y, val in enumerate(rows)) 方法二：切片，与上述方法在效率空间上没有差距，更喜欢这个方法。 123def isToeplitzMatrix(self, matrix: 'List[List[int]]') -&gt; 'bool': return all(matrix[i][1:]==matrix[i-1][:-1] for i in range(1, len(matrix))) 830. Positions of Large Groups根据指定字符串分组，超过三个元素的称为大组，求所有大组的位置。原题12Input: &quot;abcdddeeeeaabbbcd&quot;Output: [[3,5],[6,9],[12,14]] 方法一：groupby. 123456789def largeGroupPositions(self, S: 'str') -&gt; 'List[List[int]]': groups = itertools.groupby(S) index, ans = 0, [] for s, group in groups: count = len(list(group)) if count &gt;= 3: ans.append([index, index+count-1]) index += count return ans 方法二：two pointers. 123456789def largeGroupPositions(self, S: 'str') -&gt; 'List[List[int]]': i = 0 # start of each group ans = [] for j in range(len(S)): if j == len(S)-1 or S[j] != S[j+1]: if j - i &gt;= 2: ans.append([i, j]) i = j + 1 return ans 832. Flipping an Image水平翻转一张图片并反转(invert). 原题1234Input: [[1,1,0],[1,0,1],[0,0,0]]Output: [[1,0,0],[0,1,0],[1,1,1]]Explanation: First reverse each row: [[0,1,1],[1,0,1],[0,0,0]].Then, invert the image: [[1,0,0],[0,1,0],[1,1,1]] 12def flipAndInvertImage(self, A: 'List[List[int]]') -&gt; 'List[List[int]]': return [[x ^ 1 for x in reversed(row)] for row in A] 840. Magic Squares In Grid找出grid中数独的个数。原题12345678910111213141516Input: [[4,3,8,4], [9,5,1,9], [2,7,6,2]]Output: 1Explanation: The following subgrid is a 3 x 3 magic square:438951276while this one is not:384519762In total, there is only one magic square inside the given grid. 方法一：Brute Force. 12345678910111213141516171819202122232425def numMagicSquaresInside(self, grid: 'List[List[int]]') -&gt; 'int': digits = set(range(1, 10)) ans = 0 def is_sudoku(matrix): if matrix[1][1] != 5: # for optimization return False if set(sum(matrix, [])) != digits: return False if &#123;sum(row) for row in matrix&#125; != &#123;15&#125;: return False if &#123;sum(col) for col in zip(*matrix)&#125; != &#123;15&#125;: return False if matrix[0][0] + matrix[1][1] + matrix[2][2] != 15 or \ matrix[2][0] + matrix[1][1] + matrix[0][2] != 15: return False return True for i in range(len(grid)-2): for j in range(len(grid[0])-2): matrix = [rows[j:j+3] for rows in grid[i:i+3]] # print(matrix) if is_sudoku(matrix): ans += 1 return ans 方法二：参考了大神的解法。外层循环中只把左上角的点传入子方法进行判断，并在外循环判断中心点是否为5； 另外一个规律就是，满足条件数独的9宫格中，4个角都是偶数，4个边都是奇数，并且沿着一个方向必然是’43816729’的正序或者倒序。所以当左上角为偶数时，并满足顺序要求，另两个条件也自然满足了。 1234567891011def numMagicSquaresInside(self, g: 'List[List[int]]') -&gt; 'int': def is_sudoku(i, j): # clockwise begin i, j s = ''.join(str(g[i + x//3][j + x%3]) for x in (0, 1, 2, 5, 8, 7, 6, 3)) return g[i][j] &amp; 1 == 0 and ( s in '43816729'*2 or s in '43816729'[::-1]*2) return sum(is_sudoku(i, j) for i in range(len(g)-2) for j in range(len(g[0])-2) if g[i+1][j+1] == 5) 849. Maximize Distance to Closest Person一排电影院座位，离人的最远距离。数组中必含有一个1和0。原题123456Input: [1,0,0,0,1,0,1]Output: 2Explanation: If Alex sits in the second open seat (seats[2]), then the closest person has distance 2.If Alex sits in any other open seat, the closest person has distance 1.Thus, the maximum distance to the closest person is 2. 方法一：groupby。需要注意两个地方：一个是group是一个生成器，必须转成list才可以求长度；另一个地方是reversed(seats)也是一个生成器，所以这里要用切片。 1234567def maxDistToClosest(self, seats: 'List[int]') -&gt; 'int': ans = 0 groups = itertools.groupby(seats) for seat, group in groups: if not seat: ans = max(ans, (len(list(group))+1) // 2) return max(ans, seats.index(1), seats[::-1].index(1)) 方法二：two pointers. 在第一个1出现之前长度都是j。直到第二个1出现时，计算方式变为平均数。这里使用i = j + 1而不是i = j是因为有根据i判断的条件，在计算平均距离时又将其加了回来。最后的len(seats)-i是为了[1, 0, 0, 0]末尾的0作结算。 123456789101112def maxDistToClosest(self, seats: 'List[int]') -&gt; 'int': ans = i = 0 for j in range(len(seats)): # print(j, i, ans) if seats[j] == 1: dis = (j - i + 1) // 2 if i == 0: dis = j ans = max(ans, dis) i = j + 1 # print(ans) return max(ans, len(seats)-i) 方法三：方法二的简洁写法。 1234567def maxDistToClosest(self, seats: 'List[int]') -&gt; 'int': ans = i = 0 for j in range(len(seats)): if seats[j] == 1: ans = max(ans, ((j-i+1)//2, j)[i==0]) i = j + 1 return max(ans, len(seats)-i) 867. Transpose Matrix转置矩阵。原题12Input: [[1,2,3],[4,5,6],[7,8,9]]Output: [[1,4,7],[2,5,8],[3,6,9]] 方法一：zip。 这里testcase并没有检测其中的元素是否为list。所以不需要转换。 12def transpose(self, A: 'List[List[int]]') -&gt; 'List[List[int]]': return list(zip(*A)) 方法二：zip原理。 12def transpose(self, A: 'List[List[int]]') -&gt; 'List[List[int]]': return list(map(lambda *arg: arg, *A)) 方法三：列表生成式。 123def transpose(self, A: 'List[List[int]]') -&gt; 'List[List[int]]': return [[A[i][j] for i in range(len(A))] for j in range(len(A[0]))] 方法四：numpy. 123def transpose(self, A): import numpy as np return np.transpose(A).tolist() 888. Fair Candy Swap公平的糖果交换。两个人有很多糖果酒吧，交换其中一间使，糖果相同，可能有多个答案，返回任意一个。原题12Input: A = [1,1], B = [2,2]Output: [1,2] 方法一：Solution中的答案。 123456def fairCandySwap(self, A: 'List[int]', B: 'List[int]') -&gt; 'List[int]': diff = (sum(B) - sum(A)) // 2 set_b = set(B) for a in A: if diff + a in set_b: return a, diff + a 896. Monotonic Array判断一个数组是不是单调递增或递减。原题12345Input: [1,2,2,3]Output: trueInput: [6,5,4,4]Output: true 方法一：迭代两次。但是由于是生成器，平均效率比下面要高。 123def isMonotonic(self, A: 'List[int]') -&gt; 'bool': return all(A[i] &lt;= A[i+1] for i in range(len(A)-1)) or \ all(A[i] &gt;= A[i+1] for i in range(len(A)-1)) 方法二：迭代一次。 12345678910def isMonotonic(self, A: 'List[int]') -&gt; 'bool': increasing = decreasing = True for i in range(len(A)-1): if A[i+1] &gt; A[i]: decreasing = False if A[i+1] &lt; A[i]: increasing = False if not decreasing and not increasing: return False return True 方法三：python2的一种写法。 12def isMonotonic(self, A): return not &#123;cmp(i, j) for i, j in zip(A, A[1:])&#125; &gt;= &#123;1, -1&#125; 977. Squares of a Sorted Array求一个有序数组，平方后的有序结果。原题12Input: [-4,-1,0,3,10]Output: [0,1,9,16,100] 方法一：双指针填充数组。 123456789101112def sortedSquares(self, A: 'List[int]') -&gt; 'List[int]': answer = [0] * len(A) l, r = 0, len(A) - 1 while l &lt;= r: left, right = abs(A[l]), abs(A[r]) if left &gt; right: answer[r - l] = left * left l += 1 else: answer[r - l] = right * right r -= 1 return answer 941. Valid Mountain Array验证是否是山峰数组，前段单调增（不重复），后段单调减，必须是单峰值。原题12Input: [0,3,2,1]Output: true 方法一：传统迭代方式。 123456789101112def validMountainArray(self, A: 'List[int]') -&gt; 'bool': increasing = True for i in range(len(A)-1): if A[i] == A[i+1]: return False if A[i] &gt; A[i+1]: increasing = False if not increasing and (A[i] &lt; A[i+1] or i ==0): return False if i == len(A)-2 and increasing: return False return len(A) &gt;= 3 方法二：这个方法挺新颖，根据值来递增索引。中途暂停一下判断峰值是否在首位点。 123456789def validMountainArray(self, A: 'List[int]') -&gt; 'bool': l, r = 0, len(A)-1 while l &lt; r and A[l] &lt; A[l+1]: l += 1 if l==0 or l == r: return False while l &lt; r and A[l] &gt; A[l+1]: l += 1 return l == r 方法三：Lee神的双指针，想象两个人同时从左右两边爬山，最终是否相遇在一点。 12345def validMountainArray(self, A: 'List[int]') -&gt; 'bool': l, r, n = 0, len(A)-1, len(A) while l &lt; r and A[l] &lt; A[l+1]: l += 1 while r &gt; 0 and A[r] &lt; A[r-1]: r -= 1 return 0 &lt; l==r &lt; n-1 942. DI String Match根据一个”IDID”字符串（I表示增加，D表示减少）生成一个数组，数组元素不能重复，答案不唯一。原题12Input: &quot;IDID&quot;Output: [0,4,1,3,2] 1234567891011def diStringMatch(self, S: 'str') -&gt; 'List[int]': l = r = 0 ans = [0] for s in S: if s == 'I': r += 1 ans.append(r) else: l -= 1 ans.append(l) return [x-l for x in ans] 994. Rotting Oranges腐烂的橘子，1表示新鲜，2表示腐烂，每分钟腐烂的会传染给四周上下左右的橘子，问所有的橘子腐烂最少需要几分钟。原题 方法一：竞赛时虽然做出来了，但有些点没想出来，其实是BFS，这样一想退出条件就很清楚了。 12345678910111213141516171819def orangesRotting(self, g: 'List[List[int]]') -&gt; 'int': R, C = len(g), len(g[0]) rotted = ((x, y, 0) for x in range(R) for y in range(C) if g[x][y]==2) q = collections.deque(rotted) def to_rot(x, y): for x, y in ((x-1, y), (x, y-1), (x+1, y), (x, y+1)): if 0&lt;=x&lt;R and 0&lt;=y&lt;C and g[x][y]==1: yield x, y d = 0 while q: r, c, d = q.popleft() for sr, sc in to_rot(r, c): g[sr][sc] = 2 q.append((sr, sc, d+1)) if 1 in sum(g, []): return -1 return d 1002. Find Common Characters在给定的单词列表中找到公共字符。原题12Input: [&quot;bella&quot;,&quot;label&quot;,&quot;roller&quot;]Output: [&quot;e&quot;,&quot;l&quot;,&quot;l&quot;] 1234def commonChars(self, A: List[str]) -&gt; List[str]: from collections import Counter from functools import reduce return list(reduce(lambda x, y: x &amp; y, map(Counter, A)).elements()) 1007. Minimum Domino Rotations For Equal Row旋转最小次，是上下的多米诺骨牌有一行全部相同。原题 方法一：竞赛时写的Brute Force.当时觉得炒鸡硬核。 12345678def minDominoRotations(self, A: List[int], B: List[int]) -&gt; int: ans = reduce(lambda x, y: set(x) &amp; set(y), zip(A, B)) if not ans: return -1 else: a = set(ans).pop() dul = sum(a==c==d for c, d in zip(A, B)) return min(A.count(a), B.count(a)) - dul 方法二：Lee神的方法。有个地方想错了，想要算出重复的值，实际上就是求非目标值的最小值就行了。 1234567def minDominoRotations(self, A: List[int], B: List[int]) -&gt; int: ans = reduce(lambda x, y: x &amp; y, map(set, zip(A, B))) if not ans: return -1 else: a = ans.pop() return min(len(A)-A.count(a), len(B)-B.count(a)) 48. Rotate Image矩阵顺时针旋转90度。原题12345678910111213Given input matrix = [ [1,2,3], [4,5,6], [7,8,9]],rotate the input matrix in-place such that it becomes:[ [7,4,1], [8,5,2], [9,6,3]] 方法一：使用zip。 12def rotate(self, matrix: List[List[int]]) -&gt; None: matrix[:] = list(zip(*reversed(matrix))) 方法二：通用写法。 12345def rotate(self, matrix: List[List[int]]) -&gt; None: matrix.reverse() for i in range(len(matrix)): for j in range(i+1, len(matrix[0])): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] 方法三：找到四个点，直接互换。 123456def rotate(self, A: List[List[int]]) -&gt; None: n = len(A) for i in range(n//2): for j in range(n-n//2): A[i][j], A[~j][i], A[~i][~j], A[j][~i] = \ A[~j][i], A[~i][~j], A[j][~i], A[i][j] 695. Max Area of Island最大的岛屿面积。原题方法一：dfs. 1234567891011121314def maxAreaOfIsland(self, grid: List[List[int]]) -&gt; int: R, C = len(grid), len(grid[0]) area, seen = 0, set() def spread(i, j): if not (0&lt;=i&lt;R and 0&lt;=j&lt;C and (i, j) not in seen and grid[i][j]): return 0 seen.add((i, j)) surrounds = ((i-1, j), (i+1, j), (i, j-1), (i, j+1)) return 1 + sum(map(lambda x: spread(x[0], x[1]), surrounds)) return max(spread(i, j) for i in range(R) for j in range(C)) 1020. Partition Array Into Three Parts With Equal Sum一个数组是否可以分成三个和相同的部分。原题123Input: [0,2,1,-6,6,-7,9,1,2,0,1]Output: trueExplanation: 0 + 2 + 1 = -6 + 6 - 7 + 9 + 1 = 2 + 0 + 1 方法一：竞赛时写的Time: O(n²)的方法。 12345678def canThreePartsEqualSum(self, A: List[int]) -&gt; bool: a = list(itertools.accumulate(A)) n, a_set = len(a), set(a) for i, total in enumerate(a): if total==a[-1]//3 and total*2 in a_set: if n-1-a[::-1].index(total*2) &gt; i: return True return False 方法二：其实不需要遍历。每部分的和可以通过总和/3得到。比如每部分和为3，只要找到3和6，并且3在6的左边。 12345678910111213141516def canThreePartsEqualSum(self, A: List[int]) -&gt; bool: a = list(itertools.accumulate(A)) total = sum(A) if total % 3 != 0: return False one = total // 3 two = one * 2 if one in a: l_index = a.index(one) else: return False if two in a: r_index = len(A) - 1 - a[::-1].index(two) else: return False return l_index &lt; r_index 1021. Best Sightseeing Pair得分最高的两个景点。原题两个景点之间有距离。 123Input: [8,1,5,2,6]Output: 11Explanation: i = 0, j = 2, A[i] + A[j] + i - j = 8 + 5 + 0 - 2 = 11 方法一：cur保存着一个上一次最好的景点。 123456def maxScoreSightseeingPair(self, A: List[int]) -&gt; int: cur = res = 0 for a in A: res = max(res, cur + a) cur = max(cur, a) - 1 return res 1029. Binary Prefix Divisible By 5二进制前缀能否被5整除。原题12Input: [0,1,1,1,1,1]Output: [true,false,false,false,true,false] 方法一：首次AC的方法。 1234567def prefixesDivBy5(self, A: List[int]) -&gt; List[bool]: num, ans = 0, [] for d in A: num &lt;&lt;= 1 num |= d ans.append(not bool(num%5)) return ans 方法二：取余操作具有累加性，简单的优化提升了3倍的速度。 12345678def prefixesDivBy5(self, A: List[int]) -&gt; List[bool]: num, ans = 0, [] for d in A: num &lt;&lt;= 1 num |= d num %= 5 ans.append(not bool(num)) return ans 1031. Number of Enclaves求被困的地点个数。1表示陆地，不能够走到边界的陆地称为被困的陆地。原题方法一：简单的DFS 1234567891011121314151617181920212223def numEnclaves(self, A: List[List[int]]) -&gt; int: if not A: return 0 R, C = len(A), len(A[0]) def spread(i, j): A[i][j] = 0 for x, y in ((i-1, j), (i+1, j), (i, j-1), (i, j+1)): if 0&lt;=x&lt;R and 0&lt;=y&lt;C and A[x][y] == 1: spread(x, y) for i in range(R): if A[i][0]==1: spread(i, 0) if A[i][C-1] == 1: spread(i, C-1) for j in range(C): if A[0][j] == 1: spread(0, j) if A[R-1][j] == 1: spread(R-1, j) return sum(sum(row) for row in A) 503. Next Greater Element II下一个比当前元素大的元素，数组首位连接。原题和1030题相似。方法一：首位连接，所以要遍历两次。 12345678def nextGreaterElements(self, nums: List[int]) -&gt; List[int]: ans, stack = [], [] for num in nums * 2: while stack and stack[-1][1] &lt; num: ans[stack.pop()[0]] = num stack.append((len(ans), num)) ans.append(-1) return ans[:len(nums)] 方法二：实际并不需要保存数字。 1234567def nextGreaterElements(self, nums: List[int]) -&gt; List[int]: ans, stack = [-1]*len(nums), [] for i in list(range(len(nums)))*2: while stack and nums[stack[-1]] &lt; nums[i]: ans[stack.pop()] = nums[i] stack.append(i) return ans]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
        <tag>Algorithm</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode算法题整理（链表篇）LinkedList]]></title>
    <url>%2FLeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E9%93%BE%E8%A1%A8%E7%AF%87%EF%BC%89LinkedList%2F</url>
    <content type="text"><![CDATA[链表的定义1234class ListNode: def __init__(self, x): self.val = x self.next = None 2. Add Two Numbers两个链表相加123Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8Explanation: 342 + 465 = 807. 123456789101112131415def addTwoNumbers(l1, l2): l = head = ListNode(0) carry = 0 while l1 or l2 or carry: v1 = v2 = 0 if l1: v1 = l1.val l1 = l1.next if l2: v2 = l2.val l2 = l2.next carry, val = divmod(v1+v2+carry, 10) l.next = ListNode(val) l = l.next return head.next 445. Add Two Numbers II跟上题类似，只不过是进位方式不同。原题12Input: (7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 8 -&gt; 0 -&gt; 7 方法一：先reverse再相加，最后再reverse。 1234567891011121314151617181920212223def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode: def reverse(head): prev = None while head: head.next, prev, head = prev, head, head.next return prev ans = head = ListNode(0) l1, l2 = reverse(l1), reverse(l2) carry = 0 while l1 or l2 or carry: v1 = v2 = 0 if l1: v1 = l1.val l1 = l1.next if l2: v2 = l2.val l2 = l2.next carry, val = divmod(v1+v2+carry, 10) head.next = ListNode(val) head = head.next return reverse(ans.next) 方法二：由于Python int没有限制，所以可以遍历相加，再从尾到头还原节点。 12345678910111213141516def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode: v1 = v2 = 0 while l1: v1 = v1*10 + l1.val l1 = l1.next while l2: v2 = v2*10 + l2.val l2 = l2.next val = v1 + v2 tail, head = None, None while val &gt; 0: head = ListNode(val % 10) head.next = tail tail = head val //= 10 return head if head else ListNode(0) 21. Merge Two Sorted Lists合并两个有序链表。原题12Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 方法1：iteratively 迭代 12345678910def mergeTwoLists(l1, l2): l = head = ListNode(0) while l1 and l2: if l1.val &lt;= l2.val: l.next, l1 = l1, l1.next else: l.next, l2 = l2, l2.next l = l.next l.next = l1 or l2 return head.next 方法2：recursively 递归 12345678910def mergeTwoLists(l1, l2): # 判断是否存在None if not l1 or not l2: return l1 or l2 if l1.val &lt; l2.val: l1.next = mergeTwoLists(l1.next, l2) return l1 else: l2.next = mergeTwoLists(l1, l2.next) return l2 23. Merge k Sorted Lists合并k个有序列表。原题1234567Input:[ 1-&gt;4-&gt;5, 1-&gt;3-&gt;4, 2-&gt;6]Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6 方法一：Brute Force. time: O(NlogN) 1234567891011def mergeKLists(self, lists: List[ListNode]) -&gt; ListNode: ans = [] for l in lists: while l: ans.append(l.val) l = l.next h = head = ListNode(0) for v in sorted(ans): h.next = ListNode(v) h = h.next return head.next 方法二：优先级队列。本来优先级就没有方法一快，再加上Python3中的比较符机制不同，导致要实现__lt__方法，就更慢了。不过理论时间复杂度是比方法一小的。Time: O(Nlogk) 123456789101112131415161718192021222324class CmpNode: def __init__(self, node): self.node = node def __lt__(self, other): return self.node.val &lt; other.node.val class Solution: def mergeKLists(self, lists: List[ListNode]) -&gt; ListNode: from queue import PriorityQueue head = h = ListNode(0) q = PriorityQueue() for l in lists: if l: q.put(CmpNode(l)) while not q.empty(): to_add = q.get().node h.next = to_add h = h.next if to_add.next: q.put(CmpNode(to_add.next)) return head.next 方法三：规避ListNode的比较，以解决上述问题。只要加上该链表在原数组中的索引位置，就一定不会重复，从而忽略对ListNode的比较。 1234567891011121314def mergeKLists(self, lists: List[ListNode]) -&gt; ListNode: from queue import PriorityQueue q = PriorityQueue() for idx, l in enumerate(lists): if l: q.put((l.val, idx, l)) h = head = ListNode(0) while not q.empty(): val, idx, node = q.get() h.next = node h, node = h.next, node.next if node: q.put((node.val, idx, node)) return head.next 方法四：俩俩合并。Time: O(Nlogk) 1234567891011121314151617181920def mergeKLists(self, lists: List[ListNode]) -&gt; ListNode: def merge_both(l1, l2): if not l1 or not l2: return l1 or l2 if l1.val &lt;= l2.val: l1.next = merge_both(l1.next, l2) return l1 else: l2.next = merge_both(l1, l2.next) return l2 pairs = list(lists) while len(pairs) &gt; 1: n = len(pairs) if n &amp; 1 == 1: pairs.append(None) pairs = [merge_both(pairs[i*2], pairs[i*2+1]) for i in range(((n+1)//2))] return pairs[0] if pairs else None 141. Linked List Cycle判断一个链表是否有环。原题经典的一道题，看成两个人在赛跑，如果有环，快的人会和慢的人相遇 1234567def hasCycle(self, head): slow = fast = head: while fast and fast.next: slow, fast = slow.next, fast.next.next if fast is slow: return True return False 142. Linked List Cycle II求链表中环的入口节点。原题 首先判断此链表是否有环。 然后在相交点和头结点一起走，一定会在入口相遇。 Consider the following linked list, where E is the cylce entry and X, the crossing point of fast and slow. H: distance from head to cycle entry E D: distance from E to X L: cycle length ​ _____ ​ / \ head_____H______E \ ​ \ / ​ X_____/ If fast and slow both start at head, when fast catches slow, slow has traveled H+D and fast 2(H+D). Assume fast has traveled n loops in the cycle, we have: 2H + 2D = H + D + L --&gt; H + D = nL --&gt; H = nL - D Thus if two pointers start from head and X, respectively, one first reaches E, the other also reaches E. In my solution, since fast starts at head.next, we need to move slow one step forward in the beginning of part 2 12345678910111213def detectCycle(self, head): fast = slow = head # 检测是否有环 while fast and fast.next: slow, fast = slow.next, fast.next.next if slow is fast: break else: return None # 找出入口节点 while head is not slow: head, slow = head.next, slow.next return head 206. Reverse Linked List倒置一个链表。原题12Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULLOutput: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 方法一： iteratively 12345678def reverseList(head): prev = None while head: cur = head head = head.next cur.next = prev prev = cur return prev 方法二：使用一行赋值 12345def reverseList(self, head): prev = None while head: head.next, prev, head = prev, head, head.next return prev Python同时给多个变量赋值。 方法三：递归 123456def reverseList(self, head, prev=None): if not head: return prev cur, head.next = head.next, prev return self.reverseList(cur, head) 92. Reverse Linked List II跟上题不同的是，只倒置指定区间的部分。原题12Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4Output: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL 123456789101112131415161718def reverseBetween(self, head: ListNode, m: int, n: int) -&gt; ListNode: root = h = ListNode(0) h.next = head for _ in range(m-1): h = h.next cur_head = h p1 = p2 = cur_head.next for _ in range(n-m): p2 = p2.next prev = p2.next if p2 else None if p2: p2.next = None while p1: p1.next, prev, p1 = prev, p1, p1.next cur_head.next = prev return root.next 160. Intersection of Two Linked Lists两个链表求相交。原题123456def getIntersectionNode(self, headA, headB): p1, p2 = headA, headB while p1 is not p2: p1 = p1.next if p1 else headB p2 = p2.next if p2 else headA return p1 138. Copy List with Random Pointer深拷贝一个复杂链表，链表多包含了一个随机指针。原题 Time-O(2n), Memory-O(n). 12345678910111213def copyRandomList(self, head): cp_map = &#123;&#125; m = n = head while m: cp_map[m] = RandomListNode(m.label) m = m.next while n: cp_map[n].next = cp_map.get(n.next) cp_map[n].random = cp_map.get(n.random) n = n.next return cp_map.get(head) Time-O(n), Memory-O(n). 这种方式是相当于把第一次迭代的过程委托给了defaultdict，通过创建一个默认的对象，再去修改它的label值。 1234567891011def copyRandomList(self, head): from collections import defaultdict cp = defaultdict(lambda: RandomListNode(0)) cp[None] = None n = head while n: cp[n].label = n.label cp[n].next = cp[n.next] cp[n].random = cp[n.random] n = n.next return cp[head] 237. Delete Node in a Linked List在链表中删除节点。给定的节点不是尾节点。原题12Input: head = [4,5,1,9], node = 5Output: [4,1,9] 开始看到这题的思路是，要是能拿到父节点就好了，然后这道题需要别的思路，其关键在于复制 123def deleteNode(self, node): node.val = node.next.val # 4-&gt;1-&gt;1-&gt;9 node.next = node.next.next # 4-&gt;1-&gt;9 203. Remove Linked List Elements删除链表中值为val的元素。原题方法一：遍历head并构建新的ListNode。 12345678def removeElements(self, head, val): l = res = ListNode(0) while head: if head.val != val: l.next = ListNode(head.val) l = l.next head = head.next return res.next 方法二：更喜欢这个方法。 123456789def removeElements(self, head: 'ListNode', val: 'int') -&gt; 'ListNode': l = ListNode(0) l.next, ans = head, l while l and l.next: if l.next.val == val: l.next = l.next.next else: l = l.next return ans.next 83. Remove Duplicates from Sorted List删除有序链表中重复的节点。原题12345678def delete_duplicates(head): root = head while head and head.next: if head.val == head.next.val: head.next = head.next.next else: head = head.next return root 82. Remove Duplicates from Sorted List II和上题不同的是，重复的节点要全部删除。原题12Input: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5Output: 1-&gt;2-&gt;5 方法一：首次AC的方法。 123456789101112131415def deleteDuplicates(self, head: ListNode) -&gt; ListNode: prev = ans = ListNode(0) prev.next = h = head while h and h.next: remove = False while h.next and h.val == h.next.val: h.next = h.next.next remove = True if remove: prev.next = h.next else: prev = prev.next h = h.next return ans.next 876. Middle of the Linked List链表中点，如果偶数个，则返回第二个节点。原题12345678Input: [1,2,3,4,5]Output: Node 3 from this list (Serialization: [3,4,5])The returned node has value 3. (The judge&apos;s serialization of this node is [3,4,5]).Note that we returned a ListNode object ans, such that:ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, and ans.next.next.next = NULL.Output: Node 4 from this list (Serialization: [4,5,6])Since the list has two middle nodes with values 3 and 4, we return the second one. 12345def middleNode(self, head: 'ListNode') -&gt; 'ListNode': fast = slow = head while fast and fast.next: slow, fast = slow.next, fast.next.next return slow 234. Palindrome Linked List判断一个链表是否是回文链表。原题12Input: 1-&gt;2-&gt;2-&gt;1Output: true 方法一：此题为倒置链表和快慢指针的总和应用。 1234567891011def isPalindrome(self, head: 'ListNode') -&gt; 'bool': rev = None slow = fast = head while fast and fast.next: fast = fast.next.next slow.next, rev, slow = rev, slow, slow.next if fast: slow = slow.next while rev and rev.val == slow.val: rev, slow = rev.next, slow.next return rev is None 方法二：上述方法有一个缺点就是改变了原始的head，这里进行一些改进。 12345678910111213def isPalindrome(self, head): rev = None fast = head while fast and fast.next: fast = fast.next.next rev, rev.next, head = head, rev, head.next tail = head.next if fast else head isPali = True while rev: isPali = isPali and rev.val == tail.val head, head.next, rev = rev, head, rev.next tail = tail.next return isPali 24. Swap Nodes in Pairs成对转换链表。原题1Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3. 12345678def swapPairs(self, head: ListNode) -&gt; ListNode: prev, prev.next = self, head while prev.next and prev.next.next: a = prev.next # current b = a.next prev.next, b.next, a.next = b, a, b.next prev = a return self.next 19. Remove Nth Node From End of List删除倒数第N个节点。原题123Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5. 12345678910def removeNthFromEnd(self, head: ListNode, n: int) -&gt; ListNode: root = slow = fast = ListNode(0) slow.next = head while n &gt;= 0 and fast: fast = fast.next n -= 1 while fast: slow, fast = slow.next, fast.next slow.next = slow.next.next if slow.next else None return root.next 328. Odd Even Linked List重排链表，使奇数位节点在前，偶数位节点在后，就地排序。原题12Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULLOutput: 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL 123456789101112def oddEvenList(self, head: ListNode) -&gt; ListNode: if not head: return None odd = head even_h = even = head.next while even and even.next: odd.next = odd.next.next odd = odd.next even.next = even.next.next even = even.next odd.next = even_h return head ***. Sort a linked list that is sorted alternating asc and desc这题不是LC上的，是面经里的，要求将一个奇数位升序，偶数位降序的链表转成一个升序的链表。12Input List: 10-&gt;40-&gt;53-&gt;30-&gt;67-&gt;12-&gt;89-&gt;NULLOutput List: 10-&gt;12-&gt;30-&gt;40-&gt;53-&gt;67-&gt;89-&gt;NULL 方法一：分别参考了328，206，21三题，但是有一个副作用，就是将输入的链表改变了，一开始我是想针对链表就地修改，但是发现最后合并的时候又不太好实现。 12345678910111213141516171819202122232425262728def sort_alternating(head: ListNode) -&gt; ListNode: if not head: return None # separate two lists odd = head even_h = even = head.next while even and even.next: odd.next = odd.next.next odd = odd.next even.next = even.next.next even = even.next odd.next = None # for last even tail ！！ # reverse the one with descending order prev = None while even_h: even_h.next, prev, even_h = prev, even_h, even_h.next # merge both lists ans = h = ListNode(0) while head and prev: if head.val &lt;= prev.val: h.next, head = head, head.next else: h.next, prev = prev, prev.next h = h.next h.next = head or prev # head is not head original return ans.next 方法二：修改了方法一中的不足，在一开始就建立两个链表。两个链表要分开迭代才不会遗漏元素。 12345678910111213141516171819202122232425262728293031def sort_alternating(head: ListNode) -&gt; ListNode: if not head: return None # separate two lists odd_head = odd_h = ListNode(0) even_head = even_h = ListNode(0) odd = head even = head.next while odd: odd_h.next = ListNode(odd.val) odd, odd_h = odd.next.next if odd.next else None, odd_h.next while even: even_h.next = ListNode(even.val) even, even_h = even.next.next if even.next else None, even_h.next # reverse the one with descending order prev = None odd_head, even_head = odd_head.next, even_head.next while even_head: even_head.next, prev, even_head = prev, even_head, even_head.next # merge both lists ans = h = ListNode(0) while odd_head and prev: if odd_head.val &lt;= prev.val: h.next, odd_head = odd_head, odd_head.next else: h.next, prev = prev, prev.next h = h.next h.next = odd_head or prev return ans.next 148. Sort List给链表排序。原题12Input: 4-&gt;2-&gt;1-&gt;3Output: 1-&gt;2-&gt;3-&gt;4 方法一： 1234567891011121314151617181920212223242526def sortList(self, head: ListNode) -&gt; ListNode: def merge_both(l1, l2): l = h = ListNode(0) while l1 and l2: if l1.val &lt;= l2.val: l.next, l1 = l1, l1.next else: l.next, l2 = l2, l2.next l = l.next l.next = l1 or l2 return h.next def merge_sort(h): if not h or not h.next: return h slow = fast = h prev = None while fast and fast.next: prev, slow, fast = slow, slow.next, fast.next.next prev.next = None left = merge_sort(h) right = merge_sort(slow) return merge_both(left, right) return merge_sort(head) 817. Linked List Components链表的组件。给定一个集合G，然后根据是否在G中分成若干部分，求连起来在G中的部分的个数。原题123456Input: head: 0-&gt;1-&gt;2-&gt;3-&gt;4G = [0, 3, 1, 4]Output: 2Explanation: 0 and 1 are connected, 3 and 4 are connected, so [0, 1] and [3, 4] are the two connected components. 1234567891011def numComponents(self, head: ListNode, G: List[int]) -&gt; int: SET_G = set(G) h = head count = 0 while h: if h.val in SET_G: if (h.next and h.next.val not in SET_G or not h.next): count += 1 h = h.next return count 86. Partition List链表分区，将比x小的节点放到前面，其余节点放到后面，并保持原有顺序。原题12Input: head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3Output: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5 方法一：首次AC的方法。注意最后gt后面可能有残留的节点比如最后一个2. 123456789101112131415def partition(self, head: ListNode, x: int) -&gt; ListNode: lt = letter = ListNode(0) gt = greater = ListNode(0) h = head while h: if h.val &lt; x: lt.next = h lt = h else: gt.next = h gt = h h = h.next gt.next = None # important !! lt.next = greater.next return letter.next 61. Rotate List向右旋转链表k次。原题1234567Input: 0-&gt;1-&gt;2-&gt;NULL, k = 4Output: 2-&gt;0-&gt;1-&gt;NULLExplanation:rotate 1 steps to the right: 2-&gt;0-&gt;1-&gt;NULLrotate 2 steps to the right: 1-&gt;2-&gt;0-&gt;NULLrotate 3 steps to the right: 0-&gt;1-&gt;2-&gt;NULLrotate 4 steps to the right: 2-&gt;0-&gt;1-&gt;NULL 1234567891011121314def rotateRight(self, head: ListNode, k: int) -&gt; ListNode: n, cur, prev = 0, head, None while cur: n += 1 prev, cur = cur, cur.next if n==0 or k%n==0: return head k = k % n tail = head for _ in range(n-k-1): tail = tail.next ans, tail.next, prev.next = tail.next, None, head return ans 725. Split Linked List in Parts按部分拆分链表。如果不能整除，要保证前面部分的大。原题123456Input: root = [1, 2, 3], k = 5Output: [[1],[2],[3],[],[]]Input: root = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], k = 3Output: [[1, 2, 3, 4], [5, 6, 7], [8, 9, 10]] 12345678910111213141516def splitListToParts(self, root: ListNode, k: int) -&gt; List[ListNode]: n, cur = 0, root ans = [] while cur: n += 1 cur = cur.next parts, remain = divmod(n, k) h = root for i in range(k): head = h for i in range(parts-1+(i&lt;remain)): h = h.next if h: h.next, h = None, h.next ans.append(head) return ans 143. Reorder List1Given 1-&gt;2-&gt;3-&gt;4-&gt;5, reorder it to 1-&gt;5-&gt;2-&gt;4-&gt;3. 1234567891011121314151617def reorderList(self, head: ListNode) -&gt; None: if not head: return slow = fast = head while fast and fast.next: slow, fast = slow.next, fast.next.next tail, slow.next = slow.next, None def reverse(node): prev = None while node: node.next, prev, node = prev, node, node.next return prev tail = reverse(tail) h = head while h and tail: h.next, tail.next, tail, h = tail, h.next, tail.next, h.next 1030. Next Greater Node In Linked List链表中下一个比当前节点大的值。和503题类似。原题12Input: [2,7,4,3,5]Output: [7,0,5,5,0] 方法一：竞赛时没有做出来，虽然是一个链表题，但是跟链表没啥关系。思路vals保存了之前所有节点的值，stack按序存的索引，当遍历一个新的节点时，不断地去和之前的节点比较，如果大于，那么久更新ans中的值，之前设为了0。 12345678910111213def nextLargerNodes(self, head: ListNode) -&gt; List[int]: stack, vals = [], [] i, ans = 0, [] while head: num = head.val vals.append(num) while stack and num &gt; vals[stack[-1]]: ans[stack.pop()] = num stack.append(i) ans.append(0) i += 1 head = head.next return ans 方法二：去除方法一中无用的变量。 123456789def nextLargerNodes(self, head: ListNode) -&gt; List[int]: ans, stack = [], [] while head: while stack and stack[-1][1] &lt; head.val: ans[stack.pop()[0]] = head.val stack.append((len(ans), head.val)) ans.append(0) head = head.next return ans]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
        <tag>Algorithm</tag>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo搭建遇到的问题及优化]]></title>
    <url>%2Fhexo%E6%90%AD%E5%BB%BA%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[前言终于有了一个整理自己学习笔记的地方了，之前用过印象笔记，觉得它的markdown格式处理得不是很完美，复制粘贴出来总是格式不对。后来又用过jupyter_nootboke，但是不方便在其它客户端查看。折腾了半天终于弄好了期间遇到过不少坑，发现hexo有时候同一样的问题总是对应着几种不同的解决方法，在此整理一下以便之后遇到问题。 关于问题NexT这里使用了next主题，这个主题特别简洁，还有很多易用性的扩展，尤其侧边栏的快速定位，让我爱不释手。 头像不显示开始按照_config.yml中所说把avatar.gif放到blog-site/source/下，没有任何的作用。后来发现是主题的原因，放到themes/next/source/images/下就好了，默认的头像是正方形的，这里修改了一下代码把它改成圆形，文件位置在themes/next/source/css_common_components/sidebar/sidebar-author.styl 1234567891011121314.site-author-image &#123; display: block; margin: 0 auto; max-width: 96px; height: auto; border: 2px solid #333; padding: 2px; /* start*/ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px; box-shadow: inset 0 -1px 0 #333sf; /* end */&#125; 网页图标favicon.ico不显示这里也是因为Next的原因，把favicon.ico放到themes/next/source/images/下，然后修改_config.yml中favicon: /images/favicon.ico解决了问题。这里介绍一个很方便转换ico的网站favicon在线制作。 没有建立资源文件夹 设置post_asset_foler: true之后执行hexo new post_name后没有建立资源文件夹。搜索没有查到相关记录，后来想到之前next主题设置时，把配置文件拆分了出来，这样每次执行hexo clean/generate的时候在后面加了参数--config指定了配置文件。但是这样修改的文件对于hexo new post_name来说是没有修过的，所以要在source/_config.yml修改这项参数。 之后没有选择官方的标签插件是因为，在编辑markdown时无法看到预览效果所以安装npm install https://github.com/CodeFalling/hexo-asset-image --save，在文章中使用markdown语法引用![logo](&lt;title_name&gt;/a.png)使用。 选择官方的标签插件引用图片。 关于优化在右上角或者左上角实现fork me on github在这里选择喜欢的样式。这里选择的是 1&lt;a href="https://your-url" class="github-corner" aria-label="View source on Github"&gt;&lt;svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"&gt;&lt;path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"&gt;&lt;/path&gt;&lt;path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"&gt;&lt;/path&gt;&lt;path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;&lt;style&gt;.github-corner:hover .octo-arm&#123;animation:octocat-wave 560ms ease-in-out&#125;@keyframes octocat-wave&#123;0%,100%&#123;transform:rotate(0)&#125;20%,60%&#123;transform:rotate(-25deg)&#125;40%,80%&#123;transform:rotate(10deg)&#125;&#125;@media (max-width:500px)&#123;.github-corner:hover .octo-arm&#123;animation:none&#125;.github-corner .octo-arm&#123;animation:octocat-wave 560ms ease-in-out&#125;&#125;&lt;/style&gt; 将其粘贴到themes/next/layout/_layout.swig中，放在div class=&quot;headhand&quot;&gt;&lt;/div&gt;下面。 修改文章底部的那个带#号的标签修改模板/themes/next/layout/_macro/post.swig，搜索rel=&quot;tag&quot;&gt;#，将#换成&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt; 侧边栏社交小图标设置在配置文件搜索social_icons，把值换成喜欢的图标名字，这里列出了图标库 在网站底部加上访问量打开/themes/next/layout/_partials/footer.swig文件添加红框内的代码 1&lt;script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"&gt;&lt;/script&gt; 添加统计代码如下位置 12345&lt;div class="powered-by"&gt;&lt;i class="fa fa-user-md"&gt;&lt;/i&gt;&lt;span id="busuanzi_container_site_uv"&gt; 本站访客数:&lt;span id="busuanzi_value_site_uv"&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt; 网站底部字数统计根目录安装npm install hexo-wordcount --save然后再/themes/next/layout/_partials/footer.swig文件最后加上 1234&lt;div class=&quot;theme-info&quot;&gt; &lt;div class=&quot;powered-by&quot;&gt;&lt;/div&gt; &lt;span class=&quot;post-count&quot;&gt;博客全站共&#123;&#123; totalcount(site) &#125;&#125;字&lt;/span&gt;&lt;/div&gt; 添加顶部加载条_config.yml设置中pace:true 在文章底部增加版权信息在目录themes/next/layout/_macro/下添加my-copyright.swig: 123456789101112131415161718192021222324252627282930&#123;% if page.copyright %&#125;&lt;div class="my_post_copyright"&gt; &lt;script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"&gt;&lt;/script&gt; &lt;!-- JS库 sweetalert 可修改路径 --&gt; &lt;script src="https://cdn.bootcss.com/jquery/2.0.0/jquery.min.js"&gt;&lt;/script&gt; &lt;script src="https://unpkg.com/sweetalert/dist/sweetalert.min.js"&gt;&lt;/script&gt; &lt;p&gt;&lt;span&gt;本文标题:&lt;/span&gt;&lt;a href="&#123;&#123; url_for(page.path) &#125;&#125;"&gt;&#123;&#123; page.title &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;文章作者:&lt;/span&gt;&lt;a href="/" title="访问 &#123;&#123; theme.author &#125;&#125; 的个人博客"&gt;&#123;&#123; theme.author &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;发布时间:&lt;/span&gt;&#123;&#123; page.date.format("YYYY年MM月DD日 - HH:MM") &#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;span&gt;最后更新:&lt;/span&gt;&#123;&#123; page.updated.format("YYYY年MM月DD日 - HH:MM") &#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;span&gt;原始链接:&lt;/span&gt;&lt;a href="&#123;&#123; url_for(page.path) &#125;&#125;" title="&#123;&#123; page.title &#125;&#125;"&gt;&#123;&#123; page.permalink &#125;&#125;&lt;/a&gt; &lt;span class="copy-path" title="点击复制文章链接"&gt;&lt;i class="fa fa-clipboard" data-clipboard-text="&#123;&#123; page.permalink &#125;&#125;" aria-label="复制成功！"&gt;&lt;/i&gt;&lt;/span&gt; &lt;/p&gt; &lt;p&gt;&lt;span&gt;许可协议:&lt;/span&gt;&lt;i class="fa fa-creative-commons"&gt;&lt;/i&gt; &lt;a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)"&gt;署名-非商业性使用-禁止演绎 4.0 国际&lt;/a&gt; 转载请保留原文链接及作者。&lt;/p&gt; &lt;/div&gt;&lt;script&gt; var clipboard = new Clipboard('.fa-clipboard'); $(".fa-clipboard").click(function()&#123; clipboard.on('success', function()&#123; swal(&#123; title: "", text: '复制成功', icon: "success", showConfirmButton: true &#125;); &#125;); &#125;); &lt;/script&gt;&#123;% endif %&#125; 在目录themes/next/source/css/_common/components/post/下添加my-post-copyright.styl: 123456789101112131415161718192021222324252627282930313233343536373839404142434445.my_post_copyright &#123; width: 85%; max-width: 45em; margin: 2.8em auto 0; padding: 0.5em 1.0em; border: 1px solid #d3d3d3; font-size: 0.93rem; line-height: 1.6em; word-break: break-all; background: rgba(255,255,255,0.4);&#125;.my_post_copyright p&#123;margin:0;&#125;.my_post_copyright span &#123; display: inline-block; width: 5.2em; color: #b5b5b5; font-weight: bold;&#125;.my_post_copyright .raw &#123; margin-left: 1em; width: 5em;&#125;.my_post_copyright a &#123; color: #808080; border-bottom:0;&#125;.my_post_copyright a:hover &#123; color: #a3d2a3; text-decoration: underline;&#125;.my_post_copyright:hover .fa-clipboard &#123; color: #000;&#125;.my_post_copyright .post-url:hover &#123; font-weight: normal;&#125;.my_post_copyright .copy-path &#123; margin-left: 1em; width: 1em; +mobile()&#123;display:none;&#125;&#125;.my_post_copyright .copy-path:hover &#123; color: #808080; cursor: pointer;&#125; 修改/themes/next/layout/_macro/post.swig在如下位置 添加代码：(注意和之前的教程不一样，这里可能是next的更新了，所以要把代码放到外面，否则在wechat_subscriber未开启时会导致失效。) 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'my-copyright.swig' %&#125; &#123;% endif %&#125;&lt;/div&gt; 修改themes/next/source/css/_common/components/post/post.styl末尾增加一行1@import &quot;my-post-copyright&quot; 博文置顶替换node_modules/hexo-generator-index/lib/generator.js所有的代码为： 12345678910111213141516171819202122232425262728'use strict';var pagination = require('hexo-pagination');module.exports = function(locals)&#123; var config = this.config; var posts = locals.posts; posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义 if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排 else return b.top - a.top; // 否则按照top值降序排 &#125; else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233） return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; // 都没定义按照文章日期降序排 &#125;); var paginationDir = config.pagination_dir || 'page'; return pagination('', posts, &#123; perPage: config.index_generator.per_page, layout: ['index', 'archive'], format: paginationDir + '/%d/', data: &#123; __index: true &#125; &#125;);&#125;; 使用：在头部添加top 12345678---title: date: 2017-05-22 22:45:48tags: 技巧categories: 技巧copyright: truetop: 100--- 修改字体大小/themes/next/source/css/_variables/base.styl搜索font-size-base 设置阅读次数添加阅读量统计 添加搜索12local_search: enable: true SEO优化两个搜索引擎入口： 谷歌搜索引擎验证 百度搜索引擎验证 这里选择用下载文件的方式，将文件放到source/目录下，注意一点应该在文件前添加两行代码，防止hexo将其格式化 12layout: false--- 生成站点地图 sitemap 站点地图是一种文件，您可以通过该文件列出您网站上的网页，从而将您网站内容的组织架构告知Google和其他搜索引擎。Googlebot等搜索引擎网页抓取工具会读取此文件，以便更加智能地抓取您的网站。 12npm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save 更改配置 12345# 自动生成sitemapsitemap: path: sitemap.xmlbaidusitemap: path: baidusitemap.xml 使搜索引擎收录我们的博客 谷歌比较简单向谷歌站长工具提交sitemap 百度。参考Hexo插件之百度主动提交链接 网站自身优化给出站链接添加 “nofollow” 标签/themes/next/layout/_partials/footer.swig找到下面两行，分别在a标签中添加rel=&quot;texternal nofollow&quot;属性 同样在/themes/next/layout/_macor/sidebar.swig中添加这个属性 设置更改属性seo: true 缩短文章链接编辑配置文件permalink: :title.html 添加文章更新时间参考了hexo添加文章更新时间 首先找到/themes/next/layout/_macro/post.swig文件，在&lt;span class=&quot;post-time&quot;&gt;...&lt;/span&gt;后添加： 12345678&#123;%if post.updated and post.updated &gt; post.date%&#125; &lt;span class="post-updated"&gt; &amp;nbsp; | &amp;nbsp; &#123;&#123; __('Updated on') &#125;&#125; &lt;time itemprop="dateUpdated" datetime="&#123;&#123; moment(post.updated).format() &#125;&#125;" content="&#123;&#123; date(post.updated, config.date_format) &#125;&#125;"&gt; &#123;&#123; date(post.updated, config.date_format) &#125;&#125; &lt;/time&gt; &lt;/span&gt;&#123;% endif %&#125; 博主这里改了一下显式的文本，后面的语言配置没有配，如果想手动更改文章更新时间在文章前加上： 1updated: 2018-01-01 12:00:00 默认使用md的修改时间。 文章添加阴影效果找到文件themes/next/source/css/_custom/custom.styl，添加如下代码。 12345678// 主页文章添加阴影效果.post &#123; margin-top: 0px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5);&#125;]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
