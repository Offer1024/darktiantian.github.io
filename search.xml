<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[记一次淘宝接口sign签名破解]]></title>
    <url>%2F%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%B7%98%E5%AE%9D%E6%8E%A5%E5%8F%A3sign%E7%AD%BE%E5%90%8D%E7%A0%B4%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[淘宝H5页面接口Sign签名破解前言：由于公司业务需求，需要显示淘宝商品详情页面的图文详情部分。之前原业务逻辑是根据https://world.taobao.com/item/{num_iid}.htm，在得到html文本后全量通过图片前缀名如https://img.alicdn.com/imgextra进行抓取，返回给客户端。 由于header中的UA传的一个PC端的UA，所以获取的H5数据中，可能含有一些广告，商家之类自己的布局，从而无法在客户端正常展示。另一方面，该接口为高频接口，打开htm页面每次耗时70~80%，严重影响客户端体验，所以对此将接口进行升级。 后来发现手机上打开该页面是不显示一些无关的广告的，而且布局也正常。于是将UA改为了手机端的UA，然后通过抓包分析，返回的页面是一个不包含图片的html，图文详情是根据js接口调用动态渲染。接口为https://h5api.m.taobao.com/h5/mtop.wdetail.getitemdescx/4.9/?jsv=2.4.11&amp;appKey=12574478&amp;t=1544165283634&amp;sign=c691925755f2ff429c950f7b00903a23&amp;api=mtop.wdetail.getItemDescx&amp;v=4.9&amp;type=jsonp&amp;dataType=jsonp&amp;callback=mtopjsonp6&amp;data=%7B%22item_num_id%22%3A%22554401452734%22%7D。看到参数中包含了sign，所以是根据某种规则算出来的签名。 接着就是找到sign的签名算法了，将页面中的js格式化了一下。找到关于sign签名的部分。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107s.prototype.__processRequestUrl = function(n) &#123; &#123;var e = this.params, r = this.options; if (r.hostSetting &amp;&amp; r.hostSetting[t.location.hostname]) &#123; var o = r.hostSetting[t.location.hostname]; o.prefix &amp;&amp; (r.prefix = o.prefix), o.subDomain &amp;&amp; (r.subDomain = o.subDomain), o.mainDomain &amp;&amp; (r.mainDomain = o.mainDomain) &#125; if (!0 === r.H5Request) &#123; var i = "//" + (r.prefix ? r.prefix + ".": "") + (r.subDomain ? r.subDomain + ".": "") + r.mainDomain + "/h5/" + e.api.toLowerCase() + "/" + e.v.toLowerCase() + "/", a = e.appKey || ("waptest" === r.subDomain ? "4272": "12574478"), c = (new Date).getTime(), u = function(t) &#123; function n(t, n) &#123; return t &lt;&lt; n | t &gt;&gt;&gt; 32 - n &#125; function e(t, n) &#123; var e, r, o, i, a; return o = 2147483648 &amp; t, i = 2147483648 &amp; n, a = (1073741823 &amp; t) + (1073741823 &amp; n), (e = 1073741824 &amp; t) &amp; (r = 1073741824 &amp; n) ? 2147483648 ^ a ^ o ^ i: e | r ? 1073741824 &amp; a ? 3221225472 ^ a ^ o ^ i: 1073741824 ^ a ^ o ^ i: a ^ o ^ i &#125; function r(t, r, o, i, a, c, u) &#123; return e(n(t = e(t, e(e(function(t, n, e) &#123; return t &amp; n | ~t &amp; e &#125; (r, o, i), a), u)), c), r) &#125; function o(t, r, o, i, a, c, u) &#123; return e(n(t = e(t, e(e(function(t, n, e) &#123; return t &amp; e | n &amp; ~e &#125; (r, o, i), a), u)), c), r) &#125; function i(t, r, o, i, a, c, u) &#123; return e(n(t = e(t, e(e(function(t, n, e) &#123; return t ^ n ^ e &#125; (r, o, i), a), u)), c), r) &#125; function a(t, r, o, i, a, c, u) &#123; return e(n(t = e(t, e(e(function(t, n, e) &#123; return n ^ (t | ~e) &#125; (r, o, i), a), u)), c), r) &#125; function c(t) &#123; var n, e = "", r = ""; for (n = 0; 3 &gt;= n; n++) e += (r = "0" + (t &gt;&gt;&gt; 8 * n &amp; 255).toString(16)).substr(r.length - 2, 2); return e &#125; var u, s, f, l, p, d, h, v, m, g; for (g = function(t) &#123; for (var n, e = t.length, r = e + 8, o = 16 * ((r - r % 64) / 64 + 1), i = new Array(o - 1), a = 0, c = 0; e &gt; c;) a = c % 4 * 8, i[n = (c - c % 4) / 4] = i[n] | t.charCodeAt(c) &lt;&lt; a, c++; return a = c % 4 * 8, i[n = (c - c % 4) / 4] = i[n] | 128 &lt;&lt; a, i[o - 2] = e &lt;&lt; 3, i[o - 1] = e &gt;&gt;&gt; 29, i &#125; (t = function(t) &#123; t = t.replace(/\r\n/g, "\n"); for (var n = "", e = 0; e &lt; t.length; e++) &#123; var r = t.charCodeAt(e); 128 &gt; r ? n += String.fromCharCode(r) : r &gt; 127 &amp;&amp; 2048 &gt; r ? (n += String.fromCharCode(r &gt;&gt; 6 | 192), n += String.fromCharCode(63 &amp; r | 128)) : (n += String.fromCharCode(r &gt;&gt; 12 | 224), n += String.fromCharCode(r &gt;&gt; 6 &amp; 63 | 128), n += String.fromCharCode(63 &amp; r | 128)) &#125; return n &#125; (t)), d = 1732584193, h = 4023233417, v = 2562383102, m = 271733878, u = 0; u &lt; g.length; u += 16) s = d, f = h, l = v, p = m, h = a(h = a(h = a(h = a(h = i(h = i(h = i(h = i(h = o(h = o(h = o(h = o(h = r(h = r(h = r(h = r(h, v = r(v, m = r(m, d = r(d, h, v, m, g[u + 0], 7, 3614090360), h, v, g[u + 1], 12, 3905402710), d, h, g[u + 2], 17, 606105819), m, d, g[u + 3], 22, 3250441966), v = r(v, m = r(m, d = r(d, h, v, m, g[u + 4], 7, 4118548399), h, v, g[u + 5], 12, 1200080426), d, h, g[u + 6], 17, 2821735955), m, d, g[u + 7], 22, 4249261313), v = r(v, m = r(m, d = r(d, h, v, m, g[u + 8], 7, 1770035416), h, v, g[u + 9], 12, 2336552879), d, h, g[u + 10], 17, 4294925233), m, d, g[u + 11], 22, 2304563134), v = r(v, m = r(m, d = r(d, h, v, m, g[u + 12], 7, 1804603682), h, v, g[u + 13], 12, 4254626195), d, h, g[u + 14], 17, 2792965006), m, d, g[u + 15], 22, 1236535329), v = o(v, m = o(m, d = o(d, h, v, m, g[u + 1], 5, 4129170786), h, v, g[u + 6], 9, 3225465664), d, h, g[u + 11], 14, 643717713), m, d, g[u + 0], 20, 3921069994), v = o(v, m = o(m, d = o(d, h, v, m, g[u + 5], 5, 3593408605), h, v, g[u + 10], 9, 38016083), d, h, g[u + 15], 14, 3634488961), m, d, g[u + 4], 20, 3889429448), v = o(v, m = o(m, d = o(d, h, v, m, g[u + 9], 5, 568446438), h, v, g[u + 14], 9, 3275163606), d, h, g[u + 3], 14, 4107603335), m, d, g[u + 8], 20, 1163531501), v = o(v, m = o(m, d = o(d, h, v, m, g[u + 13], 5, 2850285829), h, v, g[u + 2], 9, 4243563512), d, h, g[u + 7], 14, 1735328473), m, d, g[u + 12], 20, 2368359562), v = i(v, m = i(m, d = i(d, h, v, m, g[u + 5], 4, 4294588738), h, v, g[u + 8], 11, 2272392833), d, h, g[u + 11], 16, 1839030562), m, d, g[u + 14], 23, 4259657740), v = i(v, m = i(m, d = i(d, h, v, m, g[u + 1], 4, 2763975236), h, v, g[u + 4], 11, 1272893353), d, h, g[u + 7], 16, 4139469664), m, d, g[u + 10], 23, 3200236656), v = i(v, m = i(m, d = i(d, h, v, m, g[u + 13], 4, 681279174), h, v, g[u + 0], 11, 3936430074), d, h, g[u + 3], 16, 3572445317), m, d, g[u + 6], 23, 76029189), v = i(v, m = i(m, d = i(d, h, v, m, g[u + 9], 4, 3654602809), h, v, g[u + 12], 11, 3873151461), d, h, g[u + 15], 16, 530742520), m, d, g[u + 2], 23, 3299628645), v = a(v, m = a(m, d = a(d, h, v, m, g[u + 0], 6, 4096336452), h, v, g[u + 7], 10, 1126891415), d, h, g[u + 14], 15, 2878612391), m, d, g[u + 5], 21, 4237533241), v = a(v, m = a(m, d = a(d, h, v, m, g[u + 12], 6, 1700485571), h, v, g[u + 3], 10, 2399980690), d, h, g[u + 10], 15, 4293915773), m, d, g[u + 1], 21, 2240044497), v = a(v, m = a(m, d = a(d, h, v, m, g[u + 8], 6, 1873313359), h, v, g[u + 15], 10, 4264355552), d, h, g[u + 6], 15, 2734768916), m, d, g[u + 13], 21, 1309151649), v = a(v, m = a(m, d = a(d, h, v, m, g[u + 4], 6, 4149444226), h, v, g[u + 11], 10, 3174756917), d, h, g[u + 2], 15, 718787259), m, d, g[u + 9], 21, 3951481745), d = e(d, s), h = e(h, f), v = e(v, l), m = e(m, p); return (c(d) + c(h) + c(v) + c(m)).toLowerCase() &#125; (r.token + "&amp;" + c + "&amp;" + a + "&amp;" + e.data), s = &#123; jsv: "2.4.11", appKey: a, t: c, sign: u &#125;, f = &#123; data: e.data, ua: e.ua &#125;; Object.keys(e).forEach(function(t) &#123; "undefined" == typeof s[t] &amp;&amp; "undefined" == typeof f[t] &amp;&amp; "headers" !== t &amp;&amp; "ext_headers" !== t &amp;&amp; "ext_querys" !== t &amp;&amp; (s[t] = e[t]) &#125;), e.ext_querys &amp;&amp; Object.keys(e.ext_querys).forEach(function(t) &#123; s[t] = e.ext_querys[t] &#125;), r.getJSONP ? s.type = "jsonp": r.getOriginalJSONP ? s.type = "originaljsonp": (r.getJSON || r.postJSON) &amp;&amp; (s.type = "originaljson"), "undefined" != typeof e.valueType &amp;&amp; ("original" === e.valueType ? r.getJSONP || r.getOriginalJSONP ? s.type = "originaljsonp": (r.getJSON || r.postJSON) &amp;&amp; (s.type = "originaljson") : "string" === e.valueType &amp;&amp; (r.getJSONP || r.getOriginalJSONP ? s.type = "jsonp": (r.getJSON || r.postJSON) &amp;&amp; (s.type = "json"))), !0 === r.useJsonpResultType &amp;&amp; "originaljson" === s.type &amp;&amp; delete s.type, r.dangerouslySetProtocol &amp;&amp; (i = r.dangerouslySetProtocol + ":" + i), r.querystring = s, r.postdata = f, r.path = i &#125; n()&#125;,&#125; 看到这里应该是一个加密后的js，后来找到一篇文章。淘宝sign加密算法。根据抓包的参数，按照公式来计算sign，验证算法是否正确。可能由于时间戳没有取整，或者一些其他的原因如编码问题等，导致sign的值没有和正确值对上，又看到文中贴的代码比我找到的js更加简单，以为淘宝更新了算法。再后来一位知友提示说算法没有问题，（在此特别感谢知友Jaho及文章作者小歪）才又抓包试了一次，这次将毫秒时间戳转为了int，并将字符串进行utf8编码，算出来的sign值和抓包中的匹配。后来证实通过js断点调试也可以验证公式的正确性。sign生成公式为：md5Hex(token&amp;t&amp;appKey&amp;data)t表示毫秒时间戳，appKey一般为固定值。data为参数。本文中的例子为6b2310e47a950f1c8c3fe6ec792f356a&amp;1544165283634&amp;12574478&amp;{&quot;item_num_id&quot;:&quot;554401452734&quot;}再进行md5转换。 知道了sign算法，接下来就是token的获取，根据知乎文中作者所说，第一次请求是会设置cookie，于是使用Postman清理cookie后请求，此时sign的值传任何值均无影响，接口会返回 123456mtopjsonp2(&#123; "api": "mtop.wdetail.getItemDescx", "v": "4.9", "ret": ["FAIL_SYS_TOKEN_EXOIRED::令牌过期"], "data": &#123;&#125;&#125;) 并设置两个cookie，一个是_m_h5_tk值为6b2310e47a950f1c8c3fe6ec792f356a_1544173923544，另一个是_m_h5_tk_enc，这个目前用不到，我们要的token就是前者_分割的前部分。这样一来，我们请求两次接口，第一次拿到token，第二次请求拿到数据。 123456789101112131415161718192021222324252627282930313233343536&#123; "api": "mtop.wdetail.getItemDescx", "data": &#123; "pages": [ "&lt;txt&gt;特别提醒：此款收纳箱尺寸测量方法：（盖上盖子测量长宽高）长度=盖子+把手。手工量的，稍许误差，谢谢谅解！ 注意：不要把本店的L数跟超市的比较，本店的L数是网上笼统的叫法，以箱子实际尺寸为主，介意的亲请勿拍！建议：店长推荐拍套装几个套在一起 可以抗摔 。。10L不建议购买只能装一些小东西人工测量会有2cm左右误差属于正常现象温馨提醒：塑料属于易碎品，为了免去亲的麻烦，请亲在收货时先拆开检查后在签收，如有破损请直接拒收&lt;/txt&gt;&lt;img&gt;https://img.alicdn.com/imgextra/i3/2651141793/TB2kQKqbgsSMeJjSspcXXXjFXXa_!!2651141793.jpg&lt;/img&gt;&lt;img&gt;https://img.alicdn.com/imgextra/i1/2651141793/TB2UkPszC8mpuFjSZFMXXaxpVXa_!!2651141793.jpg&lt;/img&gt;&lt;img&gt;https://img.alicdn.com/imgextra/i3/2651141793/TB2dJSBzstnpuFjSZFKXXalFFXa_!!2651141793.jpg&lt;/img&gt;&lt;img&gt;https://img.alicdn.com/imgextra/i4/2651141793/TB2U3i5zxxmpuFjSZFNXXXrRXXa_!!2651141793.jpg&lt;/img&gt;&lt;img&gt;https://img.alicdn.com/imgextra/i1/2651141793/TB22qfEzr4npuFjSZFmXXXl4FXa_!!2651141793.jpg&lt;/img&gt;&lt;img&gt;https://img.alicdn.com/imgextra/i2/2651141793/TB2_8HcvbJkpuFjy1zcXXa5FFXa_!!2651141793.jpg&lt;/img&gt;", "&lt;img&gt;https://img.alicdn.com/imgextra/i1/2651141793/TB2f7YszC8mpuFjSZFMXXaxpVXa_!!2651141793.jpg&lt;/img&gt;&lt;img&gt;https://img.alicdn.com/imgextra/i3/2651141793/TB2B600zrBnpuFjSZFGXXX51pXa_!!2651141793.jpg&lt;/img&gt;&lt;img&gt;https://img.alicdn.com/imgextra/i4/2651141793/TB2C.HmvgFkpuFjSspnXXb4qFXa_!!2651141793.jpg&lt;/img&gt;&lt;img&gt;https://img.alicdn.com/imgextra/i3/2651141793/TB25AYszC8mpuFjSZFMXXaxpVXa_!!2651141793.jpg&lt;/img&gt;&lt;img&gt;https://img.alicdn.com/imgextra/i3/2651141793/TB2Tt1BzstnpuFjSZFKXXalFFXa_!!2651141793.jpg&lt;/img&gt;&lt;img&gt;https://img.alicdn.com/imgextra/i3/2651141793/TB2FNPgvgxlpuFjSszbXXcSVpXa_!!2651141793.jpg&lt;/img&gt;&lt;img&gt;https://img.alicdn.com/imgextra/i2/2651141793/TB26j40zrBnpuFjSZFGXXX51pXa_!!2651141793.jpg&lt;/img&gt;&lt;img&gt;https://img.alicdn.com/imgextra/i4/2651141793/TB2uDGozCVmpuFjSZFFXXcZApXa_!!2651141793.jpg&lt;/img&gt;", "&lt;img&gt;https://img.alicdn.com/imgextra/i1/2651141793/TB2Bx9ntxRDOuFjSZFzXXcIipXa_!!2651141793.jpg&lt;/img&gt;&lt;img&gt;https://img.alicdn.com/imgextra/i2/2651141793/TB2nSblvm0jpuFjy0FlXXc0bpXa_!!2651141793.jpg&lt;/img&gt;&lt;img&gt;https://img.alicdn.com/imgextra/i2/2651141793/TB2wtaQvbXlpuFjSszfXXcSGXXa_!!2651141793.jpg&lt;/img&gt;&lt;img&gt;https://img.alicdn.com/imgextra/i4/2651141793/TB2k1vfvl4lpuFjy1zjXXcAKpXa_!!2651141793.jpg&lt;/img&gt;&lt;img&gt;https://img.alicdn.com/imgextra/i1/2651141793/TB26HbQvbFkpuFjy1XcXXclapXa_!!2651141793.jpg&lt;/img&gt;&lt;img&gt;https://img.alicdn.com/imgextra/i3/2651141793/TB24miYzypnpuFjSZFIXXXh2VXa_!!2651141793.jpg&lt;/img&gt;&lt;txt&gt;.................welcome20160618152824&lt;/txt&gt;" ], "images": [ "https://img.alicdn.com/imgextra/i3/2651141793/TB2kQKqbgsSMeJjSspcXXXjFXXa_!!2651141793.jpg", "https://img.alicdn.com/imgextra/i1/2651141793/TB2UkPszC8mpuFjSZFMXXaxpVXa_!!2651141793.jpg", "https://img.alicdn.com/imgextra/i3/2651141793/TB2dJSBzstnpuFjSZFKXXalFFXa_!!2651141793.jpg", "https://img.alicdn.com/imgextra/i4/2651141793/TB2U3i5zxxmpuFjSZFNXXXrRXXa_!!2651141793.jpg", "https://img.alicdn.com/imgextra/i1/2651141793/TB22qfEzr4npuFjSZFmXXXl4FXa_!!2651141793.jpg", "https://img.alicdn.com/imgextra/i2/2651141793/TB2_8HcvbJkpuFjy1zcXXa5FFXa_!!2651141793.jpg", "https://img.alicdn.com/imgextra/i1/2651141793/TB2f7YszC8mpuFjSZFMXXaxpVXa_!!2651141793.jpg", "https://img.alicdn.com/imgextra/i3/2651141793/TB2B600zrBnpuFjSZFGXXX51pXa_!!2651141793.jpg", "https://img.alicdn.com/imgextra/i4/2651141793/TB2C.HmvgFkpuFjSspnXXb4qFXa_!!2651141793.jpg", "https://img.alicdn.com/imgextra/i3/2651141793/TB25AYszC8mpuFjSZFMXXaxpVXa_!!2651141793.jpg", "https://img.alicdn.com/imgextra/i3/2651141793/TB2Tt1BzstnpuFjSZFKXXalFFXa_!!2651141793.jpg", "https://img.alicdn.com/imgextra/i3/2651141793/TB2FNPgvgxlpuFjSszbXXcSVpXa_!!2651141793.jpg", "https://img.alicdn.com/imgextra/i2/2651141793/TB26j40zrBnpuFjSZFGXXX51pXa_!!2651141793.jpg", "https://img.alicdn.com/imgextra/i4/2651141793/TB2uDGozCVmpuFjSZFFXXcZApXa_!!2651141793.jpg", "https://img.alicdn.com/imgextra/i1/2651141793/TB2Bx9ntxRDOuFjSZFzXXcIipXa_!!2651141793.jpg", "https://img.alicdn.com/imgextra/i2/2651141793/TB2nSblvm0jpuFjy0FlXXc0bpXa_!!2651141793.jpg", "https://img.alicdn.com/imgextra/i2/2651141793/TB2wtaQvbXlpuFjSszfXXcSGXXa_!!2651141793.jpg", "https://img.alicdn.com/imgextra/i4/2651141793/TB2k1vfvl4lpuFjy1zjXXcAKpXa_!!2651141793.jpg", "https://img.alicdn.com/imgextra/i1/2651141793/TB26HbQvbFkpuFjy1XcXXclapXa_!!2651141793.jpg", "https://img.alicdn.com/imgextra/i3/2651141793/TB24miYzypnpuFjSZFIXXXh2VXa_!!2651141793.jpg" ] &#125;, "ret": [ "SUCCESS::接口调用成功" ], "v": "4.9"&#125; 其中的images数组就是我想要的数据，这里返回值不是标准的json，套了一层mtopjsonp2({JSON})，于是获取结果后还要根据正则截取一下json的文本。 附上部分相关代码，python版本 123456789101112131415161718192021222324252627282930313233343536def get_images_from_mtop(num_iid): APPKEY = '12574478' DATA = '&#123;"item_num_id":"%s"&#125;' % num_iid URL = 'https://h5api.m.taobao.com/h5/mtop.wdetail.getitemdescx/4.9/' params = &#123;'jsv': '2.4.11', 'appKey': APPKEY, 't': int(time.time()*1000), 'sign': 'FAKE_SIGN_WITH_ANYTHING', 'api': 'mtop.wdetail.getItemDescx', 'v': '4.9', 'type': 'jsonp', 'dataType': 'jsonp', 'callback': 'mtopjsonp2', 'data': DATA&#125; headers = &#123; 'User-Agent': 'Mozilla/5.0 (iPhone; CPU iPhone OS 9_3_4 like Mac OS X) AppleWebKit/601.1.46 ' + \ '(KHTML, like Gecko) Version/9.0 Mobile/13G35 Safari/601.1', &#125; images = [] try: # get token in first request r1 = requests.get(URL, params=params, headers=headers) token_with_time = r1.cookies.get('_m_h5_tk') token = token_with_time.split('_')[0] enc_token = r1.cookies.get('_m_h5_tk_enc') logger.debug(r1.cookies) # get results in second request t2 = str(int(time.time() * 1000)) c = '&amp;'.join([token, t2, APPKEY, DATA]) m = hashlib.md5() m.update(c.encode('utf-8')) params.update(&#123;'t': t2, 'sign': m.hexdigest()&#125;) cookies = &#123;'_m_h5_tk': token_with_time, '_m_h5_tk_enc': enc_token&#125; r2 = requests.get(URL, params=params, headers=headers, cookies=cookies) logger.debug(r2.text) json_text = re.match(r'(.*\()(.*)(\))', r2.text).group(2) images = dict(json.loads(json_text))['data']['images'] except Exception as e: logger.warning(e) finally: return images 可以看到，接口响应时间有了大幅度提升。]]></content>
      <categories>
        <category>逆向工程</category>
      </categories>
      <tags>
        <tag>Sign签名</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工作中项目优化小记]]></title>
    <url>%2F%E5%B7%A5%E4%BD%9C%E4%B8%AD%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[前言博主目前接手了一个项目，该项目代码从某马微店那里买来，社交金融相关。这个项目的代码可以说是逻辑混乱，毫无可重用性，而且又无文档，git message中一堆毫无用处的“update”，PEP8规范？不存在的。使得我每日游走在被代码劝退的边缘。震惊！一次请求1W多条sql。该功能为商品的热销分类表单。之前大概看了一眼，数据是先从redis中取，redis值存的永久有效，没有的话查DB。然后某天清了一下测试数据库的redis，这下好了，接口超时。查了一下silk发现运行了1w多次sql。 万恶之源的代码，难怪查了1W多次，这外键coupon，每次都要查询数据库。而且这里channel也没有用set，这简直基础数据结构都没掌握啊。 123456tbkcoupons = TbkCouponTags.objects.filter(is_hot=True)channel = []for t in tbkcoupons: cc = t.coupon.channel if cc not in channel: channel.append(cc) 使用select_related简单的处理了一下 12345tbkcoupons = TbkCouponTags.objects.select_related('coupon').filter(is_hot=True)channel = set()for t in tbkcoupons: cc = t.coupon.channel channel.add(cc) 快了10倍，冷静一下，思考一下这大哥到底要干嘛，后面看到拿到了tbkcoupons没有再做其他用处。所以这东西完全可以使用反向连接加去重来解决啊，看来sql基础也欠缺。这里改成了values+distinct来处理，因为mysql不支持distinct(‘channel’)这种指定字段的形式。 12tbkcoupons = TbkCoupon.objects.filter(tbkcoupontags__is_hot=True).values('channel').distinct()channels = [c['channel'] for c in tbkcoupons] 后面的逻辑判断，又使用了一堆的ifelse，看着不清晰，将其改为了字典。这些倒不是什么大问题。 最后，修改了一些取值的逻辑。最后将结果保存到了redis中。命中缓存的话大概10+ms。 后来又发现了一个有意思的事情，他好像也知道这个查询挺慢的，所以用celerybeat实现了一个周期任务，定时地更新这个redis。 返回按照当前查询数组顺序的queryset。遇见了这样一个需求 ，收藏列表需要返回按照收藏顺序的商品。而这个顺序保存在java后台。通过Thrift接口调用，返回了一个id列表，而商品保存在我这里。需要根据这个id的顺序返回queryset。django-get-a-queryset-from-array-of-ids-in-specific-order。 123from django.db.models import Case, Whenpreserved = Case(*[When(num_iid=num_iid, then=pos) for pos, num_iid in enumerate(num_iids)])TbkCoupon.objects.filter(num_iid__in=num_iids).order_by(preserved)]]></content>
      <categories>
        <category>Project</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>Django-rest-framework</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode算法题整理（正则篇）regex]]></title>
    <url>%2FLeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E6%AD%A3%E5%88%99%E7%AF%87%EF%BC%89regex%2F</url>
    <content type="text"><![CDATA[193. Valid Phone Numbers使用bash命令在一行中提取一个文本中的手机号。原题 12345678910(xxx) xxx-xxxx or xxx-xxx-xxxx. (x means a digit).Assume that file.txt has the following content:987-123-4567123 456 7890(123) 456-7890Your script should output the following valid phone numbers:987-123-4567(123) 456-7890 1awk '/^([0-9]&#123;3&#125;-|\([0-9]&#123;3&#125;\) )[0-9]&#123;3&#125;-[0-9]&#123;4&#125;$/' telephone.txt]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
        <tag>Algorithm</tag>
        <tag>Regex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 并行赋值]]></title>
    <url>%2FPython-%E5%A4%9A%E4%B8%AA%E5%8F%98%E9%87%8F%E5%90%8C%E6%97%B6%E8%B5%8B%E5%80%BC%2F</url>
    <content type="text"><![CDATA[经常可以在Python看到这样的赋值语句 a, b, c = 1, 2, 3，其执行顺序先执行=右边的表达式，再依次将值赋给左边，Python解释器会将其组成为一个tuple，赋值的时候再unpack。 1234&gt;&gt;&gt; a, b = 2, 0&gt;&gt;&gt; a, b, a = 1, a, 4&gt;&gt;&gt; a, b(4, 2) 可以看到，上面是先把算出右边的值(1, 2, 4)再将其赋值给左边，最后a的值被修改成了4。 如果是可变的对象怎么办，LeetCode有一道经典的题，叫反转一个链表。要求将1-&gt;2-3-&gt;None的链表反转成3-&gt;2-&gt;1-&gt;None。有一个迭代的写法是这样的。 12345678def reverseList(head): prev = None while head: cur = head head = head.next cur.next = prev prev = cur return prev 它的简化写法如下： 12345def reverseList(self, head): prev = None while head: head.next, prev, head = prev, head, head.next return prev 具体的过程是这样的。先执行=右边表达式(None, head, head.next)，然后第一步把head.next=None，此时head变成了1-&gt;None；第二步，执行prev=head，这里为什么head的值时1-&gt;None而不是1-&gt;2-3-&gt;None呢，因为虽然等式先执行的右边，拿到了head，但是上一步的操作是将head修改了，由于head是一个可变对象，prev的值是1-&gt;None，最后再把head=head.next，这里为什么head.next的值又是2-&gt;3-&gt;None了呢，因为，执行右侧的表达式之后，head.next这个对象再前两步中没有被修改，一直都是2-&gt;3-&gt;None，这正是和第二步不同的地方，所以这两个写法是等同的。 参考： Multiple assignment and evaluation order in Python]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[371. Sum of Two Integers - Python]]></title>
    <url>%2F371-Sum-of-Two-Integers-Python%2F</url>
    <content type="text"><![CDATA[不用加减乘除做加法剑指Offer中也出现过此题，此篇文章着重分析一下为什么Python需要做一些多余的操作。 根据书中的分析，大致分为三步： 相加但不进位，使用^ 进位使用&amp;和&lt;&lt; 前两步结果相加 这里不再赘述详细过程。那么我们不难写出代码： 1234567def get_sum(a, b): res, carry = 0, 0 while b != 0: res = a ^ b carry = (a &amp; b) &lt;&lt; 1 a, b = res, carry return res 但是当输入a=-1, b=1时，会发现程序超时。先来看看正常的32位int类型运算时发生了什么，因为进行位运算时要使用补码进行运算，而正数的反码和补码都是本身，负数的反码为除符号位，其它按位取反，负数的补码为反码+1。下面列出了传入a=-1,b=1时，每次循环中a和b的补码。 a的原码 a的补码 b的补码 a ^ b a &amp; b 10…0001 11…1111 00…0001 11…1110 00…0001 10…0010 11…1110 00…0010 11…1100 00…0010 10…0100 11…1100 00…0100 11…1000 00…0100 ⋮ ⋮ ⋮ ⋮ ⋮ 110…000 110…000 010…000 100…000 010…000 100…000 100…000 100…000 000…000 100…000 000…000 000…000 000…000 ‘break’ ‘break’ 可以看出由于位数的限制，b和a最后都变成了0。因为Python中的int没有范围限制，所以这就是为什么会死循环的原因。 如何解决这个问题呢？我们需要在b的补码变成1000…000(32个0)时终止循环，如何将一个一个无限位的整型转成32位呢，想到了&amp;，所以我们找到一个mask=2**32-1也就是32个1，用一个无限位的值和mask进行与运算，就变成了上述表格中的例子，于是我们将代码改为： 12345678def getSum(self, a, b): res, carry = 0, 0 mask = 0xFFFFFFFF while b != 0: res = (a ^ b) &amp; mask carry = ((a &amp; b) &lt;&lt; 1) &amp; mask a, b = res, carry return res 提交之后还是不能通过测试用例，当a=-12, b=-8时输出了4294967276而不是-20。好，把mask先去掉，传入这两个值，发现可以正常输出-20，那么这里的mask是怎么造成了一些副作用的。再来分析一下这两个参数下，具体的过程是怎样的。 为了方便DEBUG，我们添加一些输出： 1234567891011121314def get_sum(self, a, b): mask = 0xFFFFFFFF res, carry = 0, 0 while b != 0: print('bin(&#123;&#125;) = &#123;&#125;, bin(&#123;&#125;) = &#123;&#125;'.format(a, bin(a), b, bin(b))) res = (a ^ b) &amp; mask # res = (a ^ b) print('\t res = &#123;&#125;, bin(res) = &#123;&#125;'.format(res, bin(res))) carry = ((a &amp; b) &lt;&lt; 1) &amp; mask # carry = ((a &amp; b) &lt;&lt; 1) print('\t \t a&amp;b = &#123;&#125;, (a&amp;b)&lt;&lt;1 = &#123;&#125;, carry = &#123;&#125;'.format((a&amp;b), ((a&amp;b)+1), carry)) a, b = res, carry # return res if res &lt;= MAX else ~(res ^ mask) return res 输出如下： 12345678910111213141516Finished in 20 msbin(-12) = -0b1100, bin(-8) = -0b1000 res = 12, bin(res) = 0b1100 a&amp;b = -16, (a&amp;b)&lt;&lt;1 = -15, carry = -32bin(12) = 0b1100, bin(-32) = -0b100000 res = -20, bin(res) = -0b10100 a&amp;b = 0, (a&amp;b)&lt;&lt;1 = 1, carry = 0-20Finished in 24 msbin(-12) = -0b1100, bin(-8) = -0b1000 res = 12, bin(res) = 0b1100 a&amp;b = -16, (a&amp;b)&lt;&lt;1 = -15, carry = 4294967264bin(12) = 0b1100, bin(4294967264) = 0b11111111111111111111111111100000 res = 4294967276, bin(res) = 0b11111111111111111111111111101100 a&amp;b = 0, (a&amp;b)&lt;&lt;1 = 1, carry = 04294967276 可以看到在进行-15&amp;mask时，carry变成了一个很大的正数，并丢失了符号。此处为个人猜想，当负数与mask进行与运算时，比如-2，此时-2的补码变为11…10，一个33-bit的数字，然后和32位的mask与操作后，变为了一个33位的正数。 有一个公式可以帮我们还原a，如果一个负数n，它的无符号的32位补码是m，那么m=~(n ^ mask) 或者n=~(m ^ mask) 于是代码修改为： 1234567891011121314def getSum(self, a, b): MASK = 0xffffffff # in Python, every integer is associated with its two's complement and its sign. # However, doing bit operation "&amp; mask" loses the track of sign. # Therefore, after the while loop, a is the two's complement of the final result as a 32-bit unsigned integer. while b != 0: a, b = (a ^ b) &amp; MASK, ((a &amp; b) &lt;&lt; 1) &amp; MASK # a is negative if the first bit is 1 if (a &gt;&gt; 31) &amp; 1: return ~(a ^ MASK) else: return a 虽然python进行大数字运算很方便，但是无限制位数往往会对位运算的操作中产生一些陷阱。如果可以直接转成Java中那种32的int，岂不是没有这么多麻烦了，好在numpy为我们提供了这样的方法。 1234567import numpy as npclass Solution(object): def getSum(self, a, b): while b != 0: a, b = np.int32(a ^ b), np.int32((a &amp; b) &lt;&lt; 1) return int(a) 最后要再转回int，否则是没法通过测试用例的。 参考： numpy实现方式 mask实现方式 the-meaning-of-bit-wise-not-in-python stackoverflow]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Bit Manipulation</tag>
        <tag>LeetCode</tag>
        <tag>Python</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[约瑟夫环问题（Josephus problem）]]></title>
    <url>%2F%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E9%97%AE%E9%A2%98%EF%BC%88Josephus-problem%EF%BC%89%2F</url>
    <content type="text"><![CDATA[问题：0，1，…，n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求这个圆圈里剩下的最后一个数字。 注意到，一开始有 n 个人，报到 m 的人出局后，如果我们从刚才出局的那人的下一位开始重新从 1 开始编号，原问题就转化为了一个 n–1 人的问题。如下表所示： 原始编号(i) 第一个人出局后的编号(j) m 0 m+1 1 m+2 2 … … m-2 n-2 （n为出局前的总人数） m-1 OUT 可以看出老编号i和新编号j的关系为：i = (j+m) % n，于是总结递推公式： f(n) = (f(n-1) + m) % n (n &gt; 1)，其中f(n)为当场上还有n个人时在场的人的编号。当最后只剩下一个人的时候，这个人的编号只能是0，即f(1)=0，现在根据上面的公式反推，推导出当n个人在场时这个最后幸存者的编号。例如：f(2)=(f(1)+m) % 2，所以range范围从2开始，执行n-1次，也就是range(2, n+1) 12345678def LastRemaining_Solution(self, n, m): # write code here if n&lt;=0 or m&lt;=0: return -1 last_num = 0 for i in range(2, n+1): last_num = (last_num+m) % i return last_num]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>algorithm</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[波义尔摩尔投票算法（Boyer-Moore Voting Algorithm）]]></title>
    <url>%2F%E6%B3%A2%E4%B9%89%E5%B0%94%E6%91%A9%E5%B0%94%E6%8A%95%E7%A5%A8%E7%AE%97%E6%B3%95%EF%BC%88Boyer-Moore-Voting-Algorithm%EF%BC%89%2F</url>
    <content type="text"><![CDATA[简介 The Boyer–Moore majority vote algorithm is an algorithm for finding the majority of a sequence of elements using linear time and constant space. It is named after Robert S. Boyer and J Strother Moore, who published it in 1981,[1] and is a prototypical example of a streaming algorithm. 波义尔摩尔投票算法是一种使用线性时间复杂度和常数空间复杂度来找到数组的主要元素（出现超过一半次数的元素）。 题目: 169. Majority Element。找出数组中出现超过一半的元素。 Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times. You may assume that the array is non-empty and the majority element always exist in the array. 《剑指Offer》中的解释 遍历数组的时候保存两个值：一个是数组中的数字，另一个是次数。当我们遍历到下一个数字的时候，如果下一个数字和我们之前保存的数字相同，则次数加1；如果下一个数字和我们之前保存的数字不同，则次数减1。如果次数为零，那么需要保存下一个数字，并把次数设为1.由于我们要找的数字出现的次数比其他所有数字出现的次数之和还要多，那么要找的数字肯定是最后一次把次数设为1时的对应数字。 整个过程想象成一次投票选举投票规则：大屏幕上只允许出现一位候选人。如果选举人投的票不是当前候选人，那么让当前候选人票-1，如果是，则+1。OK，我们现在把所有数组的元素当成是选举人举出的号牌。我们先考虑最极端的情况：最后的winner以一票之差险胜。也就是元素出现的次数为n//2+1。这种情况是如何出现的呢，假设数组是这样的： 1[7, 7, 7, 7, 1, 2, 3] 没有投7的选举人假设在一开始知道了最有潜力的winner即7号，那么他们‘同仇敌忾’，将-1的票都投在了7号上，这种情况7号一直处于大屏幕中，没有更换过候选人。但是最后也没能打败7号，因为7号最后还保留一票。 另外一种非极端的情况，没有投7的选举人产生了‘内讧’： 1[7, 1, | 2, 3, | 7, 7, 7] 首先7号得到一票，然后被1号干掉，接着2号称为候选人，被3号干掉。3号的票浪费在了‘自己人’身上，即‘我们中出了一个叛徒’。就算团结起来都干不过7号，所以winner还是7号。 最后附上LeetCode上的Python代码： 1234567891011class Solution: def majorityElement(self, nums): count = 0 candidate = None for num in nums: if count == 0: candidate = num count += (1 if num == candidate else -1) return candidate 参考： 维基百科 LeetCode]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode算法题整理（sql篇）sql]]></title>
    <url>%2FLeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88sql%E7%AF%87%EF%BC%89sql%2F</url>
    <content type="text"><![CDATA[595. Big Countries查询’大城市’。原题 使用where OR 123select name, population, area from World where area &gt; 3000000 or population &gt; 25000000; 使用UNION 12345678select name, population, area from World where area &gt; 3000000unionselect name, population, areafrom Worldwhere population &gt; 25000000; 补充说明：Solution中解释道，使用UNION会比OR快上一丢丢。 Suppose we are searching population and area, Given that MySQL usually uses one one index per table in a given query, so when it uses the 1st index rather than 2nd index, it would still have to do a table-scan to find rows that fit the 2nd index. 因为前者查询的时候只用到第一个索引，对第二个条件查询时，也就是population，使用的是全表扫描，于是浪费了一些时间。但是想想背后的代价，想必是以空间来换时间。 627. Swap Salary转换性别。原题 使用if 123UPDATE salarySET sex=IF(sex='m', 'f', 'm'); 使用CASE 1234567update salaryset sex = CASE sex when 'm' Then 'f' else 'm' END; 使用XOR 123update salaryset sex = CHAR(ASCII('f') ^ ASCII('m') ^ ASCII(sex)); 620. Not Boring Movies使用MOD替代%。原题12345select *from cinemawhere mod(id, 2) = 1 and description != 'boring'order by rating DESC; 182. Duplicate Emails查询多余的重复值。原题思考：开始陷入了误区，以为要将重复的id也查出来。 1234SELECT emailFROM PersonGROUP BY emailHAVING Count(*) &gt; 1; 175. Combine Two Tables左链接。过于简单。原题123456SELECT p.FirstName, p.LastName, ad.City, ad.StateFROM Person p LEFT JOIN Address ad ON p.PersonId = ad.PersonId; 181. Employees Earning More Than Their Managers自链接。原题123456select e.name Employeefrom Employee e inner join Employee m on e.ManagerId = m.Idwhere e.Salary &gt; m.Salary; 183. Customers Who Never Order没有订单的顾客。原题123456select c.name Customersfrom Customers c left join Orders o on c.id = o.CustomerIdwhere o.CustomerId is Null; 123456select customers.name as 'Customers'from customerswhere customers.id not in( select customerid from orders); 596. Classes More Than 5 Students超过5个学生的班级。原题12345select classfrom coursesgroup by classhaving count(distinct student) &gt;= 5; 197. Rising Temperature这个挺有意思，开始天真地想用id作为条件，测试用例教做人。原题 我的答案 123456SELECT today.IdFROM Weather yest INNER JOIN Weather today ON today.RecordDate = DATE_ADD(yest.RecordDate, INTERVAL 1 day)WHERE today.Temperature &gt; yest.Temperature; 标准答案 12345678SELECT weather.id AS 'Id'FROM weather JOIN weather w ON DATEDIFF(weather.date, w.date) = 1 AND weather.Temperature &gt; w.Temperature; 查看Mysql文档： DATEDIFF(expr1,expr2) DATEDIFF() returns expr1 − expr2 expressed as a value in days from one date to the other. expr1 and expr2 are date or date-and-time expressions. Only the date parts of the values are used in the calculation. 1234mysql&gt; SELECT DATEDIFF('2007-12-31 23:59:59','2007-12-30'); -&gt; 1mysql&gt; SELECT DATEDIFF('2010-11-30 23:59:59','2010-12-31'); -&gt; -31 196. Delete Duplicate Emails删除重复的邮件。原题1234delete p1 from Person p1, Person p2where p1.email=p2.email and p1.Id &gt; p2.Id; 176. Second Highest Salary返回第二高的salary。原题PS：奇怪的题，没有记录非要人返回Null，只能再套一层查询或者使用IFNULL也可以。 12345678SELECT (SELECT DISTINCT Salary FROM Employee ORDER BY Salary DESC LIMIT 1 OFFSET 1) AS SecondHighestSalary; 626. Exchange Seats交换相邻两行的值。原题开始理解错了，以为要update。 CASE 123456789101112SELECT ( CASE WHEN MOD(id, 2) != 0 AND counts != id THEN id + 1 WHEN MOD(id, 2) != 0 AND counts = id THEN id ELSE id - 1 end ) AS id, studentFROM seat, (SELECT Count(*) AS counts FROM seat) AS seat_countsORDER BY id ASC;; COALESCE() 第一步：使用XOR，但是不能直接使用排序因为id为5的被换成了6。 1SELECT id, (id+1)^1-1, student FROM seat; 123456789+------+------+----------+------------+---------+| id | id+1 | (id+1)^1 | (id+1)^1-1 | student |+------+------+----------+------------+---------+| 1 | 2 | 3 | 2 | Abbot || 2 | 3 | 2 | 1 | Doris || 3 | 4 | 5 | 4 | Emerson || 4 | 5 | 4 | 3 | Green || 5 | 6 | 7 | 6 | Jeame |+------+------+----------+------------+---------+ 第二步：使用LEFT JOIN链接。 12345SELECT *FROM seat s1 LEFT JOIN seat s2 ON ( s1.id + 1 )^1 - 1 = s2.idORDER BY s1.id; 123456789+------+---------+------+---------+| id | student | id | student |+------+---------+------+---------+| 1 | Abbot | 2 | Doris || 2 | Doris | 1 | Abbot || 3 | Emerson | 4 | Green || 4 | Green | 3 | Emerson || 5 | Jeame | NULL | NULL |+------+---------+------+---------+ 第三步：使用COALESCE() 1234567SELECT s1.id, Coalesce(s2.student, s1.student) as studentFROM seat s1 LEFT JOIN seat s2 ON ( s1.id + 1 )^1 - 1 = s2.idORDER BY s1.id; 参考：Mysql文档 Returns the first non-NULL value in the list, or NULL if there are no non-NULL values.The return type of COALESCE() is the aggregated type of the argument types. 178. Rank Scores]]></content>
      <categories>
        <category>sql</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode算法题整理（位运算篇）Bit Manipulation]]></title>
    <url>%2FLeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AF%87%EF%BC%89Bit-Manipulation%2F</url>
    <content type="text"><![CDATA[191. Number of 1 Bits计算数字的二进制中有多少个1。原题123Input: 11Output: 3Explanation: Integer 11 has binary representation 00000000000000000000000000001011 方法一：常规解法，使用1与n作与运算，如果不是0说明，含有一个1。 1234567def hamming_weight(n): bits, mask = 0, 1 for _ in range(32): if n&amp;mask != 0: bits += 1 mask &lt;&lt;= 1 return bits 方法二：关键点是，一个数n和n-1的与运算操作，相当于去掉了最右面的1。 123456def hamming_weigth(n): bits = 0 while n: bits += 1 n = (n-1) &amp; n return bits 136. Single Number找出数组中不重复的元素。其它元素出现两次。原题12Input: [4,1,2,1,2]Output: 4 123def single_num(nums): from itertools import reduce return reduce(lambda x, y: x ^ y, nums) 137. Single Number II找出数组中出现一次的元素，其它元素出现三次。原题12Input: [2,2,3,2]Output: 3 方法一：找出单独元素每一位的值。如果把所有数字的二进制每一位加起来，如果某一位可以被3整除，则表示单独元素的该位为0，否则为1。以下使用count来表示每一位1的个数。假设count%3!=0为True，说明该元素i位为1，然后是用|=更新ans在第i个位置的值，这里也可以使用+=，但是效率稍慢。convert的作用是因为python中的int是个对象，且没有最大限制，不是在第32位使用1来表示负数。 1234567891011121314def singleNumber(self, nums, n=3): ans = 0 for i in range(32): count = 0 for num in nums: if ((num &gt;&gt; i) &amp; 1): count += 1 ans |= ((count%n!=0) &lt;&lt; i) return self.convert(ans)def convert(self, x): if x &gt;= 2**31: x -= 2**32 return x 这里有个状态机的解法，不明觉厉，留坑。讨论1和讨论2 123456def singleNumber(self, nums): ones, twos = 0, 0; for i in range(len(nums)): ones = (ones ^ nums[i]) &amp; ~twos twos = (twos ^ nums[i]) &amp; ~ones return ones 260. Single Number III找出数组中两个唯一出现一次的元素，其余元素均出现两次。原题12Input: [1,2,1,3,2,5]Output: [3,5] 思想：将这两个元素分到两个组，由于这两个数不相等，所以亦或结果不为0，也就是说二进制中至少有一位1，记为第n位。我们以第n位是否为1，把数组分为两个子数组。 123456789101112def singleNumber(self, nums): total_xor = self.get_xor(nums) mask = 1 while total_xor&amp;mask == 0: mask &lt;&lt;= 1 p1 = [num for num in nums if num&amp;mask==0] p2 = [num for num in nums if num&amp;mask!=0] return [self.get_xor(p1), self.get_xor(p2)] def get_xor(self, nums): from functools import reduce return reduce(lambda x, y: x ^ y, nums) 371. Sum of Two Integers不用加减乘除做加法。原题解析为何Python位运算有些不同 12345678910111213def getSum(self, a, b): # 32 bits integer max MAX = 0x7FFFFFFF # 2**31-1 # 32 bits interger min MIN = 0x80000000 # -2**31 # mask to get last 32 bits mask = 0xFFFFFFFF # 2*32-1 while b != 0: # ^ get different bits and &amp; gets double 1s, &lt;&lt; moves carry a, b = (a ^ b) &amp; mask, ((a &amp; b) &lt;&lt; 1) &amp; mask # if a is negative, get a's 32 bits complement positive first # then get 32-bit positive's Python complement negative return a if a &lt;= MAX else ~(a ^ mask) 190. Reverse Bits返回一个数的二进制的倒序的十进制。原题1234Input: 43261596Output: 964176192Explanation: 43261596 represented in binary as 00000010100101000001111010011100, return 964176192 represented in binary as 00111001011110000010100101000000. 方法一：使用原生库。ljust表示在右侧补’0’。或者使用format来补0。 123def reverseBits(self, n): return int(bin(n)[:1:-1].ljust(32, '0'), 2) # return int('&#123;:0&lt;32s&#125;'.format(bin(n)[:1:-1]), 2) 方法二：自己实现进制转换，使用位运算优化。 123456def reverseBits(self, n): code = '' for _ in range(32): code += str(n &amp; 1) n &gt;&gt;= 1 return sum([int(bit) &lt;&lt; i for i, bit in enumerate(code[::-1])]) 方法二改进：这里有个误区，为什么非要将整个二进制完整体现出来，再去遍历它转成int，而不是直接构建这个int。 123456def reverseBits(self, n): code = 0 for _ in range(32): code = (code&lt;&lt;1) + (n&amp;1) n &gt;&gt;= 1 return code 389. Find the Differences和t两个由小写字母组成的字符串，t是由s打乱顺序并再随机添加一个小写字母组成。原题方法一：使用Collection。 123def findTheDifference(self, s, t): from collections import Counter return next((Counter(t) - Counter(s)).elements()) 方法二：使用异或。 1234def findTheDifference(self, s, t): from operator import xor from functools import reduce return chr(reduce(xor, map(ord, s+t))) 401. Binary Watch有这样一个二进制的手表，输入一个n，表示有几个亮着的灯，返回所有可能出现的时间。时间范围为12小时制，即hours(0-11)，minutes(0-59)。原题 12Input: n = 1Return: [&quot;1:00&quot;, &quot;2:00&quot;, &quot;4:00&quot;, &quot;8:00&quot;, &quot;0:01&quot;, &quot;0:02&quot;, &quot;0:04&quot;, &quot;0:08&quot;, &quot;0:16&quot;, &quot;0:32&quot;] 一开始的思路：这是个错误的解法，因为分钟的灯不应该超过60分钟，因为要进位。类似的4和8的小时灯也不能同时亮起。 1234567def readBinaryWatch(self, num): from itertools import combinations # transform hours to minutes minutes = list(map(lambda x: x * 60, (1, 2, 4, 8))) + [32, 16, 8, 4, 2, 1] minutes_groups = combinations(minutes, num) res = ['&#123;:d&#125;:&#123;:0&gt;2d&#125;'.format(sum(g)//60, sum(g)%60) for g in minutes_groups] return res 方法二：正确的写法。需要分开判断小时和分钟，然后再合并。 123456789101112def readBinaryWatch(self, num): from itertools import combinations # transform hours to minutes hours = list(map(lambda x: x*60, (1, 2, 4, 8))) minutes = (1, 2, 4, 8, 16, 32) res = [] for i in range(num+1): get_hours = [x for x in list(combinations(hours, i)) if sum(x) &lt; 12 * 60] get_minutes = [x for x in list(combinations(minutes, num-i)) if sum(x) &lt; 60] minutes_groups = [h+m for h in get_hours for m in get_minutes] res += ['&#123;:d&#125;:&#123;:0&gt;2d&#125;'.format(sum(g)//60, sum(g)%60) for g in minutes_groups] return res 方法三：遍历所有可能的时间，找到符合条件的。因为表中的数组都是二进制，所以’1’的个数就是亮灯的个数。 1234def readBinaryWatch(self, num): return ['&#123;:d&#125;:&#123;:0&gt;2d&#125;'.format(h, m) for h in range(12) for m in range(60) if (bin(h)+bin(m)).count('1') == num] 405. Convert a Number to Hexadecimal把一个32位有符号的整数转换成16进制。原题123456789Input:26Output:&quot;1a&quot;Input:-1Output:&quot;ffffffff&quot; 123def toHex(self, num): return ''.join(['0123456789abcdef'[(num &gt;&gt; 4 * i) &amp; 15] for i in range(8)])[::-1].lstrip('0') or '0' 461. Hamming Distance求两个正数的原码中不同位的个数。原题1234567Input: x = 1, y = 4Output: 2Explanation:1 (0 0 0 1)4 (0 1 0 0) ↑ ↑The above arrows point to positions where the corresponding bits are different. 12def hammingDistance(self, x, y): return bin(x ^ y).count('1') 476. Number Complement给定一个正数，求其原码的按位取反后的数。原题123Input: 5Output: 2Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2. 方法一：暴力的方法。 12def findComplement(self, num): return int(''.join([str(1 ^ int(d)) for d in bin(num)[2:]]), 2) 方法二：其实就是求101和111的异或。所以先找到111。 12345def findComplement(self, num): i = 1 while i &lt;= num: i &lt;&lt;= 1 return (i-1) ^ num 方法三：更少的位移。核心思想还是找到111。比如一个8位数，最高代表符号：1000000，先将其右移1位，使得左边两位都变成1。然后再右移2位，使得左边四位变成1，以此类推，8位数最多移动3次就可以得到1111111，32位则还需要再移动2次。 12345def findComplement(self, num): mask = num for i in range(5): mask |= mask &gt;&gt; (2**i) return num ^ mask]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Bit Manipulation</tag>
        <tag>LeetCode</tag>
        <tag>Python</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode算法题整理（二分法篇）Binary Search]]></title>
    <url>%2FLeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E4%BA%8C%E5%88%86%E6%B3%95%E7%AF%87%EF%BC%89Binary-Search%2F</url>
    <content type="text"><![CDATA[704. Binary Search二分法在有序数组中查找元素。原题123Input: nums = [-1,0,3,5,9,12], target = 9Output: 4Explanation: 9 exists in nums and its index is 4 方法一：实现原理。 1234567891011def binary_search(nums, target): l, r = 0, len(nums)-1 while l &lt;= r: mid = (l+r) // 2 if nums[mid] &gt; target: r = mid - 1 elif nums[mid] &lt; target: l = mid + 1 else: return mid return -1 方法二：使用标准库。 1234def search(self, nums, target): from bisect import bisect_left index = bisect_left(nums, target) return index if index &lt; len(nums) and nums[index] == target else -1 35. Search Insert Position给定一个target，插入到一个有序数组中，假定数组中无重复元素。原题12Input: [1,3,5,6], 5Output: 2 方法一：实现原理。 1234567891011def binary_insert(nums, target): l, r = 0, len(nums)-1 while l &lt;= r: mid = (l+r) // 2 if nums[mid] &gt; target: r = mid - 1 elif nums[mid] &lt; target: l = mid + 1 else: return mid return l 方法二：使用标准库。 123def searchInsert(self, nums, target): from bisect import bisect_left return bisect_left(nums, target) 153. Find Minimum in Rotated Sorted Array通过一个排序数组旋转后的结果，找出最小元素。原题12Input: [3,4,5,1,2] Output: 1 思路：通过二分法不断缩小范围，由于mid是整除，最后l==mid，并且nums[mid] &gt; nums[r]的。 123456789101112def find_min(nums): l, r = 0, len(nums)-1 if nums[l] &lt; nums[r]: return nums[l] while l &lt;= r: mid = (l+r) // 2 if nums[mid] &gt; nums[l]: l = mid elif nums[mid] &lt; nums[r]: r = mid else: return nums[r] 34. Find First and Last Position of Element in Sorted Array有序数组中查找数组，返回数字的索引范围。原题1234Input: nums = [5,7,7,8,8,10], target = 8Output: [3,4]Input: nums = [5,7,7,8,8,10], target = 6Output: [-1,-1] 12345678910111213141516def searchRange(self, nums, target): left_idx = self.search_edge(nums, target, True) if left_idx == len(nums) or nums[left_idx] != target: return [-1, -1] return [left_idx, self.search_edge(nums, target, False)-1] def search_edge(self, nums, target, left): l, r = 0, len(nums) while l &lt; r: mid = (l+r) // 2 if nums[mid] &gt; target or (left and nums[mid]==target): r = mid else: l = mid + 1 return l 278. First Bad Version找出提交版本中的bad version。原题1234567Given n = 5, and version = 4 is the first bad version.call isBadVersion(3) -&gt; falsecall isBadVersion(5) -&gt; truecall isBadVersion(4) -&gt; trueThen 4 is the first bad version. 123456789def firstBadVersion(self, n): l, r = 1, n while l &lt;= r: mid = (l+r) // 2 if isBadVersion(mid): r = mid - 1 else: l = mid + 1 return l 374. Guess Number Higher or Lower猜数游戏1~n，每猜一次会告诉你答案是更小还是更大。原题12345678def guess(num): return -1 : My number is lower 1 : My number is higher 0 : Congrats! You got it! Input: n = 10, pick = 6Output: 6 方法一：实现原理。 12345678910def guessNumber(self, n): l, r = 1, n while l &lt;= r: mid = (l+r) // 2 if guess(mid) == -1: r = mid - 1 elif guess(mid) == 1: l = mid + 1 else: return mid 方法二：使用标准库。此答案受stefan大神启发。核心思想为将guess返回的结果转为一个数组，然后使用二分法查找。 1234567def guessNumber(self, n): from bisect import bisect, bisect_left class C: def __getitem__(self, x): return -guess(x) # return bisect(C(), -1, 1, n) return bisect_left(C(), 0, 1, n) 解析：以n=10, pick=6为例。实际上C class相当于: 1234ary = map(lambda x: -guess(x), range(1, n+1))ary.insert(0, None)# ary = [None, -1, -1, -1, -1, -1, 0, 1, 1, 1, 1]return bisect(ary, -1, 1, n) 而索引又是从1开始，所以这里在前面添加了一个None，实际上将题转为了查找ary的0，问题便迎刃而解。值得注意的是，如果使用了map，会导致空间，时间复杂度增加，而使用class的方法，并没有求出整个的list，所以效率更高。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
        <tag>Algorithm</tag>
        <tag>Binary Search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer]]></title>
    <url>%2F%E5%89%91%E6%8C%87Offer%2F</url>
    <content type="text"><![CDATA[2. 实现Singleton模式使用__new__控制实例创建过程12345678class Singleton: def __new__(cls, *args, **kw): if not hasattr(cls, '_instance'): cls._instance = super(Singleton, cls).__new__(cls, **args, **kw) return cls._instanceclass Myclass(Singleton): pass 使用decorator12345678910111213from functools import wrapsdef singleton(cls): instances = &#123;&#125; @wraps(cls) def get_instance(*args, **kw): if cls not in instances: instances[cls] = cls(*args, **kw) return instances[cls] return get_instance@singletonclass Myclass: pass 使用元类12 4. 二维数组中的查找1234567891011def find(target, array): row = 0 col = len(array[0]) - 1 while col &gt;= 0 and row &lt;= len(array)-1: if array[row][col] &gt; target: col -= 1 elif array[row][col] &lt; target: row += 1 else: return True return False 5.替换空格123456def replaceSpace(self, s): chars = list(s) for i, char in enumerate(chars): if char == ' ': chars[i] = '%20' return ''.join(chars) 6.从尾到头打印链表123456def printListFromTailToHead(self, listNode): stack = [] while listNode: stack.append(listNode.val) listNode = listNode.next return stack[::-1] 7.重建二叉树说明：根据前序遍历和中序遍历重建二叉树，假设遍历结果中不包含重复的数字。105. Construct Binary Tree from Preorder and Inorder Traversal 9.用两个栈实现队列232. Implement Queue using Stacks 9.1用两个队列实现栈225. Implement Stack using Queues 10.斐波那契数列说明：爬楼梯问题的抽象70. Climbing Stairs 11.旋转数组的最小数字说明：通过一个递增数组旋转后的数组，找出最小元素。153. Find Minimum in Rotated Sorted Array 12.矩阵中的路径说明：回溯法。这道题在牛客网上做的，参考了排行前几的答案，却发现了问题，前几的答案中，find方法中的循环都在条件中直接return，这样依赖于整个条件判断的顺序，奇怪的是这样居然可以通过测试用例，可见牛客网的权威性还是不如LeetCode。例如输入matrix = &#39;ABEESFCSADME&#39;, rows=3, cols=4, path=&#39;SEE&#39;返回了False，实际应该返回True。正确的做法不应直接return，而是保存结果用or判断，判断中也不应该使用elif。 12345678910111213141516171819202122232425# -*- coding:utf-8 -*-class Solution: def hasPath(self, matrix, rows, cols, path): # write code here for i in range(rows): for j in range(cols): if matrix[i*cols + j] == path[0]: if self.spread(list(matrix), rows, cols, path[1:], i, j): return True return False def spread(self, matrix, rows, cols, path, i, j): if not path: return True matrix[i*cols + j] = '-' up, down, left, right = False, False, False, False if j + 1 &lt; cols and matrix[i * cols + j + 1] == path[0]: down = self.spread(matrix, rows, cols, path[1:], i, j + 1) if j - 1 &gt;= 0 and matrix[i * cols + j - 1] == path[0]: left = self.spread(matrix, rows, cols, path[1:], i, j - 1) if i + 1 &lt; rows and matrix[(i + 1) * cols + j] == path[0]: right = self.spread(matrix, rows, cols, path[1:], i + 1, j) if i - 1 &gt;= 0 and matrix[(i - 1) * cols + j] == path[0]: up = self.spread(matrix, rows, cols, path[1:], i - 1, j) return up or down or left or right 13. 机器人的运动范围12345678910111213141516171819202122232425# -*- coding:utf-8 -*-class Solution: def movingCount(self, threshold, rows, cols): # write code here self.visited = [False] * rows * cols self.movingCountCore(threshold, rows, cols, 0, 0) return sum(self.visited) def movingCountCore(self, threshold, rows, cols, i, j): if self.get_double_sum(i, j) &lt;= threshold: self.visited[i*cols + j] = True if i-1&gt;=0 and not self.visited[(i-1)*cols+j]: self.movingCountCore(threshold, rows, cols, i-1, j) if i+1&lt;rows and not self.visited[(i+1)*cols+j]: self.movingCountCore(threshold, rows, cols, i+1, j) if j-1&gt;=0 and not self.visited[i*cols+j-1]: self.movingCountCore(threshold, rows, cols, i, j-1) if j+1&lt;cols and not self.visited[i*cols+j+1]: self.movingCountCore(threshold, rows, cols, i, j+1) def get_digit_sum(self, num): return sum(map(int, str(num))) def get_double_sum(self, i, j): return self.get_digit_sum(i) + self.get_digit_sum(j) 14.剪绳子说明：数学思想，当n&gt;=5时，2(n-2)&gt;n并且3(n-3)&gt;n，而且3(n-3) &gt;= 2(n-2)，所以尽可能多剪长度为3的绳子。如果长度为4的时候，2*2&gt;3*1，所以4的时候就剪成2*2的两段。 12345678910111213def cut_rope(length): if length &lt; 2: return 0 if length == 2: return 1 if length == 3: return 2 timesOf3 = length // 3 if length-timesOf3*3 == 1: timeOf3 -= 1 timesOf2 = (length-timesOf3*3) // 2 return (3**timesOf3) * (2**timesOf2) 15.二进制中1的个数191. Number of 1 Bits 16.数值的整数次方50. Pow(x, n) 18.删除链表中的节点237. Delete Node in a Linked List 19.正则表达式10. Regular Expression Matching 先考虑没有*的情况，通过一个递归逐个字符判断 1234def match(text, pattern): if not pattern: return not text first_match = bool(text) and pattern[0] in &#123;text[0], '.'&#125; return first_match and match(text[1:], pattern[1:]) 当*出现时，一定会在前面跟一个其他字符，所以一定会出现在pattern[1]的位置。一种情况是我们忽略这对pattern，因为可以出现0次；另一种情况是匹配上这个字符，用递归的方式匹配下一个。 12345678def match(text, pattern): if not pattern: return not text first_match = bool(text) and pattern[0] in &#123;text[0], '.'&#125; if len(pattern) &gt;= 2 and pattern[1] == '*': return match(text, pattern[2:]) or \ (first_match and match(text[1:], pattern) else: return first_match and match(text[1:], pattern[1:]) 20. 表示数值的字符串65. Valid Number此处留坑，排名第一的python答案暂时没有理解。 21.调整数组顺序使奇数位于偶数前面 时间：O(n), 空间O(1) 123456789def reOrderArray(self, array): # write code here l, r = 0, len(array)-1 while l &lt; r: while l &lt; r and array[l]&amp;1 == 1: l += 1 while l &lt; r and array[r]&amp;1 == 0: r -= 1 array[l], array[r] = array[r], array[l] 看了一下没有通过牛客网的测试用例，因为题目有些不同，牛客网要求奇数和奇数，偶数和偶数之前的相对位置不变。 12def reOrderArray(array): return sorted(array, key=lambda x:x&amp;1==0) 不使用sort 1234567891011def reOrderArray(self, array): # write code here from collections import deque q = deque() n = len(array) for i in range(n): if array[n-1-i] &amp; 1 == 1: # 从后找奇数 q.appendleft(array[n-1-i]) if array[i] &amp; 1 == 0: #从前找偶数 q.append(array[i]) return q 22.链表中倒数第k个节点思路：两个指针，快指针先走k-1步，然后两个一起走，快指针走到尾节点时，慢指针在倒数第k个节点。需考虑k=0时和fast已经走到尾节点的情况。 12345678910111213141516def FindKthToTail(self, head, k): # write code here if k == 0: return None fast = slow = head for _ in range(k-1): if fast and fast.next: fast = fast.next else: return None while fast.next: slow = slow.next fast = fast.next return slow 23.链表中环的入口节点142. Linked List Cycle II 24.反转链表206. Reverse Linked List 25.合并两个有序链表21. Merge Two Sorted Lists 26.树的子结构572. Subtree of Another Tree 27.二叉树的镜像123456def Mirror(self, root): # write code here if root: root.left, root.right = root.right, root.left self.Mirror(root.left) self.Mirror(root.right) 28.对称的二叉树101. Symmetric Tree 29.顺时针打印矩阵说明：书中的方法过于繁琐，这里参考了一个LeetCode大神的解法。主要思想是每次取出数组的第一行，然后将整个数组逆时针旋转90°。 54. Spiral Matrix 30.包含min函数的栈155. Min Stack 31.栈的压入、弹出序列思路：如果下一个弹出的数字是栈顶数字，直接弹出；如果下一个弹出的数字不在栈顶，则把没有入栈的数字压入栈，如果入栈序列为空，则返回False 123456789101112131415class Solution: def IsPopOrder(self, pushV, popV): # write code here stack = [] for i in range(len(popV)): while True: if stack and popV[i]==stack[-1]: stack.pop() break else: if pushV: stack.append(pushV.pop(0)) else: return False return True 32.从上到下打印二叉树 双端队列 123456789101112def PrintFromTopToBottom(self, root): # write code here from collections import deque queue = deque([root]) res = [] while len(queue) != 0: cur = queue.popleft() if cur: res.append(cur.val) queue.append(cur.left) queue.append(cur.right) return res 分层思想，主要为了下一题 12345678910def PrintFromTopToBottom(self, root): # write code here res, level = [], [root] while root and level: res.extend([node.val for node in level]) temp = [] for node in level: temp.extend([node.left, node.right]) level = [leaf for leaf in temp if leaf] return res 32.1分层从上到下打印二叉树102. Binary Tree Level Order Traversal 32.2之字形打印二叉树103. Binary Tree Zigzag Level Order Traversal 33.二叉树的后序遍历145. Binary Tree Postorder Traversal 34.二叉树和为某一值的路径113. Path Sum II 35.复杂链表的复制138. Copy List with Random Pointer 36.二叉搜索树与双向链表此题留坑。 37.序列化二叉树297. Serialize and Deserialize Binary Tree 38.字符串的排列46. Permutations II 使用itertools 123456def Permutation(self, ss): # write code here from itertools import permutations if not ss: return [] return sorted(list(set([''.join(x) for x in permutations(ss)]))) 这里注意几点： 为什么要判断if not ss，是因为如果ss=&#39;&#39;的时时候，返回了[&#39;&#39;]而不是[]。因为这里返回了一个空的tuple，所以在列表推导式中是有一个元素的。 12&gt;&gt;&gt; list(permutations('', 0))[()] 为什么使用set去重，因为当ss=&#39;aa&#39;的时候，牛客网的测试用例要求返回一个元素，即[&#39;aa&#39;]。 排序也是为了满足测试用例。 自己实现。这里拆成两个方法的原因还是因为ss=&#39;&#39;的时候会影响递归循环。 1234567891011def Permutation(self, ss): # write code here if not ss: return [] return self.permute(ss)def permute(self, ss): return sorted(list(set([h + p for i, h in enumerate(ss) for p in self.permute(ss[:i]+ss[i+1:]) ]))) or [""] 39.数组中出现次数超过一半的数字169. Majority Element 40.最小的k个数相似题目。LeetCode这道题返回的是最大的第k个数。 215. Kth Largest Element in an Array 12345678910111213141516171819202122def GetLeastNumbers_Solution(self, tinput, k): # write code here l, r = 0, len(tinput)-1 if k &gt; len(tinput) or k &lt; 1: return [] # for passing the damn testcase while True: pos = self.partition(tinput, l, r) if pos &lt; k-1: l = pos + 1 elif pos &gt; k-1: r = pos - 1 else: return sorted(tinput[:pos+1]) # sorted for passing the damn testcase def partition(self, nums, l, r): from random import randint p = randint(l, r) nums[r], nums[p] = nums[p], nums[r] for i, v in enumerate(nums[l:r+1], l): if nums[i] &lt;= nums[r]: nums[l], nums[i] = nums[i], nums[l] l += 1 return l-1 # the pivot index 41.数据流中的中位数295. Find Median from Data Stream 42.连续子数组的最大和53. Maximum Subarray 43.1~n整数中1出现的次数233. Number of Digit One 45.把数组排成最小的数字python2的写法。 12345def PrintMinNumber(self, numbers): # write code here nums = map(str, numbers) nums.sort(lambda x, y: cmp(x+y, y+x)) return ''.join(nums) 匿名函数作为sort的参数，在python2中有这个参数。 cmp specifies a custom comparison function of two arguments (iterable elements) which should return a negative, zero or positive number depending on whether the first argument is considered smaller than, equal to, or larger than the second argument: cmp=lambda x,y: cmp(x.lower(), y.lower()). The default value is None. 作为sort的参数，cmp提供了一个自定义的比较两个元素的方法，如果返回-1表示前者小于后者。python3中取消了这个参数，但是提供了一种key的转换。而内置函数可以通过运算符实现。 1cmp(a, b) 等同于 1(a&gt;b) - (a&lt;b) 所以python3的写法如下： 123456from functools import cmp_to_keydef PrintMinNumber(self, numbers): # write code here nums = list(map(str, numbers)) nums.sort(key=cmp_to_key(lambda x, y: ((x+y)&gt;(y+x)) - ((y+x)&gt;(x+y)))) return ''.join(nums) 48.最长不含重复字符的子字符串3. Longest Substring Without Repeating Characters 49.丑数264. Ugly Number II 50.第一个只出现一次的字符有些区别，LeetCode上输出索引，书中让输入字符，因此实现有区别。 387. First Unique Character in a String 这里用OrderedDict做计数器，Time-O(2n), Space-O(2n) 12345678910111213def firstUniqChar(self, s): from collections import OrderedDict counter = OrderedDict() for ch in s: if ch not in counter: counter[ch] = 1 else: counter[ch] += 1 for k, v in counter.items(): if v == 1: return k return '' 51.数组中的逆序对开始以为效率有点低，牛客网的时间是3900ms，时间估计浪费在将deque转换成list上了。然后不信邪的我粘贴了一下排行榜第一的答案，上面写着运行时间2122ms，然后我提交了一下3500ms，？？？[黑人问号]，是我打开方式不对？又提交一次直接超时？？对牛客网的运行时间有了新的认识。虽然LeetCode的也不准，但是也不至于太离谱吧。 123456789101112131415161718192021222324252627282930from collections import dequeclass Solution: def InversePairs(self, data): # write code here self.p = 0 self.merge_sort(data) return self.p % 1000000007 # damn testcase def merge_sort(self, ary): if len(ary) &lt;= 1: return ary num = len(ary) // 2 left = self.merge_sort(ary[:num]) right = self.merge_sort(ary[num:]) return self.merge(left, right) def merge(self, left, right): ln, rn = len(left), len(right) res, l, r = deque(), ln-1, rn-1 while l &gt;= 0 and r &gt;= 0: if left[l] &gt; right[r]: self.p += (r+1) # res.insert(0, left[l]) res.appendleft(left[l]) l -= 1 else: # res.insert(0, right[r]) res.appendleft(right[r]) r -= 1 res = left[:l+1] + right[:r+1] + list(res) return res 52.两个链表的第一个公共节点160. Intersection of Two Linked Lists 53.在排序数组中查找数字相似题目，LeetCode是求出数字的索引，书中返回个数。 34. Find First and Last Position of Element in Sorted Array 53.0~n-1中缺失的数字相似题目，LeetCode是未排序，书中是已排序。所以可以利用排序的特性使时间复杂度小于O(n)。即找出第一个下标与值不相等的元素，再-1就是缺失的元素。 268. Missing Number 123456789def find_missing(nums): l, r = 0, len(nums)-1 while l &lt; r: mid = (l+r) &gt;&gt; 1 if nums[mid] == mid: l = mid + 1 else: r = mid return nums[r]-1 54.二叉搜索树的第k大节点牛客网上是求第k小节点，这里被坑了一次，然后返回值居然要求返回节点对象，而不是节点值，否则一直报错，WTF。这里的答案按书中返回。如果是牛客网上需要把节点添加到res中，然后return res[k-1] 123456789101112131415def KthNode(self, pRoot, k): # write code here stack, res = [], [] while True: while pRoot: stack.append(pRoot) pRoot = pRoot.left if stack == []: break cur = stack.pop() res.append(cur.val) pRoot = cur.right if k &lt; 1 or k &gt; len(res): return None return res[-k] 55.二叉树的深度104. Maximum Depth of Binary Tree 55.1平衡二叉树110. Balanced Binary Tree 56 数组中只出现一次的两个数字。260. Single Number III 56.1数组中出现一次的数字，其余元素出现三次。137. Single Number II 57.和为s的数字看牛客网上的描述，如果有多对数字和为s，要求返回乘积最小的一对。乍一看以为牛客网又乱改题，但是仔细一想，如果两个和为s的数，而且是在递增数组中很明显，边缘的数字乘积要小，例如8X8&gt;1X15。所以还是和书中解法一样。 1234567891011def FindNumbersWithSum(self, array, tsum): # write code here l, r = 0, len(array)-1 while l &lt; r: if array[l] + array[r] &lt; tsum: l += 1 elif array[l]+array[r] &gt; tsum: r -= 1 else: return array[l], array[r] return [] 58.翻转字符串。151. Reverse Words in a String 59.滑动窗口的最大值。得益于python的切片。 123def maxInWindows(self, num, size): return [max(num[i:i+size]) for i in range(len(num)-size+1) if size!=0 ] 60.n个骰子的点数关于此题的实现，并没有找到特别pythonic的解法，大多都是直接从c++’翻译’过来的，参考leetcode之n个骰子的点数，python版本，在此之上做了一些优化。dp表示所有骰子的结果集合，dp中的元素表示该骰子所有的次数集合，如下n=2后，dp为 1[[1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0], [0, 1, 2, 3, 4, 5, 6, 5, 4, 3, 2, 1]] dp[0][j]==1表示第一个骰子和为j+1的次数为1，因为数组下标从0开始。 12345678910111213141516def dice_probability(n, val=6): dp = [[0]*val*n for _ in range(n)] dp[0][:val] = [1] * val # 初始化第一个骰子 for i in range(n-1): # 根据第i个骰子更新第i+1个骰子 for j in range(i, len(dp[i+1])): # 第i+1个骰子和为j（实际为j+1，因为数组下标从0开始）的次数，等于第i个 # 骰子j-1 ~ j-6次数的总和 dp[i+1][j] = sum([dp[i][j-k] for k in range(1, val+1)]) # 整理数据成为dict，key表示和，value表示出现的次数 # count = &#123;i+1: times for i, times in enumerate(dp[-1])&#125; # 计算概率 count = &#123;i+1: round(float(times / (val**n)), 5) for i, times in enumerate(dp[-1]) if times!=0&#125; return count 感觉用dict来表示更加明确，没有数组下标从0开始的混淆。 1234567891011121314def dice_probability_dict(n, val=6): from collections import defaultdict dp = [defaultdict(int) for _ in range(n)] dp[0].update(&#123;k: 1 for k in range(1, val+1)&#125;) # 初始化第一个骰子 for i in range(n-1): # 根据第i个骰子更新第i+1个骰子 for j in range(n*(i+1), val*n+1): # n个骰子最小值为n*(i+1)，最大值为val*n # 第i+1个骰子和为j（实际为j+1，因为数组下标从0开始）的次数，等于第i个 # 骰子j-1 ~ j-6次数的总和 dp[i+1][j] = sum([dp[i][j-k] for k in range(1, val+1)]) # 这时的dp[-1]就是得到我们想要的了，只不过值为出现的次数，我们算一下概率 count = &#123;k: round(float(times / (val**n)), 5) for k, times in dp[-1].items()&#125; return count 61.扑克牌中的顺子开始以为还要用个dict来映射值，后来发现直接传得卡牌的值。思想就是先排序，然后查joker的数量，看剩下牌的差值加起来能不能用已有的joker连起来。 12345678910111213def IsContinuous(self, numbers): # poker = &#123;k: k for k in range(2, 11)&#125; # poker.update(&#123;'A': 1, 'J': 11, 'Q': 12, 'K': 13, '0': 0&#125;) if not numbers: return False joker_count = numbers.count(0) left_cards = sorted(numbers)[joker_count:] need_joker = 0 for i in range(len(left_cards)-1): if left_cards[i+1] == left_cards[i]: return False need_joker += (left_cards[i+1]-left_cards[i]-1) return need_joker &lt;= joker_count 62.圆圈中最后剩下的数字方法一：其实不需要环形链表，使用一个list足矣，每次将其旋转rot位，一开始想将要把第m个数旋转到list首部，然后再pop(0)，后来想到直接可以通过切片取出来，节省了pop(0)的O(n)复杂度。 123456789def LastRemaining_Solution(self, n, m): # write code here if n&lt;=0 or m&lt;=0: return -1 seats = range(n) while seats: rot = (m-1) % len(seats) seats, last = seats[rot+1:] + seats[:rot], seats[rot] return last 方法二：书中的推导过程过于复杂，这里学到了一个稍微简单的推导过程。参考约瑟夫环问题。 解析Josephus-problem 1234567def LastRemaining_Solution(self, n, m): if n&lt;=0 or m&lt;=0: return -1 last_num = 0 for i in range(2, n+1): last_num = (last_num+m) % i return last_num 63.股票的最大利润121. Best Time to Buy and Sell Stock 64.求1+2+···+n这题对python不是很友好，感觉and也属于条件判断语句。reduce`sum`之类的属于作弊行为，这里就不贴了。 123def Sum_Solution(self, n): # write code here return n and (n+self.Sum_Solution(n-1)) 65.不用加减乘除做加法371. Sum of Two Integers]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithm</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python排序算法]]></title>
    <url>%2FPython%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[快速排序 快排算是应用中广泛的排序算法了。由于实现简单，适用于不同的输入数据且在一般应用中比其他排序算法要快。快排的一个特点是原地排序，内循环比大多数排序算法要短小。它的主要缺点是非常脆弱，在实现中要非常小心才能避免低劣的性能。 快排是一种分治的排序算法。它将一个数组分成两个子数组，将两部分独立地排序。快排和归并排序是互补的：归并排序将数组分成两个子数组分别排序，并将有序的子数组归并以将整个数组排序，递归调用发生在处理整个数组之前；而快排将数组排序的方式则是当两个子数组都有序时整个数组自然也就有序了，递归调用发生在处理整个数组之后。 按照《算法第4版》中的例子，实现一个标准的python解法。 1234567891011121314151617181920212223242526import randomdef quick_sort(a): random.shuffle(a) # 消除输入依赖，保持随机性，也可使用随机选取切分元素 quick_sort_divide(a, 0, len(a)-1) def quick_sort_divide(a, lo, hi): if hi &lt;= lo: return j = partition(a, lo, hi) quick_sort_divide(a, lo, j-1) quick_sort_divide(a, j+1, hi) def partition(a, lo, hi): i, j = lo+1, hi pivot = a[lo] # 选取第一个元素作为切分元素 while True: while a[i]&lt;pivot and i&lt;hi: # 遇到大于等于pivot时停止，某些情况可以避免算法运行时间变为平方级别 i += 1 while a[j]&gt;pivot and j&gt;lo: j -= 1 if i &gt;= j: break a[i], a[j] = a[j], a[i] a[lo], a[j] = a[j], a[lo] return j 性能分析： 内循环使用一个递增的索引将数组元素和一个定值比较，相对于归并和希尔的在内循环中移动数据的方法更快，更简洁。 比较的次数很少。排序效率依赖切分数组的效果。 冒泡排序123456789101112def bubble_sorted(nums): res = list(nums) n = len(res) for i in range(n-1, 0, -1): flag = True for j in range(0, i): if res[j] &gt; res[j+1]: res[j], res[j+1] = res[j+1], res[j] flag = False if flag: return res return res 选择排序12345678910def select_sorted(nums): res = list(nums) n = len(res) for i in range(n-1): min_i = i for j in range(i+1, n): if res[min_i] &gt; res[j]: min_i = j res[min_i], res[i] = res[i], res[min_i] return res 插入排序 1234567891011121314def inset_sorted(nums): res = list(nums) n = len(res) for i in range(1, n): val = res[i] # 待插入值 index = i # 待插入下标 for j in range(i-1, -1, -1): if res[j] &gt; val: res[j+1] = res[j] index = j else: break res[index] = val return res 希尔排序一直觉得网上的希尔排序方式不够pythonic，这里写了一个调用插入排序的方法。 123456789def shell_sorted(nums): res = list(nums) n = len(res) step = round(n/2) while step &gt; 0: for i in range(step): res[i:n:step] = insert_sorted(res[i:n:step]) step = round(step/2) return res 归并排序 123456789101112131415161718def merge_sort(ary): if len(ary) &lt;= 1 : return ary num = len(ary) // 2 left = merge_sort(ary[:num]) right = merge_sort(ary[num:]) return merge(left, right) def merge(left, right): res, l, r = [], 0, 0 while l&lt;len(left) and r&lt;len(right) : if left[l] &lt; right[r]: res.append(left[l]) l += 1 else: res.append(right[r]) r += 1 res += left[l:] or right[r:] return res]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithm</tag>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode算法题整理（设计篇）Design]]></title>
    <url>%2FLeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E8%AE%BE%E8%AE%A1%E7%AF%87%EF%BC%89Design%2F</url>
    <content type="text"><![CDATA[155. Min Stack设计一个栈，要求在常数时间复杂度取出最小值。原题 12345678MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin(); --&gt; Returns -3.minStack.pop();minStack.top(); --&gt; Returns 0.minStack.getMin(); --&gt; Returns -2. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class MinStack: def __init__(self): """ initialize your data structure here. """ self._stack = [] def push(self, x): """ :type x: int :rtype: void """ prev = self.getMin() if prev is None or x &lt; prev: prev = x self._stack.append((x, prev)) def pop(self): """ :rtype: void """ return self._stack.pop() def top(self): """ :rtype: int """ if self._stack == []: return None return self._stack[-1][0] def getMin(self): """ :rtype: int """ if self._stack == 0: return None return self._stack[-1][1] # Your MinStack object will be instantiated and called as such:# obj = MinStack()# obj.push(x)# obj.pop()# param_3 = obj.top()# param_4 = obj.getMin() 232. Implement Queue using Stacks使用两个栈实现一个队列。原题1234567MyStack stack = new MyStack();stack.push(1);stack.push(2); stack.top(); // returns 2stack.pop(); // returns 2stack.empty(); // returns false 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class MyQueue: def __init__(self): """ Initialize your data structure here. """ self.in_stack, self.out_stack = [], [] def push(self, x): """ Push element x to the back of queue. :type x: int :rtype: void """ self.in_stack.append(x) def pop(self): """ Removes the element from in front of queue and returns that element. :rtype: int """ self.move() return self.out_stack.pop() def peek(self): """ Get the front element. :rtype: int """ self.move() return self.out_stack[-1] def empty(self): """ Returns whether the queue is empty. :rtype: bool """ return self.in_stack == self.out_stack == [] def move(self): """ move the element from in_stack to out_stack """ if self.out_stack == []: while self.in_stack: self.out_stack.append(self.in_stack.pop()) 225. Implement Stack using Queues使用队列实现栈。原题方法一：两个队列，push-O(1), pop/top O(n) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748from collections import dequeclass MyStack: def __init__(self): """ Initialize your data structure here. """ self.q1, self.q2 = deque(), deque() def push(self, x): """ Push element x onto stack. :type x: int :rtype: void """ self.q1.append(x) def pop(self): """ Removes the element on top of the stack and returns that element. :rtype: int """ while len(self.q1) != 1: self.q2.append(self.q1.popleft()) pop_val = self.q1.popleft() self.q1, self.q2 = self.q2, self.q1 return pop_val def top(self): """ Get the top element. :rtype: int """ while len(self.q1) != 1: self.q2.append(self.q1.popleft()) pop_val = self.q1[0] self.q2.append(self.q1.popleft()) self.q1, self.q2 = self.q2, self.q1 return pop_val def empty(self): """ Returns whether the stack is empty. :rtype: bool """ return len(self.q1) == 0 方法二：两个队列，push-O(n), pop/top-O(1) 1234567891011121314151617181920212223242526272829303132333435363738394041from collections import dequeclass MyStack: def __init__(self): """ Initialize your data structure here. """ self.q1, self.q2 = deque(), deque() def push(self, x): """ Push element x onto stack. :type x: int :rtype: void """ self.q2.append(x) while self.q1: self.q2.append(self.q1.popleft()) self.q1, self.q2 = self.q2, self.q1 def pop(self): """ Removes the element on top of the stack and returns that element. :rtype: int """ return self.q1.popleft() def top(self): """ Get the top element. :rtype: int """ return self.q1[0] def empty(self): """ Returns whether the stack is empty. :rtype: bool """ return len(self.q1) == 0 方法三：一个队列旋转 12345678910111213141516171819202122232425262728293031323334353637383940from collections import dequeclass MyStack: def __init__(self): """ Initialize your data structure here. """ self.queue = deque() def push(self, x): """ Push element x onto stack. :type x: int :rtype: void """ self.queue.append(x) for _ in range(len(self.queue)-1): self.queue.append(self.queue.popleft()) def pop(self): """ Removes the element on top of the stack and returns that element. :rtype: int """ return self.queue.popleft() def top(self): """ Get the top element. :rtype: int """ return self.queue[0] def empty(self): """ Returns whether the stack is empty. :rtype: bool """ return len(self.queue) == 0 295. Find Median from Data Stream找出数据流中的中位数。原题思路：使用两个堆，最大堆存储较小的数据，最小堆存储较大的数据。添加数字时，先添加到最大堆，然后最大堆返回一个最大的数字给最小堆，最后为了平衡，可能需要最小堆还给最大堆一个最小值，以保证最大堆的长度&gt;=最小堆的长度。由于headpq是最小堆，所以使用取反实现最大堆。添加数字：Time-O(logn)，取出中位数：Time-O(1)。 12345678910111213141516171819import heapq as hqclass MedianFinder: def __init__(self): self.lo, self.hi = [], [] # lo is max_heap, hi is min_heap def addNum(self, num): hq.heappush(self.lo, -num) hq.heappush(self.hi, -hq.heappop(self.lo)) if len(self.lo) &lt; len(self.hi): hq.heappush(self.lo, -hq.heappop(self.hi)) def findMedian(self): if len(self.lo) == len(self.hi): return (-self.lo[0]+self.hi[0]) / 2.0 else: return float(-self.lo[0]) 535. Encode and Decode TinyURL设计一个短链接。原题1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class Codec: BASE = 62 UPPERCASE_OFFSET = 55 LOWERCASE_OFFSET = 61 DIGIT_OFFSET = 48 num_sender = 0 url = &#123;&#125; def encode(self, longUrl): """Encodes a URL to a shortened URL. :type longUrl: str :rtype: str """ if Codec.num_sender == 0: Codec.url[Codec.num_sender] = longUrl return '0' s_url = '' while Codec.num_sender &gt; 0: tail = Codec.num_sender % Codec.BASE s_url = self.parse_chr(tail) + s_url Codec.num_sender //= Codec.BASE Codec.url[Codec.num_sender] = longUrl Codec.num_sender += 1 return s_url def decode(self, shortUrl): """Decodes a shortened URL to its original URL. :type shortUrl: str :rtype: str """ num = 0 for i, char in enumerate(reversed(shortUrl)): num += self.parse_ord(char) * (Codec.BASE**i) return Codec.url[num] def parse_ord(self, char): if char.isdigit(): return ord(char) - Codec.DIGIT_OFFSET elif char.islower(): return ord(char) - Codec.LOWERCASE_OFFSET elif char.isupper(): return ord(char) - Codec.UPPERCASE_OFFSET else: raise ValueError('%s is not a valid character' % char) def parse_chr(self, integer): if integer &lt; 10: return chr(integer + DIGIT_OFFSET) elif 10 &lt;= integer &lt;= 35: return chr(integer + UPPERCASE_OFFSET) elif 36 &lt;= integer &lt; 62: return chr(integer + LOWERCASE_OFFSET) else: raise ValueError('%d is not a valid integer in the range of base %d' % (integer, Codec.BASE))]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
        <tag>Algorithm</tag>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode算法题整理（二叉树篇）Tree]]></title>
    <url>%2FLeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AF%87%EF%BC%89Tree%2F</url>
    <content type="text"><![CDATA[树的定义12345class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None 144. Binary Tree Preorder Traversal二叉树前序遍历12345678Input: [1,null,2,3] 1 \ 2 / 3Output: [1,2,3] 方法一：iteratively 12345678910def preorder_traversal(root): nodes = [root] res = [] while nodes: cur_node = nodes.pop() if cur_node: res.append(cur_node.val) nodes.append(cur_node.right) nodes.append(cur_node.left) return res 方法二：recursively 12345def preorder_traversal(root): if not root: return [] return [root.val] + self.preorderTraversal(root.left) \ + self.preorderTraversal(root.right) 589. N-ary Tree Preorder TraversalN-叉树的前序遍历。N叉树和二叉树有个区别，就是N叉树不需要考虑子节点知否为空，做单独的判断。原题方法一：recursively. 1234567def preorder(self, root): if not root: return [] res = [root.val] for child in root.children: res += self.preorder(child) return res 方法二：iteratively. 1234567def preorder(self, root): res, stack = [], root and [root] while stack: node = stack.pop() res.append(node.val) stack.extend(reversed(node.children)) return res 94. Binary Tree Inorder Traversal中序遍历二叉树12345678Input: [1,null,2,3] 1 \ 2 / 3Output: [1,3,2] 123456789101112def inorder_traversal(root): stack = [] res = [] while True: while root: stack.append(root) root = root.left if stack == []: return res cur = stack.pop() res.append(cur.val) root = cur.right 145. Binary Tree Postorder Traversal后序遍历二叉树12345678Input: [1,null,2,3] 1 \ 2 / 3Output: [3,2,1] 方法一：根右左，再倒序。 123456789def postorder_traversal(root): res, stack = [], [root] while stack: node = stack.pop() if node: res.append(node.val) stack.append(node.left) stack.append(node.right) return res[::-1] 方法二：思想: 使用last作为判断是否该节点的右子树完成遍历，如果一个node.right已经刚刚遍历完毕，那么将last==node.right，否则将会寻找node.right。 123456789101112131415def postorderTraversal(self, root): res, stack, node, last = [], [], root, None while stack or node: if node: stack.append(node) node = node.left else: node = stack[-1] if not node.right or last == node.right: node = stack.pop() res.append(node.val) last, node = node, None else: node = node.right return res 方法三：使用boolean判断一个节点是否被遍历过 123456789101112def postorderTraversal(self, root): res, stack = [], [(root, False)] while stack: node, visited = stack.pop() if node: if visited: res.append(node.val) else: stack.append((node, True)) stack.append((node.right, False)) stack.append((node.left, False)) return res 590. N-ary Tree Postorder TraversalN-叉树的后序遍历。原题方法一：recursively. 1234def postorder(self, root): if not root: return [] return sum([self.postorder(child) for child in root.children], []) + [root.val] 方法二：iteratively and reversed. 1234567def postorder(self, root): res, stack = [], root and [root] while stack: node = stack.pop() res.append(node.val) stack.extend(node.children) return res[::-1] 方法三：iteratively and flag. 12345678910def postorder(self, root): res, stack = [], root and [(root, False)] while stack: node, visited = stack.pop() if visited: res.append(node.val) else: stack.append((node, True)) stack.extend([(n, False) for n in reversed(node.children)]) return res 100. Same Tree判断相同的二叉树。原题1234567Input: 1 1 / \ / \ 2 3 2 3 [1,2,3], [1,2,3]Output: true 方法一：recursively 12345def is_same_tree(p, q): if p and q: return p.val == q.val and is_same_tree(p.left, q.left) and is_same_tree(p.right, q.right) else: return p is q 方法二：recursively, tuple 12345def is_same_tree(p, q): def t(n): return n and (n.val, t(n.left), t(n.right) return t(p) == t(q) 101. Symmetric Tree判断二叉树是否对称。原题12345 1 / \ 2 2 / \ / \3 4 4 3 12345678910def is_symmetric(root): if not root: return True return is_pair(root.left, root.right) def is_pair(l1, l2): if l1 and l2: return l1.val == l2.val and is_pair(l1.left, l2.right) and is_pair(l2.left, l1.right) else: return l1 is l2 104. Maximum Depth of Binary Tree二叉树最大深度。原题123456 3 / \ 9 20 / \ 15 7return 3 recursively 1234def max_depth(root): if not root: return 0 return max(max_depth(root.left), max_depth(root.right)) + 1 iteratively. BFS with deque 123456789101112def maxDepth(self, root): if not root: return 0 from collections import deque q = deque([(root, 1)]) while q: node, depth = q.popleft() if node.left: q.append((node.left, depth+1)) if node.right: q.append((node.right, depth+1)) return depth 可以参考102分层遍历写法，最后求长度。 559. Maximum Depth of N-ary TreeN-叉树的最大深度。原题方法一：BFS with deque.同上题一样。 12345678910def maxDepth(self, root): if not root: return 0 from collections import deque q = deque([(root, 1)]) while q: node, depht = q.popleft() for child in node.children: q.append((child, depht+1)) return depht 方法二：BFS. 12345def maxDepth(self, root): q, level = root and [root], 0 while q: q, level = [child for node in q for child in node.children], level+1 return level 方法三：recursively. 1234def maxDepth(self, root): if not root: return 0 if not root.children: return 1 return max([self.maxDepth(child) for child in root.children]) + 1 111. Minimum Depth of Binary Tree求根节点到叶子节点的最小深度。原题方法一：recursively 1234567def minDepth(self, root): if not root: return 0 if root.left and root.right: return min(self.minDepth(root.left), self.minDepth(root.right)) + 1 else: return self.minDepth(root.left) + self.minDepth(root.right) + 1 方法二：对上述方法修改，更加Pythonic 1234def minDepth(self, root): if not root: return 0 d = map(self.minDepth, (root.left, root.right)) return 1 + (min(d) or max(d)) 方法三：迭代法，BFS 1234567891011121314151617def minDepth(self, root): from collections import deque if not root: return 0 level = deque([(root, 1)]) while level: node, depth = level.popleft() if self.is_leaf(node): return depth else: if node.right: level.append((node.right, depth+1)) if node.left: level.append((node.left, depth+1)) def is_leaf(self, node): return node.left is None and node.right is None 105. Construct Binary Tree from Preorder and Inorder Traversal根据前序遍历和中序遍历重建二叉树。原题12preorder = [3,9,20,15,7]inorder = [9,3,15,20,7] 123456789def buildTree(preorder, inorder): if preorder == []: return None root_val = preorder[0] root = TreeNode(root_val) cut = inorder.index(root_val) root.left = buildTree(preorder[1:cut+1], inorder[:cut]) root.right = buildTree(preorder[cut+1:], inorder[cut+1:]) return root 572. Subtree of Another Tree判断是否是树的子结构。原题思路：这道题是遍历加判断相同树的结合。这里采用前序遍历和递归判断相同树。 12345678910111213141516def isSubtree(self, s, t): stack = [s] while stack: root = stack.pop() if root: if self.is_same(root, t): return True stack.append(root.right) stack.append(root.left) return False def is_same(self, s, t): if s and t: return s.val==t.val and self.is_same(s.left, t.left) and self.is_same(s.right, t.right) else: return s is t 102. Binary Tree Level Order Traversal分层遍历二叉树。原题注意：循环条件要加上root，以防止root is None 123456def levelOrder(self, root): res, level = [], [root] while root and level: res.append([n.val for n in level]) level = [kid for n in level for kid in (n.left, n.right) if kid] return res 103. Binary Tree Zigzag Level Order Traversal之字形打印二叉树。原题1234567def zigzagLevelOrder(self, root): res, level, order = [], [root], 1 while root and level: res.append([n for n in level][::order]) order *= -1 level = [kid for n in level for kid in (n.left, n.right) if kid] return res 107. Binary Tree Level Order Traversal II和102题不同的是，从下到上分层打印。原题方法一：将结果倒序输出，一开始这个方法居然beats有100%，不过重复提交了几次，差别也挺大的。 123456def levelOrderBottom(self, root): res, level = [], [root] while root and level: res.append([n.val for n in level]) level = [kid for n in level for kid in (n.left, n.right) if kid] return res[::-1] 方法二：也可以从前面插入元素。 123456def levelOrderBottom(self, root): res, level = [], [root] while root and level: res.insert(0, [n.val for n in level]) level = [kid for n in level for kid in (n.left, n.right) if kid] return res 429. N-ary Tree Level Order Traversal分层打印N叉树。原题12345678910111213# Definition for a Node.class Node(object): def __init__(self, val, children): self.val = val self.children = children class Solution(object): def levelOrder(self, root): level, res = [root], [] while any(level): res.append([x.val for x in level]) level = [child for n in level for child in n.children if child] return res 257. Binary Tree Paths打印二叉树从根节点到叶子节点全部路径。原题1234567891011Input: 1 / \2 3 \ 5Output: [&quot;1-&gt;2-&gt;5&quot;, &quot;1-&gt;3&quot;]Explanation: All root-to-leaf paths are: 1-&gt;2-&gt;5, 1-&gt;3 iteratively。思路：采用前序遍历二叉树，使用tuple保存节点当前路径，如果是叶子节点，则添加到结果中。开始老是想着用&#39;-&gt;&#39;.join()，这样反而麻烦，直接使用字符串保存就好。 1234567891011121314151617181920212223def binaryTreePaths(self, root): # iteratively if not root: return [] stack = [(root, str(root.val))] res = [] while stack: cur, path = stack.pop() if self.is_leaf(cur): res.append(path) else: if cur.right: stack.append((cur.right, path+'-&gt;'+str(cur.right.val))) if cur.left: stack.append((cur.left, path+'-&gt;'+str(cur.left.val))) return res def is_leaf(self, node): if node.left is None and node.right is None: return True else: return False recursively。参考了StefanPochmann大神的方法。最开始想到一半，中间那层循环想到了，但没想到用递归。 1234567def binaryTreePaths(self, root): # recursively if not root: return [] return [str(root.val) + '-&gt;' + path for kid in (root.left, root.right) if kid for path in self.binaryTreePaths(kid)] or [str(root.val)] 112. Path Sum判断是否具有从根节点到叶子节点上的值和为sum。原题 recursively 12345678def hasPathSum(self, root, sum): if not root: return False elif root.val == sum and root.left is None and root.right is None: return True else: return self.hasPathSum(root.left, sum-root.val) or \ self.hasPathSum(root.right, sum-root.val) iteratively 1234567891011121314151617181920def hasPathSum(self, root, sum): # iteratively if not root: return False stack = [(root, sum)] while stack: cur, sum = stack.pop() if self.is_leaf(cur) and cur.val==sum: return True if cur.right: stack.append((cur.right, sum-cur.val)) if cur.left: stack.append((cur.left, sum-cur.val)) return False def is_leaf(self, node): if node.left is None and node.right is None: return True else: return False 113. Path Sum II上题的升级版，要求二维数组返回所有路径。原题123456789sum = 22 5 / \ 4 8 / / \ 11 13 4 / \ / \7 2 5 1 1234[ [5,4,11,2], [5,8,4,5]] iteratively. 举一反三。 123456789101112131415161718192021def pathSum(self, root, sum): # iteratively if not root: return [] res, stack = [], [(root, [root.val], sum)] while stack: cur, path, sum = stack.pop() if self.is_leaf(cur) and cur.val==sum: res.append(path) if cur.right: stack.append((cur.right, path+[cur.right.val], sum-cur.val)) if cur.left: stack.append((cur.left, path+[cur.left.val], sum-cur.val)) return res def is_leaf(self, node): if node.left is None and node.right is None: return True else: return False recursively. 先找出所有路径，再过滤，实际上和257题一样。不过这并没有把这道题的特性涵盖进去。 1234567891011def pathSum(self, root, sum_val): paths = self.all_paths(root) return [path for path in paths if sum(path)==sum_val] def all_paths(self, root): if not root: return [] return [[root.val]+path for kid in (root.left, root.right) if kid for path in self.all_paths(kid)] or [[root.val]] recursively. 123456789def pathSum(self, root, sum): if not root: return [] val, *kids = root.val, root.left, root.right if any(kids): return [[val] + path for kid in kids if kid for path in self.pathSum(kid, sum-val)] return [[val]] if val==sum else [] 297. Serialize and Deserialize Binary Tree序列化反序列化二叉树。原题1234567891011121314151617181920class Codec: def serialize(self, root): if not root: return '$' else: return str(root.val) + ',' + self.serialize(root.left) + ',' + self.serialize(root.right) def deserialize(self, data): nodes_val = data.split(',') return self.deserialize_tree(nodes_val) def deserialize_tree(self, vals): val = vals.pop(0) if val == '$': return None cur = TreeNode(val) cur.left = self.deserialize_tree(vals) cur.right = self.deserialize_tree(vals) return cur 一开始的时候反序列化是这样写的，然后调试的时候发现这样写不对，因为这样写的话左子树和右子树变成一样了。CSDN上找到了一个答案。剑指offer：序列化二叉树（Python)。于是将其修改为上面部分。 123456789def deserialize(self, data): nodes_val = data.split(',') cur_val = nodes_val.pop(0) if cur_val == '$': return None cur = TreeNode(cur_val) cur.left = self.deserialize(','.join(nodes_val)) cur.right = self.deserialize(','.join(nodes_val)) return cur 110. Balanced Binary Tree判断是否是平衡二叉树。原题方法一：遍历+递归 123456789101112131415161718def isBalanced(self, root): if not root: return True stack = [root] while stack: cur = stack.pop() if abs(self.max_depth(cur.left)-self.max_depth(cur.right)) &gt; 1: return False if cur.left: stack.append(cur.left) if cur.right: stack.append(cur.right) return True def max_depth(self, root): if not root: return 0 return max(self.max_depth(root.left), self.max_depth(root.right)) + 1 方法二：递归+递归 12345678910def isBalanced(self, root): if not root: return True return self.isBalanced(root.left) and self.isBalanced(root.right) and \ abs(self.max_depth(root.left)-self.max_depth(root.right)) &lt;= 1 def max_depth(self, root): if not root: return 0 return max(self.max_depth(root.left), self.max_depth(root.right)) + 1 方法三：后序遍历，边遍历边判断，不会重复节点。受此思想启发，添加一种后序遍历二叉树的方法。 12345678910111213141516171819def isBalanced(self, root): stack, node = [], root last, depths = None, collections.defaultdict(int) while stack or node: if node: stack.append(node) node = node.left else: node = stack[-1] if not node.right or last == node.right: node = stack.pop() left, right = depths[node.left], depths[node.right] if abs(left - right) &gt; 1: return False depths[node] = 1 + max(left, right) last, node = node, None else: node = node.right return True 108. Convert Sorted Array to Binary Search Tree将有序数组转换成二叉搜索树。原题12345678Given the sorted array: [-10,-3,0,5,9],One possible answer is: [0,-3,9,-10,null,5], 0 / \ -3 9 / / -10 5 答案不唯一，居然一次就通过了。递归的思想还是简单一些的。 12345678def sortedArrayToBST(self, nums): if not nums: return None mid = len(nums) // 2 root = TreeNode(nums[mid]) root.left = self.sortedArrayToBST(nums[:mid]) root.right = self.sortedArrayToBST(nums[mid+1:]) return root 235. Lowest Common Ancestor of a Binary Search Tree寻找二叉搜索树的最小公共祖先。原题1234def lowestCommonAncestor(self, root, p, q): while (root.val-p.val) * (root.val-q.val) &gt; 0: root = (root.left, root.right)[root.val &lt; p.val] return root 404. Sum of Left Leaves求一个二叉树所有左叶子节点的和。原题方法一：iteratively.这里使用了tuple记录是否为左叶子节点。 12345678910def sumOfLeftLeaves(self, root): res, stack = [], [(root, False)] while stack: node, is_left = stack.pop() if node: if node.left is None and node.right is None and is_left: res.append(node.val) stack.append((node.right, False)) stack.append((node.left, True)) return sum(res) 方法二：recursively. 1234567def sumOfLeftLeaves(self, root): if not root: return 0 if root.left and root.left.left is None and root.left.right is None: return root.left.val + self.sumOfLeftLeaves(root.right) else: return self.sumOfLeftLeaves(root.left) + self.sumOfLeftLeaves(root.right) 938. Range Sum of BST给两个节点的值，求二叉搜索树在这两个值之间的节点和。每个节点的值唯一。原题1234Input: root = [10,5,15,3,7,null,18], L = 7, R = 15Output: 32Input: root = [10,5,15,3,7,13,18,1,null,6], L = 6, R = 10Output: 23 方法一：因为是竞赛题，所以没追求效率，所以这里先前序遍历了一下，再根据条件求和。 1234567891011def rangeSumBST(self, root, L, R): traverse, stack = [], [root] while stack: node = stack.pop() if node: traverse.append(node.val) if node.right: stack.append(node.right) if node.left: stack.append(node.left) return sum([x for x in traverse if L &lt;= x &lt;= R]) 方法二：利用二叉搜索树的特性。 12345678910111213def rangeSumBST(self, root, L, R): if not root: return 0 res, stack = 0, [root] while stack: node = stack.pop() if node.val &gt; L and node.left: stack.append(node.left) if node.val &lt; R and node.right: stack.append(node.right) if L &lt;= node.val &lt;= R: res += node.val return res 530. Minimum Absolute Difference in BST求二叉搜索树任意两个节点的最小差。原题12345678910111213Input: 1 \ 3 / 2Output:1Explanation:The minimum absolute difference is 1, which is the difference between 2 and 1 (or between 2 and 3). 123456def getMinimumDifference(self, root): nums = self.inorder(root) return min([abs(nums[i+1]-nums[i]) for i in range(len(nums)-1)])def inorder(self, node): return self.inorder(node.left) + [node.val] + self.inorder(node.right) if node else [] 538. Convert BST to Greater Tree二叉搜索树转换。使得节点的值等于所有比它大的节点的和。原题123456789Input: The root of a Binary Search Tree like this: 5 / \ 2 13Output: The root of a Greater Tree like this: 18 / \ 20 13 方法一：recursively。这里使用了一个变量来保存当前的累加和，然后递归中采用先右后左的方式。 123456789101112def convertBST(self, root): self.sum_val = 0 self.convert(root) return rootdef convert(self, node): if not node: return None self.convert(node.right) self.sum_val += node.val node.val = self.sum_val self.convert(node.left) 方法二：iteratively。94题中的中序遍历迭代方式不能实现，因为迭代时改变了根节点。 1234567891011121314def convertBST(self, root): stack = [(root, False)] sum_val = 0 while stack: node, visited = stack.pop() if node: if visited: node.val += sum_val sum_val = node.val else: stack.append((node.left, False)) stack.append((node, True)) stack.append((node.right, False)) return root 958. Check Completeness of a Binary Tree判断二叉树是否是完整二叉树。完整二叉树为：除了最后一层所有节点不能为空，最后一层节点全部去靠左。原题Example 1: 123Input: [1,2,3,4,5,6]Output: trueExplanation: Every level before the last is full (ie. levels with node-values &#123;1&#125; and &#123;2, 3&#125;), and all nodes in the last level (&#123;4, 5, 6&#125;) are as far left as possible. Example 2: 123Input: [1,2,3,4,5,null,7]Output: falseExplanation: The node with value 7 isn&apos;t as far left as possible. 方法一：采用分层遍历的方式，判断每层的节点是否是2**level。最后一层采用切片的方式判断最左原则。 123456789101112131415161718192021class Solution: def isCompleteTree(self, root): if not root: return True levels = [root] last_full = True level = 0 while levels: value_nodes = [n for n in levels if n] if value_nodes != levels[:len(value_nodes)]: return False else: print(len(levels), 2**level) if len(levels) != 2**level: if not last_full: return False last_full = False levels = [kid for n in levels if n for kid in (n.left, n.right)] level += 1 return True 543. Diameter of Binary Tree求二叉树的最大直径，即任意两节点的长度。原题123456 1 / \ 2 3 / \ 4 5 Return **3**, which is the length of the path [4,2,1,3] or [5,2,1,3]. 方法一： recursively, 使用一个实例变量计算了最大值。 1234567891011def diameterOfBinaryTree(self, root): self.res = 0 self.depthOfNode(root) return self.resdef depthOfNode(self, node): if not node: return 0 left, right = self.depthOfNode(node.left), self.depthOfNode(node.right) self.res = max(self.res, left+right) return 1 + max(left, right) 965. Univalued Binary Tree判断一个二叉树是否所有节点具有相同的值。原题方法一：暴力法。 1234567def isUnivalTree(self, root): return len(set(self.traversalTree(root))) == 1def traversalTree(self, node): if not node: return [] return self.traversalTree(node.left) + [node.val] + self.traversalTree(node.right) 方法二：recursively。 123456def isUnivalTree(self, root, val=None): if not root: return True if val is not None and root.val != val: return False return self.isUnivalTree(root.left, root.val) and self.isUnivalTree(root.right, root.val) 563. Binary Tree Tilt返回一个二叉树整个树的倾斜度。所有节点倾斜度的总和。节点的倾斜度等于左子树和右子树所有和的绝对值。原题12345678910Input: 1 / \ 2 3Output: 1Explanation: Tilt of node 2 : 0Tilt of node 3 : 0Tilt of node 1 : |2-3| = 1Tilt of binary tree : 0 + 0 + 1 = 1 方法一：recursively. 这里用tuple记录了节点总和和倾斜度总和。 12345678910111213def findTilt(self, root): self.res = 0 _, top_res = self.sum_and_diff(root) return self.res + top_resdef sum_and_diff(self, node): if not node: return 0, 0 l_sum, l_diff = self.sum_and_diff(node.left) r_sum, r_diff = self.sum_and_diff(node.right) self.res += l_diff + r_diff # print(node.val, node.val+l_sum+r_sum, abs(l_sum-r_sum)) return node.val+l_sum+r_sum, abs(l_sum-r_sum) 方法二: 想了一会后序遍历的迭代法，没想出来，貌似需要维护很多的变量。这里还是优化一下方法一。 123456789def findTilt(self, root): return self.sum_and_diff(root)[1]def sum_and_diff(self, node): if not node: return 0, 0 l_sum, l_diff = self.sum_and_diff(node.left) r_sum, r_diff = self.sum_and_diff(node.right) return node.val+l_sum+r_sum, abs(l_sum-r_sum)+l_diff+r_diff]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
        <tag>Algorithm</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode算法题整理（动态规划篇）Danymic Programming]]></title>
    <url>%2FLeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AF%87%EF%BC%89Danymic-Programming%2F</url>
    <content type="text"><![CDATA[70. Climbing Stairs爬楼梯，一次可以爬一阶或两阶楼梯，爬上n阶楼梯有多少种方法？原题 斐波那契问题 12345def fibonacci(n): a = b = 1 for _ in range(n-1): a, b = b, a+b return b 121. Best Time to Buy and Sell Stock买入卖出最大收益。原题1234Input: [7,1,5,3,6,4]Output: 5Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5. Not 7-1 = 6, as selling price needs to be larger than buying price. 123456789101112def max_profit(prices): if not prices: return 0 max_profit = 0 n = len(prices) min_buy = prices[0] for i in range(1, n): cur_profit = prices[i] - min_buy max_profit = max(cur_profit, max_profit) if prices[i] &lt; min_buy: min_buy = prices[i] return max_profit 122. Best Time to Buy and Sell Stock II买入卖出，允许多次交易。原题1234Input: [7,1,5,3,6,4]Output: 7Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4. Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3. 思路：比较每两天的价格，如果是涨价了，那就把收益计算进去，否则不出手交易。 123456def max_profit(prices): profit = 0 for i in range(1, len(prices)): if prices[i] &gt; prices[i-1]: profit += prices[i] - prices[i-1] return profit 198. House Robber抢劫房子问题。不能连续抢劫两个挨着的房间。原题1234Input: [2,7,9,3,1]Output: 12Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1). Total amount you can rob = 2 + 9 + 1 = 12. 123f(0) = nums[0]f(1) = max(num[0], num[1])f(k) = max( f(k-2) + nums[k], f(k-1) ) 方法一：递归，超时。 1234567def rob(self, nums): if not nums: return 0 if len(nums) &lt;= 1: return nums[0] return max(nums[0]+self.rob(nums[2:]), self.rob(nums[1:])) 方法二： 12345def rob(self, nums): last, now = 0, 0 for num in nums: last, now = now, max(last+num, now) return now 303. Range Sum Query - Immutable给定一个数组，计算索引i, j之间的和。原题12345Given nums = [-2, 0, 3, -5, 2, -1]sumRange(0, 2) -&gt; 1sumRange(2, 5) -&gt; -1sumRange(0, 5) -&gt; -3 思路：如果单纯采用切片计算，效率过低，题中要求sumRange调用多次。所以这里采用动态规划。 12345678910111213class NumArray: def __init__(self, nums): # self.sum_item = [0] # for num in nums: # self.sum_item.append(self.sum_item[-1] + num) from itertools import accumulate from operator import add self.sum_item = list(accumulate(nums, add)) def sumRange(self, i, j): # return self.sum_item[j+1] - self.sum_item[i] return self.sum_item[j] - self.sum_item[i-1] if i &gt; 0 else self.sum_item[j]]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
        <tag>Algorithm</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode算法题整理（字符串篇）String]]></title>
    <url>%2FLeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AF%87%EF%BC%89String%2F</url>
    <content type="text"><![CDATA[14. Longest Common Prefix返回最长公共前缀字符串。原题 12Input: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]Output: &quot;fl&quot; 123456def longest_common_prefix(strs): if not strs: return '' from itertools import takewhile max_pre_len = len(list(takewhile(lambda x: len(set(x))==1, zip(*strs)))) return strs[0][:max_pre_len] 20. Valid Parentheses判断括号是否成对出现，并且嵌套正确。原题 1234Input: &quot;()[]&#123;&#125;&quot;Output: trueInput: &quot;&#123;[]&#125;&quot;Output: true 12345678910111213def is_valid(s): pairs = &#123;')': '(', '&#125;': '&#123;', ']': '['&#125; stack = [] for paren in s: if paren in pairs.values(): stack.append(paren) elif paren in pairs.keys(): if stack == [] or stack.pop() != pairs[paren]: return False else: return False return stack == [] 921. Minimum Add to Make Parentheses Valid给定一个只包含小括号的字符串。返回需要多少个”(“或”)”使其成为完整的括号表达式。原题12345678Input: &quot;())&quot;Output: 1Input: &quot;()))((&quot;Output: 4Input: &quot;()&quot;Output: 0Input: &quot;(((&quot;Output: 3 1234567891011def minAddToMakeValid(self, S): stack, res = [], 0 for paren in S: if paren == '(': stack.append(paren) else: if not stack: res += 1 else: stack.pop() return res + len(stack) 28. Implement strStr()实现index。原题12Input: haystack = &quot;hello&quot;, needle = &quot;ll&quot;Output: 2 12345678def str_index(haystack, needle): h = len(haystack) n = len(needle) for i in range(h-n+1): if haystack[i:i+n] == needle: return i else: return -1 38. Count and Say原题123451. 12. 113. 214. 12115. 111221 123456789def count_and_say(n): from itertools import groupby res = '1' for _ in range(n-1): temp = '' for num, group in groupby(res): temp += (str(len(list(group)))+str(num)) res = temp return res 443. String Compression字符串压缩，实际是要将重复的字符串以个数来表示。要求O(1)空间复杂度，就地修改原数组。原题思路：看上去和38题差不多，但是有些不同，不同的地方在于如果个数为1，则不显示。个数为两位数，要显示两个元素。 123456Input = [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;,&quot;b&quot;,&quot;c&quot;,&quot;c&quot;,&quot;c&quot;]Output = [&quot;a&quot;,&quot;2&quot;,&quot;b&quot;,&quot;2&quot;,&quot;c&quot;,&quot;3&quot;]Input = [&quot;a&quot;]Output = [&quot;a&quot;]Input = [&quot;a&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;]Output = [&quot;a&quot;,&quot;b&quot;,&quot;1&quot;,&quot;2&quot;] 12 125. Valid Palindrome验证回文字符串，只判断字母数字，忽略大小写。原题12Input: &quot;A man, a plan, a canal: Panama&quot;Output: true 方法一：切片 123def is_palindrome(s): s_alnum = filter(str.isalnum, s.lower()) return s_alnum == s_alnum[::-1] 方法二：双指针 1234567def is_palindrome(s): s_alnum = list(filter(str.isalnum, s.lower())) mid = len(s_alnum) // 2 for i in range(mid): if s_alnum[i] != s_alnum[-i-1]: return False return True 151. Reverse Words in a String倒置一句话中的单词。原题12Input: &quot;the sky is blue&quot;,Output: &quot;blue is sky the&quot;. 12def reverse_words(s): return ' '.join(s.split()[::-1]) 344. Reverse String倒置字符串。原题12Input: &quot;A man, a plan, a canal: Panama&quot;Output: &quot;amanaP :lanac a ,nalp a ,nam A&quot; 123456def reverse_str(s): n = len(s) res = list(s) for i in range(n//2): res[i], res[-i-1] = res[-i-1], res[i] return ''.join(res) 242. Valid Anagram验证回文构词法，即两个字符串由同样个数的字符组成。原题12Input: s = &quot;anagram&quot;, t = &quot;nagaram&quot;Output: true 方法一： sort 12def is_anagram(s, t): return sorted(s) == sorted(t) 方法二：Counter 12345def is_anagram(s, t): from collections import Counter c1 = Counter(s) c2 = Counter(t) return c1 == c2 438. Find All Anagrams in a String找出字符串中所有的回文构词。原题1234567891011121314def findAnagrams(self, s, p): from collections import Counter ns, np = len(s), len(p) cur_c = Counter(s[:np-1]) c_p = Counter(p) res = [] for i in range(np-1, ns): cur_c[s[i]] += 1 if cur_c == c_p: res.append(i-np+1) cur_c[s[i-np+1]] -= 1 if cur_c[s[i-np+1]] == 0: del cur_c[s[i-np+1]] return res 3. Longest Substring Without Repeating Characters最长不含重复字符的子字符串。原题方法一：暴力法，果然超时了。 1234567def lengthOfLongestSubstring(self, s): max_len, n = 0, len(s) for i in range(n): for j in range(i+1, n+1): if len(s[i:j]) == len(set(s[i:j])): max_len = max(max_len, len(s[i:j])) return max_len 方法二：找到重复值时，更新start的值，为什么使用max，因为start有可能大于dic[s[end]]+1，比如当s=&#39;abba&#39;，end走到最后的时候。 12345678910def lengthOfLongestSubstring(self, s): res, start = 0, 0 dic = &#123;&#125; for end in range(len(s)): if s[end] in dic: start = max(start, dic[s[end]]+1) # start = dic[s[end]] + 1 dic[s[end]] = end res = max(res, end-start+1) return res 也可以把max判断放到条件里。 12345678910def lengthOfLongestSubstring(self, s): res, start = 0, 0 dic = &#123;&#125; for end in range(len(s)): if s[end] in dic and start &lt;= dic[s[end]]: start = dic[s[end]] + 1 else: res = max(res, end-start+1) dic[s[end]] = end return res 387. First Unique Character in a String返回第一个不重复的字符。原题1234s = &quot;leetcode&quot;return 0.s = &quot;loveleetcode&quot;,return 2. Time-O(2n), Space-O(n)。暂时没发现更快的算法了。 1234567def firstUniqChar(self, s): from collections import Counter c = Counter(s) for i, ch in enumerate(s): if c[ch] == 1: return i return -1 58. Length of Last Word输入一个字符串，通过空格分割，然后返回最后一个单词的长度，空串不算。原题123456s = &quot;Hello World&quot;return 5s = &quot;a &quot;return 1s = &quot; &quot;return 0 方法一：直观的方法。 123456def lengthOfLastWord(self, s): ss = s.split(' ') for ch in ss[::-1]: if ch: return len(ch) return 0 方法二：使用列表生成式，理论上时间复杂度比上述方法稍微高一点，不过实际时间差不多，估计是list comprehension做了优化。 123def lengthOfLastWord(self, s): ss =[x for x in s.split(' ') if x] return len(ss[-1]) if ss else 0 205. Isomorphic Strings判断两个字符串是否具有一样的形式。s和t长度一样。原题12345678Input: s = &quot;egg&quot;, t = &quot;add&quot;Output: trueInput: s = &quot;foo&quot;, t = &quot;bar&quot;Output: falseInput: s = &quot;paper&quot;, t = &quot;title&quot;Output: true 方法一：使用dict保存每个字母的位置。这里使用了OrderedDict保存了values的顺序，也可以使用sorted对values排序。最后说明一下在Python3中需要使用list格式化一下，因为values()返回一个dict_values对象，而这个对象如果直接使用==判断，会返回False，即使有相同的值，这里还不清楚内部的__eq__方法是如何实现的。而在Python2中可以直接比较。 12345678def isIsomorphic(self, s, t): from collections import OrderedDict d1, d2 = OrderedDict(), OrderedDict() for i, val in enumerate(s): d1[val] = d1.get(val, []) + [i] for i, val in enumerate(t): d2[val] = d2.get(val, []) + [i] return list(d1.values()) == list(d2.values()) 方法二：使用zip并行输出。 12&gt;&gt;&gt; list(zip('paper', 'title'))[('p', 't'), ('a', 'i'), ('p', 't'), ('e', 'l'), ('r', 'e')] 12def isIsomorphic(self, s, t): return len(set(zip(s, t))) == len(set(s)) == len(set(t)) 方法三：两个字符串每个位置的字符，第一次出现的index是否相同。 123def isIsomorphic(self, s, t): # return [s.find(i) for i in s] == [t.find(j) for j in t] return list(map(s.find, s)) == list(map(t.find, t)) 290. Word Pattern匹配字符串和空格分隔的字符串是否具有相同形式，此题和上一题相似，只不过将其中一个换成了数组。另一个区别是长度不一定相等。原题12Input: pattern = &quot;abba&quot;, str = &quot;dog cat cat dog&quot;Output: true 1234def wordPattern(self, pattern, str): s = pattern t = str.split() return list(map(s.find, s)) == list(map(t.index, t)) 12345def wordPattern(self, pattern, str): s = pattern t = str.split() return len(set(zip(s, t))) == len(set(s)) == len(set(t)) \ and len(s) == len(t) 917. Reverse Only Letters倒置一个字符串的字母。原题12345Input: &quot;ab-cd&quot;Output: &quot;dc-ba&quot;Input: &quot;a-bC-dEf-ghIj&quot;Output: &quot;j-Ih-gfE-dCba&quot; 注意：不能使用l &lt;= r作为条件，因为会打乱正确结果的排序。输出&quot;dcb-a&quot;。 123456789101112def reverseOnlyLetters(self, S): l, r = 0, len(S)-1 res = list(S) while l &lt; r: while l&lt;r and not res[l].isalpha(): l += 1 while l&lt;r and not res[r].isalpha(): r -= 1 res[l], res[r] = res[r], res[l] l += 1 r -= 1 return ''.join(res) 345.Reverse Vowels of a String倒置一个字符串中的元音字母。原题1234Example 2:Input: &quot;leetcode&quot;Output: &quot;leotcede&quot; 方法一：和917题一样，换汤不换药。只需定义一个vowels={&#39;a&#39;, &#39;e&#39;, &#39;i&#39;, &#39;o&#39;, &#39;u&#39;}然后条件改成while l&lt;r and res[l].lower() not in vowels:，提交了一下beat有68%左右，应该还有更效率的方法。 方法二：改了一下，不再使用lower方法了，把大写字母加上，beat变为99.88%。 12345678910111213def reverseVowels(self, s): l, r = 0, len(s)-1 vowels = set(list('aeiouAEIOU')) res = list(s) while l &lt; r: while l&lt;r and res[l] not in vowels: l += 1 while l&lt;r and res[r] not in vowels: r -= 1 res[l], res[r] = res[r], res[l] l += 1 r -= 1 return ''.join(res) 方法三：正则 1234def reverseVowels(self, s): vowels = re.findall('(?i)[aeiou]', s) # (?i)表示忽略大小写 # repl参数每次返回一个值，用来替换s匹配pattern的字符。 return re.sub('(?i)[aeiou]', lambda m: vowels.pop(), s) 383. Ransom Note判断是否magazine可以构成ransomNote。原题123canConstruct(&quot;a&quot;, &quot;b&quot;) -&gt; falsecanConstruct(&quot;aa&quot;, &quot;ab&quot;) -&gt; falsecanConstruct(&quot;aa&quot;, &quot;aab&quot;) -&gt; true 方法一：使用count。 12345def canConstruct(self, ransomNote, magazine): for item in set(ransomNote): if magazine.count(item) &lt; ransomNote.count(item): return False return True 方法二：one-liner. 123def canConstruct(self, ransomNote, magazine): return all(ransomNote.count(char) &lt;= magazine.count(char) for char in set(ransomNote)) 方法三：Counter。时间复杂度比二稍高。 123def canConstruct(self, ransomNote, magazine): from collections import Counter return not Counter(ransomNote) - Counter(magazine) 925. Long Pressed Name说有这么一个破键盘，老是连键，有时候打一个字母c，出来好几个。给定一个目标字符串和打出来的字符串，判断是否是这个破键盘输出的。原题1234567Input: name = "alex", typed = "aaleex"Output: trueExplanation: 'a' and 'e' in 'alex' were long pressed.Input: name = "saeed", typed = "ssaaedd"Output: falseExplanation: 'e' must have been pressed twice, but it wasn't in the typed output. 思路：一开始还想用Counter，后来发现不对，因为它将所有的一样的字符聚合到了一起。所以此题可以使用groupby 1234567891011def isLongPressedName(self, name, typed): from itertools import groupby name_groups = [(ch, len(list(g))) for ch, g in groupby(name)] typed_groups = [(ch, len(list(g))) for ch, g in groupby(typed)] if len(typed_groups) &lt; len(name_groups): return False for i in range(len(name_groups)): if typed_groups[i][0] != name_groups[i][0] or \ typed_groups[i][1] &lt; name_groups[i][1]: return False return True 929. Unique Email Addresses统计不同的email地址。原题123456789def numUniqueEmails(self, emails): res = set() for email in emails: local, domain = email.split('@') if '+' in local: local = local[:local.index('+')] local = local.replace('.', '') res.add((local, domain)) return len(res) 409. Longest Palindrome给你一堆字符串，返回用它组成的最长的回文串的长度，可以不适用所有的字符。原题方法一：每对一样的数字可以放在两边来组成回文。 1234567def longestPalindrome(self, s): from collections import Counter c = Counter(s) res = 0 for count in c.values(): res += count // 2 return res*2 + (len(s) &gt; res*2) 方法二：从奇数的角度考虑。 1234def longestPalindrome(self, s): from collections import Counter odds = sum(v &amp; 1 for v in Counter(s).values()) return len(s) - odds + bool(odds) 434. Number of Segments in a String统计字符串中有多少个以空格分割的字符串。原题方法一：Time-O(n), Space-O(1) 123456def countSegments(self, s): segment_count = 0 for i in range(len(s)): if (i == 0 or s[i-1] == ' ') and s[i] != ' ': segment_count += 1 return segment_count 方法二： 12def countSegments(self, s): return len(s.split()) 500. Keyboard Row输入一个字符串数组，返回字符在键盘同一行的字符串。原题12Input: [&quot;Hello&quot;, &quot;Alaska&quot;, &quot;Dad&quot;, &quot;Peace&quot;]Output: [&quot;Alaska&quot;, &quot;Dad&quot;] 1234567891011class Solution: def findWords(self, words): self.first = &#123;'Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'I', 'O', 'P'&#125; self.second = &#123;'A', 'S', 'D', 'F', 'G', 'H', 'J', 'K', 'L'&#125; self.third = &#123;'Z', 'X', 'C', 'V', 'B', 'N', 'M'&#125; return list(filter(self.same_line, words)) def same_line(self, word): return set(word.upper()) &lt;= set(self.first) or \ set(word.upper()) &lt;= set(self.second) or \ set(word.upper()) &lt;= set(self.third) 520. Detect Capital判断一个字符串的大写是否使用正确。要么全大写，要么全小写，或者首字母大写。原题12Input: &quot;USA&quot;Output: True 方法一：太简单了，一下子就写出来了，看评论居然好多人不知道istitle。 12def detectCapitalUse(self, word): return word.islower() or word.isupper() or word.istitle() 541. Reverse String II按照2k的长度划分一个字符串，把其中每段前k个字符倒置。原题12Input: s = &quot;abcdefg&quot;, k = 2Output: &quot;bacdfeg&quot; 方法一：比较简单的一题，使用Python的切片。 12345678def reverseStr(self, s, k): letters = list(s) n = len(letters) # for i in range(n//(2*k)+1): # letters[2*k*i:k+2*k*i] = reversed(letters[2*k*i:k+2*k*i]) for i in range(0, n, 2*k): letters[i:k+i] = reversed(letters[i:k+i]) return ''.join(letters) 551. Student Attendance Record I判断一个学生是否有奖励，缺席次数小于等于一天，没有三次连续的迟到。原题12Input: &quot;PPALLP&quot;Output: True 12def checkRecord(self, s): return s.count('A')&lt;= 1 and 'LLL' not in s 557. Reverse Words in a String III倒置一句话中的每个单词。所有单词均已一个空格分隔。原题12Input: &quot;Let&apos;s take LeetCode contest&quot;Output: &quot;s&apos;teL ekat edoCteeL tsetnoc&quot; 12def reverseWords(self, s): return ' '.join([word[::-1] for word in s.split()])]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
        <tag>Algorithm</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode算法题整理（数学篇）Math]]></title>
    <url>%2FLeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E6%95%B0%E5%AD%A6%E7%AF%87%EF%BC%89Math%2F</url>
    <content type="text"><![CDATA[7. Reverse Integer倒置一个整数， 此答案忽略了原题中的范围判断。原题12Input: -123Output: -321 方法一：str 12345def reverse_int(x): if x &gt;= 0: return int(str(x)[::-1]) else: return -int(str(x)[:0:-1]) 方法二：math reverse_int(x):1234567891011121314151617181920 if x &gt;= 0: fill_symbol = 1 else: fill_symbol = -1 result = 0 tail = abs(x) while tail: result = result*10 + tail%10 tail //= 10 return result * fill_symbol ### 9. Palindrome Number#### 判断一个数是否是回文数，这里把负数认为是不符合条件的。[原题](https://leetcode.com/problems/palindrome-number/description/)方法一：str```pythondef is_palindrome(x): return str(x) == str(x)[::-1] 方法二：math 123456def is_palindrome(x): l, r = x, 0 while l &gt; 0: r = r*10 + l%10 l //= 10 return r == x 13. Roman to Integer罗马数字转换整型。原题12345678910def roman_to_int(s): roman = &#123;'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000&#125; total = 0 for i in range(len(s)): if i == len(s)-1 or roman[s[i]] &gt;= roman[s[i+1]] total += roman[s[i]] else: total -= roman[s[i]] return total 69. Sqrt(x)实现开方，返回整数部分。原题1234Input: 8Output: 2Explanation: The square root of 8 is 2.82842..., and since the decimal part is truncated, 2 is returned. 牛顿迭代法 12345def my_sqrt(x): r = x while r**2 &gt; x: r = (r+x//r) // 2 return r 367. Valid Perfect Square判断一个数是不是某个数的平方。原题12Input: 16Output: true 方法一：牛顿迭代法。同69。 12345def isPerfectSquare(self, num): r = num while r**2 &gt; num: r = (r + num // r) // 2 return r**2 == num 171. Excel Sheet Column Numberexcel表格列表数字转换，二十六进制。原题1234567A -&gt; 1B -&gt; 2C -&gt; 3...Z -&gt; 26AA -&gt; 27AB -&gt; 28 A -&gt; 1 12def title2number(s): return sum([(ord(x)-64) * 26 ** i for i, x in enumerate(s[::-1])]) 168. Excel Sheet Column Titleexcel转换，数字转字母。十进制-&gt;26进制。原题1234567def convertToTitle(self, n): res = '' while n: res = chr((n-1)%26+65) + res # n //= 26 n = (n-1) // 26 return res 172. Factorial Trailing Zeroes求n的阶乘末尾有几个0。原题123Input: 5Output: 1Explanation: 5! = 120, one trailing zero. 思路：每一对2和5可以产生一个0，在n的阶乘中，5比2多，所以问题变成求5的个数，而25这种数有两个5，所以递归求解 12def trailing_zeroes(n): return 0 if n == 0 else n//5 + trailing_zeroes(n//5) 204. Count Primes求小于n的整数中，有多少个质数。原题123456def countPrimes(self, n): is_prime = [False]*2 + [True]*(n-2) for i in range(2, int(n ** 0.5)+1): if is_prime[i]: is_prime[i*i:n:i] = [False] * len(is_prime[i*i:n:i]) return sum(is_prime) 50. Pow(x, n)实现pow函数。原题12345Input: 2.00000, 10Output: 1024.00000Input: 2.00000, -2Output: 0.25000 . 说明：常规方法在Leetcode 上内存会爆掉。 123456789101112131415161718192021class Solution(object): def myPow(self, x, n): if n &lt; 0: return 1 / self.pow_with_unsigned(x, -n) else: return self.pow_with_unsigned(x, n) def pow_with_unsigned(self, x, n): if n == 1: return x if n == 0: return 1 res = self.pow_with_unsigned(x, n &gt;&gt; 1) res *= res if n &amp; 1 == 1: res *= x return res 233. Number of Digit One1~n数字中1的个数。原题1234567def countDigitOne(self, n): countr, i = 0, 1 while i &lt;= n: divider = i * 10 countr += (n // divider) * i + min(max(n % divider - i + 1, 0), i) i *= 10 return countr 263. Ugly Number判断一个数是否是丑数。原题方法一：根据定义实现。&lt; num是为了判断num=0的情况。 12345def isUgly(self, num): for f in 2, 3, 5: while num % f == 0 &lt; num: num //= f return num == 1 264. Ugly Number II输出第n个丑数。原题书中的方法 1234567891011121314def nthUglyNumber(self, n): q = [1] t2, t3, t5 = 0, 0, 0 for i in range(n-1): a2, a3, a5 = q[t2]*2, q[t3]*3, q[t5]*5 to_add = min(a2, a3, a5) q.append(to_add) if a2 == to_add: t2 += 1 if a3 == to_add: t3 += 1 if a5 == to_add: t5 += 1 return q[-1] 268. Missing Number0~n中缺失的数字。原题123456def missingNumber(self, nums): # math n = len(nums) expected_sum = n*(n+1) // 2 actual_sum = sum(nums) return expected_sum - actual_sum 67.Add Binary实现二进制加法。原题12Input: a = &quot;11&quot;, b = &quot;1&quot;Output: &quot;100&quot; 方法一：按照加法的二进制思想来计算，不过Runtime大约100ms。后来试着将list comprehension拆成一个for循环，也并没有提高速度。居然beats只有4%，难道大部分人都用的bin。讨论区简单翻了了一下，没有找到一个高效的pythonic的方法。 1234567891011def addBinary(self, a, b): if len(a) &gt; len(b): b = b.zfill(len(a)) else: a = a.zfill(len(b)) while int(b): sum_not_carry = ''.join([str(int(a[i]) ^ int(b[i])) for i in range(len(a))]) carry = ''.join([str(int(a[i]) &amp; int(b[i])) for i in range(len(a))]) a, b = "0"+sum_not_carry, carry+'0' return a.lstrip('0') if a != '0' else '0' 202. Happy Number判断是否是欢乐数。进行所有位的平方和运算，最后为1的是欢乐数。原题1234567Input: 19Output: trueExplanation: 1**2 + 9**2 = 828**2 + 2**2 = 686**2 + 8**2 = 1001**2 + 0**2 + 0**2 = 1 方法一：思路，使用一个字典映射0~9的平方值，然后如果死循环的话，各位数的和一定存在着一种循环，所以用一个set来判断是否重复。 12345678910def isHappy(self, n): squares = &#123;str(k): k**2 for k in range(0, 10)&#125; sum_digit = set() while n != 1: n = sum(squares[digit] for digit in str(n)) if n in sum_digit: return False else: sum_digit.add(n) return True 231. Power of Two判断一个数是否是2的n次方。思路也就是判断这个数的二进制形式是否只有一个’1’。原题方法一：可以用作通用方法。 12345def isPowerOfTwo(self, n, power=2): if n == 0: return False while n % power == 0: n //= power return n == 1 方法二：二进制统计1。 12def isPowerOfTwo(self, n): return n &gt; 0 and bin(n).count('1') == 1 方法三：如果一个数n的二进制只有一个1，那么n&amp;(n-1)一定为0。 12def isPowerOfTwo(self, n): return n &gt; 0 and (n&amp;n-1) == 0 342. Power of Four判断一个数是否是4的n次方。原题方法一：从简单入手通过231题，了解到了2的n次方特点是，二进制形式只有一个’1’，那么4的n次方就是不但只有一个’1’，后面还跟了偶数个’0’。 1234567891011def isPowerOfFour(self, num): single_1 = num &gt; 0 and not (num &amp; num-1) if single_1: while num &gt; 0: if num == 1: return True else: num &gt;&gt;= 2 return False else: return False 方法二：上述代码看起来更像是java代码，我们使用count来判断0的个数是否为偶数个。 123def isPowerOfFour(self, num): # return num &gt; 0 and (num &amp; num-1)==0 and bin(num)[2:].count('0')&amp;1==0 return num &gt; 0 and (num &amp; num-1)==0 and len(bin(num))&amp;1==1 方法三：也可以使用正则。 123def isPowerOfFour(self, num): import re return bool(re.match(r'^0b1(00)*$',bin(num))) 292. Nim Game说，有这么一堆石头，一次只能拿1~3个，拿到最后一个石头的人获胜。求n堆石头，你先拿是否可以获胜。原题思路：找规律，发现只有最后剩4个石头的时候，此时轮到谁，谁输。 12def canWinNim(self, n): return n % 4 != 0 400. Nth Digit找出无限整数序列中的第n个数字。原题123456Input:11Output:0Explanation:The 11th digit of the sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... is a 0, which is part of the number 10. 思路，根据n的位数，将无限序列分为几个范围。 size of n step start ~ stop 1 9 1 ~ 9 2 90 10 ~ 99 3 900 100 ~ 999 寻找范围。寻找n处于哪个范围，是1~9，还是10~99，例如n=15。则需要跳过1~9的范围，而这个范围有size*step个数字，所以问题变成在10~99范围上寻找第15-1*9=6个数。 定位数字。10~99范围中是从10开始的，每一个数都有两位数字，所以最终数字为10+(6-1)//2，因为索引从0开始，所以需要-1。 定位数字的位。上一步找到了数字为12，对size求余就可以知道，&#39;12&#39;[(6-1)%2]=&#39;2&#39;。 12345def findNthDigit(self, n): start, step, size = 1, 9, 1 while n &gt; size * step: n, start, step, size = n-size*step, start*10, step*10, size+1 return int(str(start + (n-1)//size)[(n-1) % size]) 415. Add Stings给定两个字符串表示的数字，把它们相加，这两个数的长度小于5100，不能使用任何BitIntegr库或是直接将其转换为整数。ps: 题中要求不将输入直接转换成int，所以我个人认为int还是可以使用的，有一些答案中是使用了ord来做运算。原题方法一：不使用标准库。 123456789101112131415def addStrings(self, num1, num2): if len(num1) &gt; len(num2): num2 = num2.zfill(len(num1)) else: num1 = num1.zfill(len(num2)) res, carry = '', 0 n1, n2 = len(num1)-1, len(num2)-1 while (n1 &gt;= 0 and n2 &gt;= 0) or carry: v1 = int(num1[n1]) if n1 &gt;= 0 else 0 v2 = int(num2[n2]) if n2 &gt;= 0 else 0 carry, val = divmod(v1+v2+carry, 10) res = str(val) + res n1 -= 1 方法二：使用zip_longest。 12345678910def addStrings(self, num1, num2): from itertools import zip_longest nums = list(zip_longest(num1[::-1], num2[::-1], fillvalue='0')) carry, res = 0, '' for digits in nums: d1, d2 = map(int, digits) carry, val = divmod(d1+d2+carry, 10) res = res + str(val) res = res if carry==0 else res+str(carry) return res[::-1] 492. Construct the Rectangle给定一个面积，求组成这个面积的长高差最小。原题1234Input: 4Output: [2, 2]Explanation: The target area is 4, and all the possible ways to construct it are [1,4], [2,2], [4,1]. But according to requirement 2, [1,4] is illegal; according to requirement 3, [4,1] is not optimal compared to [2,2]. So the length L is 2, and the width W is 2. 方法一：一开始我居然这样写。结果超时了，后来发现L+=1，循环次数要比L-=1要多。 12345678910def constructRectangle(self, area): import math squre = math.sqrt(area) if int(squre) == squre: return [int(squre), int(squre)] else: L = int(squre) + 1 while area % L != 0: L += 1 return [L, area//L] 方法二：整理一下思路其实很简单，之前想多了还以为有二分的方法。递减肯定是会优先退出循环的，但是我还不知道怎么证明这个结论。 123456def constructRectangle(self, area): import math w = int(math.sqrt(area)) while area % w != 0: w -= 1 return [area//w, w] 504. Base 710进制转7进制。原题1234Input: 100Output: &quot;202&quot;Input: -7Output: &quot;-10&quot; 方法一：需要注意负数。 1234567def convertToBase7(self, num): if num == 0: return '0' n, res = abs(num), '' while n: val, n = n%7, n//7 res = str(val) + res return res if num&gt;0 else '-'+res]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
        <tag>Algorithm</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode算法题整理（数组篇）Array]]></title>
    <url>%2FLeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E6%95%B0%E7%BB%84%E7%AF%87%EF%BC%89Array%2F</url>
    <content type="text"><![CDATA[1. Two Sum给定一个数组，找出数组两个元素相加为目标值，假定只有唯一解。原题123Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. 1234567def two_sum(nums, target): buff_dict = &#123;&#125; for i, num in enumerate(nums): if num not in buff_dict: buff_dict[target-num] = i else: return [buff_dict[num], i] 26. Remove Duplicates from Sorted Array删除排序数组中重复的元素, 使用build-in在原数组上操作，返回一个长度，标识前n个元素为目标数组。原题12345Given nums = [0,0,1,1,1,2,2,3,3,4],Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.It doesn&apos;t matter what values are set beyond the returned length. 123456789def remove_duplicates(nums): if not nums: return 0 index = 1 for i in range(len(nums)-1): if nums[i] != nums[i+1]: nums[index] = nums[i+1] index += 1 return index 66. Plus One给数组加一，元素为非负整数，不以0开头，每个元素只有一个数字。原题123Input: [4,3,2,1]Output: [4,3,2,2]Explanation: The array represents the integer 4321. 方法一：转成字符串再转成数字 1234def plus_one(digits): str_digits = ''.join(map(str, digits)) plused = int(str_digits) + 1 return [int(x) for x in str(plused)] 方法二：Math 进位 123456789101112def plus_one(digits): d = digits[:] plused = [] carry = 1 while d or carry: if d: v = d.pop() else: v = 0 carry, val = divmod(carry+v, 10) plused.append(val) return plused[::-1] 88. Merge Sorted Array合并两个有序数组，在nums1上修改。原题12345Input:nums1 = [1,2,3,0,0,0], m = 3nums2 = [2,5,6], n = 3Output: [1,2,2,3,5,6] 12345678910def merge(self, nums1, m, nums2, n): while m&gt;0 and n&gt;0: if nums1[m-1] &gt; nums2[n-1]: nums1[n+m-1] = nums1[m-1] m -= 1 else: nums1[n+m-1] = nums2[n-1] n -= 1 if n &gt; 0: nums1[:n] = nums2[:n] 118. Pascal’s Triangle杨辉三角。原题123456789Input: 5Output:[ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1]] 方法一 12345def pascal(num): res = [[1]] for _ in range(1, num): res += [list(map(lambda x, y: x+y, res[-1]+[0], [0]+res[-1]))] return res[:num] 方法二 123456789def generate(num): triangle = [] inner = [1] for _ in range(num): triangle.append(list(inner)) inner.append(0) right = [inner[i]+inner[i+1] for i in range(len(inner)-1)] inner = [1] + right return triangle 119.Pascal’s Triangle II杨辉三角，只打印一层。原题12345def getRow(self, rowIndex): res = [1] for _ in range(rowIndex): res = list(map(lambda x, y: x+y, [0]+res, res+[0])) return res 169. Majority Element找出数组中出现次数超过一半的元素。原题方法一：排序. Time-O(nlogn), Space-O(n) 12def majority_element(nums): return sorted(nums)[len(nums)//2] 方法二：Counter Time-O(n), Space-O(n) 12345def majority_element(nums): from collections import Counter c = Counter(nums) # return max(c.keys(), key=c.get) return c.most_common(1)[0][0] 方法三：Boyer-Moore Voting Algorithm. 书中的算法说的就是这个，这里附上自己的见解。 波义尔摩尔投票算法 12345678def majorityElement(self, nums): count = 0 candidate = None for num in nums: if count == 0: candidate = num count += (1 if num == candidate else -1) return candidate 189. Rotate Array旋转数组。原题123456Input: [1,2,3,4,5,6,7] and k = 3Output: [5,6,7,1,2,3,4]Explanation:rotate 1 steps to the right: [7,1,2,3,4,5,6]rotate 2 steps to the right: [6,7,1,2,3,4,5]rotate 3 steps to the right: [5,6,7,1,2,3,4] 方法一：slicing 123def rotate(nums, k): k = k % len(nums) nums[:] = nums[-k:] + nums[:-k] 方法二：这个方法不是很高效 123def rotate(nums, k): for _ in range(k): nums.insert(0, nums.pop()) 217. Contains Duplicate数组中是否包含重复元素。原题12Input: [1,2,3,1]Output: true 方法一：set 12def contains_duplicate(nums): return len(set(nums)) &lt; len(nums) 方法二：hash 12345678def contains_duplicate(nums): existed = &#123;&#125; for num in nums: if num in existed: return True else: existed[num] = None return False 219. Contains Duplicate II数组中是否包含重复元素，且元素下标差小于等于k。原题1234Input: nums = [1,2,3,1], k = 3Output: trueInput: nums = [1,0,1,1], k = 1Output: true 思路：开始想用set作切片来判断，同上题方法一，但是效率太低。故使用字典。 123456789def containsNearbyDuplicate(self, nums, k): n = len(nums) seen = &#123;&#125; for i, num in enumerate(nums): if num in seen: if i-seen[num] &lt;= k: return True seen[num] = i return False 283. Move Zeroes将数组0元素移动到末尾。原题12Input: [0,1,0,3,12]Output: [1,3,12,0,0] 方法一：two pointers 12345678def move_zero(nums): l, r = 0, len(nums)-1 while l &lt; r: if nums[l] == 0: nums[:] = nums[:l] + nums[l+1:] + [0] r -= 1 else: l += 1 方法二： slicing 12def move_zero(nums): nums[:] = [x for x in nums if x != 0] + [x for x in nums if x == 0] 54. Spiral Matrix螺旋矩阵，顺时针打印矩阵。原题这里注意一点matrix.pop(0)需要转成list，因为zip函数中的每个元素是一个tuple，如果不转变成了一个tuple+list，会抛出异常。 ps: 此题解法为LeetCode一位大神，经常能看到此人的答案，不过这个是我认为最pythonic的一个，没有为了强行one-line而one-line。brilliant! 1TypeError: can only concatenate tuple (not &quot;list&quot;) to tuple 12def spiralOrder(self, matrix): return matrix and list(matrix.pop(0))+self.spiralOrder(list(zip(*matrix))[::-1]) 46. Permutations数组全排列。原题12345678910Input: [1,2,3]Output:[ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]] recursively. 思想为拿出一个数字作为头部，剩下的递归。 1234def permute(self, nums): return [[n] + p for i, n in enumerate(nums) for p in self.permute(nums[:i]+nums[i+1:])] or [[]] iteratively. 思想为拿出一个数字插入到现有排序中的各个位置。 1234567def permute(self, nums): ans = [[]] for n in nums: ans = [l[:i] + [n] + l[i:] for l in ans for i in range(len(l)+1)] return ans 47. Permutations II全排列并去重。原题思路：当然可以使用set来去重，或者考虑一种迭代的方式。 展开。拿着每个数字向上一个结果中插入到每一个位置。 123456789101112131415def permuteUnique(self, nums): ans = [[]] for j, n in enumerate(nums): new_ans = [] for l in ans: for i in range(len(l)+1): new_ans.append(l[:i]+[n]+l[i:]) print('\t j &#123;0&#125; - &#123;3&#125; + [&#123;2&#125;] + &#123;4&#125;'.format(j, i, n, l[:i], l[i:])) # if i&lt;len(l) and l[i]==n: break #handles duplication if i&lt;len(l) and l[i]==n: print('\t \t l[&#123;&#125;] == &#123;&#125;'.format(i, n)) break #handles duplication ans = new_ans print('j &#123;&#125; afer inner ans &#123;&#125;'.format(j, ans)) return ans 输入nums=[1, 2, 3] 123456789101112 j 0 - [] + [1] + []j 0 afer inner ans [[1]] j 1 - [] + [2] + [1] j 1 - [1] + [2] + []j 1 afer inner ans [[2, 1], [1, 2]] j 2 - [] + [3] + [2, 1] j 2 - [2] + [3] + [1] j 2 - [2, 1] + [3] + [] j 2 - [] + [3] + [1, 2] j 2 - [1] + [3] + [2] j 2 - [1, 2] + [3] + []j 2 afer inner ans [[3, 2, 1], [2, 3, 1], [2, 1, 3], [3, 1, 2], [1, 3, 2], [1, 2, 3]] 理解一下是如何去重的，我们输入nums=[1, 2, 1] 123456789101112 j 0 - [] + [1] + []j 0 afer inner ans [[1]] j 1 - [] + [2] + [1] j 1 - [1] + [2] + []j 1 afer inner ans [[2, 1], [1, 2]] j 2 - [] + [1] + [2, 1] j 2 - [2] + [1] + [1] l[1] == 1 j 2 - [] + [1] + [1, 2] l[0] == 1j 2 afer inner ans [[1, 2, 1], [2, 1, 1], [1, 1, 2]][[1, 2, 1], [2, 1, 1], [1, 1, 2]] 列表生成式整合。Stefan大神的写法。使用index来找非重复的临界值。 1234567def permuteUnique(self, nums): ans = [[]] for n in nums: ans = [l[:i]+[n]+l[i:] for l in ans for i in range((l+[n]).index(n)+1)] return ans 215. Kth Largest Element in an Array找出数组中最大的第K个数。 快排的思想，没有通过LeetCode测试用例，因为内存超出了限制。 12345678910111213141516171819def findKthLargest(self, nums, k): if not nums: return pivot = nums[0] left, medium, right = [], [], [] for num in nums: if num &lt; pivot: left.append(num) elif num == pivot: medium.append(num) else: right.append(num) if k &lt;= len(right): return self.findKthLargest(right, k) elif k-len(right) &lt;= len(medium): return pivot else: return self.findKthLargest(left, k-len(right)-len(medium)) 考虑在原数组上进行修改。Time-O(n) 12345678910111213141516171819def findKthLargest(self, nums, k): l, r = 0, len(nums)-1 while True: pos = self.partition(nums, l, r) if pos &lt; k-1: l = pos + 1 elif pos &gt; k-1: r = pos - 1 else: return nums[pos] def partition(self, nums, l, r): p = randint(l, r) # choose a random element as pivot nums[r], nums[p] = nums[p], nums[r] # change the last element with the pivot for i, v in enumerate(nums[l:r+1], l): if nums[i] &gt;= nums[r]: nums[i], nums[l] = nums[l], nums[i] l += 1 return l-1 # return the pivot index 使用堆。Time-O(nlogk) 12345678def findKthLargest(self, nums, k): import heapq heapq.heapify(nums) # for _ in range(len(nums)-k): # heapq.heappop(nums) # return nums[0] return heapq.nlargest(k, nums)[-1] 53. Maximum Subarray连续子数组的最大和。原题123Input: [-2,1,-3,4,-1,2,1,-5,4],Output: 6Explanation: [4,-1,2,1] has the largest sum = 6. 方法一：书中的思想。 123456def maxSubArray(self, nums): cp_nums = nums[:] for i in range(1, len(nums)): if cp_nums[i-1] &gt; 0: cp_nums[i] += cp_nums[i-1] return max(cp_nums) 方法二：one-liner。accumulate了解一下。 123def maxSubArray(self, nums): from itertools import accumulate return max(accumulate(nums, lambda x, y: x+y if x &gt; 0 else y)) 904. Fruit Into Baskets实际上该题抽象为求最大滑动窗口的长度，滑动窗口不同元素最多不超过两个。原题1234tree = [3,3,3,1,2,1,1,2,3,3,4] # 5tree = [1,0,1,4,1,4,1,2,3] # 5tree = [1,2,3,2,2] # 4tree = [0,1,6,6,4,4,6] # 5 一开始没有找到滑动窗口的左边界，老是想直接删除一个key，后来看别人代码受到启发，可以用一个内循环来解决，可以逐个删除，然后判断是否为空。 12345678910111213def totalFruit(self, tree): from collections import Counter basket = Counter() l, res = 0, 0 for r in range(len(tree)): basket[tree[r]] += 1 while len(basket) &gt; 2: basket[tree[l]] -= 1 if basket[tree[l]] == 0: basket.pop(tree[l]) l += 1 res = max(res, sum(basket.values())) return res 27. Remove Element从数组中删除元素，在原数组修改，要求返回一个长度。原题12Given nums = [0,1,2,2,3,0,4,2], val = 2,Your function should return length = 5, 方法一：前后指针，r要从n开始，以n-1作比较 123456789def removeElement(self, nums, val): l, r = 0, len(nums) while l &lt; r: if nums[l] == val: nums[l], nums[r-1] = nums[r-1], nums[l] r -= 1 else: l += 1 return l 方法二：快慢指针 1234567def removeElement(self, nums, val): i = 0 for j in range(len(nums)): if nums[j] != val: nums[i] = nums[j] i += 1 return i 914. X of a Kind in a Deck of Cards有这样一堆数字卡牌，问是否存在一个X&gt;=2，使得将同样数字的卡牌分为每X个一组，并且刚好所有的卡牌分完。原题思路：使用Counter来统计每个数字的个数，然后求这些数字的最大公约数是否大于等于2，这里思路卡了一下，因为没想到最大公约数可以通过reduce来计算，没考虑到时可以累积的。 12345def hasGroupsSizeX(self, deck): from collections import Counter from math import gcd from functools import reduce return reduce(gcd, Counter(deck).values()) &gt;= 2 349. Intersection of Two Arrays求两个数组的交集。返回的数组必须元素唯一，可以无序。原题思路：一开始看到这题以为是两个链表求相交点。最后发现Intersection不应该理解为“十字路口”而应该是“交集”。这里翻了一下discuss，大部分都是使用方法一，其它方法要么太繁琐，要么效率低。值得注意的是，此题的相关话题还有一项是Binary Search也就是说，可能会有一个较为高效的二分搜索法的实现方式。 123Example 2:Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]Output: [9,4] 方法一：最快的方法。 12def intersection(self, nums1, nums2): return list(set(nums1) &amp; set(nums2)) 方法二：Two Pointers. 123456789def intersection(self, nums1, nums2): # two pointers inters = set() for i in range(len(nums1)): for j in range(len(nums2)): if nums1[i] == nums2[j]: inters.add(nums1[i]) break return list(inters) 350. Intersection of Two Arrays II和上题不同的是要返回所有的交集元素。原题1234Example 1:Input: nums1 = [1,2,2,1], nums2 = [2,2]Output: [2,2] 方法一：Counter实现了&amp;操作可以直接取交集。 1234def intersect(self, nums1, nums2): from collections import Counter a, b = map(Counter, (nums1, nums2)) return list((a &amp; b).elements()) 方法二：不使用Counter。 1234567891011def intersect(self, nums1, nums2): from collections import defaultdict counter = defaultdict(int) res = [] for num1 in nums1: counter[num1] += 1 for num2 in nums2: if counter[num2] != 0: res.append(num2) counter[num2] -= 1 return res 905. Sort Array By Parity将一个数组重新排列，是偶数在前奇数在后。原题123Input: [3,1,2,4]Output: [2,4,3,1]The outputs [4,2,3,1], [2,4,1,3], and [4,2,1,3] would also be accepted. 方法一：双指针。 123456789def sortArrayByParity(self, A): l, r = 0, len(A)-1 while l &lt; r: while l&lt;r and A[l]&amp;1==0: l += 1 while l&lt;r and A[r]&amp;1==1: r -= 1 A[l], A[r] = A[r], A[l] return A 方法二：列表生成式。 1234def sortArrayByParity(self, A): even = [num for num in A if num &amp; 1 == 0] odd = [num for num in A if num &amp; 1 == 1] return even + odd 922. Sort Array By Parity II输入一个奇数偶数数量相同的数组，返回下标和其对应的值都是奇数或偶数。和905相似。原题方法一：使用切片的特性赋值。 12345def sortArrayByParityII(self, A): res = [None] * len(A) res[::2] = (num for num in A if num &amp; 1 == 0) res[1::2] = (num for num in A if num &amp; 1 == 1) return res 933. Number of Recent Calls输入一个时间t，返回3000毫秒呢所有的请求个数。原题方法一：deque. 123456789101112131415161718class RecentCounter: def __init__(self): from collections import deque self.pings = deque() self.total = 0 def ping(self, t): drop = 0 self.pings.append(t) self.total += 1 while True: if self.pings[0] &gt;= t-3000: self.total -= drop return self.total else: drop += 1 self.pings.popleft() 937. Reorder Log Files按照规则将log文件排序。原题12Input: [&quot;a1 9 2 3 1&quot;,&quot;g1 act car&quot;,&quot;zo4 4 7&quot;,&quot;ab1 off key dog&quot;,&quot;a8 act zoo&quot;]Output: [&quot;g1 act car&quot;,&quot;a8 act zoo&quot;,&quot;ab1 off key dog&quot;,&quot;a1 9 2 3 1&quot;,&quot;zo4 4 7&quot;] 12345def reorderLogFiles(self, logs): letter_logs = [l for l in logs if l.split()[1].isalpha()] digit_logs = [l for l in logs if not l.split()[1].isalpha()] letter_logs.sort(key=lambda x: x.split()[1:]) return letter_logs + digit_logs 485. Max Consecutive Ones输入一个二进制数组，返回最大的连续1的长度。原题1234Input: [1,1,0,1,1,1]Output: 3Explanation: The first two digits or the last three digits are consecutive 1s. The maximum number of consecutive 1s is 3. 方法一：不使用标准库。末尾补0是因为，如果原数组末尾是1的情况下，还需要计算一次max的值。缺点是改变了原数组。也可以使用再计算一次的方式。 1234567891011def findMaxConsecutiveOnes(self, nums): max_con, count = 0, 0 nums += [0] for num in nums: if num == 1: count += 1 else: max_con = max(max_con, count) count = 0 # max_con = max(max_con, count) return max_con 方法二：使用groupby。 1234567def findMaxConsecutiveOnes(self, nums): from itertools import groupby max_con = 0 for d, group in groupby(nums): if d == 1: max_con = max(max_con, len(list(group))) return max_con 方法三：split。不过这个效率不高。 1234def findMaxConsecutiveOnes(self, nums): nums_str = ''.join(map(str, nums)) ones = nums_str.split('0') return len(max(ones)) 方法四：使用accumulate。Space-complex O(n)。 123def findMaxConsecutiveOnes(self, nums): from itertools import accumulate return max(accumulate(nums, lambda x, y: x+y if y==1 else y)) 946. Validate Stack Sequences给定一个入栈和出栈的顺序，判断是否最后可以清空该栈。原题123456789Input: pushed = [1,2,3,4,5], popped = [4,5,3,2,1]Output: trueExplanation: We might do the following sequence:push(1), push(2), push(3), push(4), pop() -&gt; 4,push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1Input: pushed = [1,2,3,4,5], popped = [4,3,5,1,2]Output: falseExplanation: 1 cannot be popped before 2. 12345678def validateStackSequences(self, pushed, popped): stack = [] for num in pushed: stack.append(num) while stack and stack[-1] == popped[0]: stack.pop() popped.pop(0) return stack[::-1] == popped 496. Next Greater Element I找出数组nums2中对应的nums1元素的位置之后的第一个比nums1大的元素。nums1是nums2的子集，二者均无重复的元素。原题123456789101112Input: nums1 = [4,1,2], nums2 = [1,3,4,2].Output: [-1,3,-1]Explanation: For number 4 in the first array, you cannot find the next greater number for it in the second array, so output -1. For number 1 in the first array, the next greater number for it in the second array is 3. For number 2 in the first array, there is no next greater number for it in the second array, so output -1. Input: nums1 = [2,4], nums2 = [1,2,3,4].Output: [3,-1]Explanation: For number 2 in the first array, the next greater number for it in the second array is 3. For number 4 in the first array, there is no next greater number for it in the second array, so output -1. 方法一：暴力法，因为题中给了范围数组长度小于1000，所以也没有超时。 1234567891011121314def nextGreaterElement(self, nums1, nums2): res = [] for num1 in nums1: index = nums2.index(num1) if not nums2[index+1:]: res.append(-1) else: for num2 in nums2[index+1:]: if num2 &gt; num1: res.append(num2) break else: res.append(-1) return res 方法二：one-liner，生成器一开始想到了，没想到next函数还可以设默认值。 12def nextGreaterElement(self, nums1, nums2): return [next((y for y in nums2[nums2.index(x):] if y &gt; x), -1) for x in nums1] 953. Verifying an Alien Dictionary判断一个字符串数组是否按照特定的字典顺序排序。原题123456789Input: words = [&quot;hello&quot;,&quot;leetcode&quot;], order = &quot;hlabcdefgijkmnopqrstuvwxyz&quot;Output: trueExplanation: As &apos;h&apos; comes before &apos;l&apos; in this language, then the sequence is sorted.Input: words = [&quot;word&quot;,&quot;world&quot;,&quot;row&quot;], order = &quot;worldabcefghijkmnpqstuvxyz&quot;Output: falseExplanation: As &apos;d&apos; comes after &apos;l&apos; in this language, then words[0] &gt; words[1], hence the sequence is unsorted.Input: words = [&quot;apple&quot;,&quot;app&quot;], order = &quot;abcdefghijklmnopqrstuvwxyz&quot;Output: falseExplanation: The first three characters &quot;app&quot; match, and the second string is shorter (in size.) According to lexicographical rules &quot;apple&quot; &gt; &quot;app&quot;, because &apos;l&apos; &gt; &apos;∅&apos;, where &apos;∅&apos; is defined as the blank character which is less than any other character (More info). 方法一：这道题想了很久，最后还是没有做出来，一开始想用zip来自己实现，也想到了sort，但是key里面的匿名函数一直没有相对，关键是二位数组也能排序这点没有想到。 12def isAlienSorted(self, words, order): return words == sorted(words, key=lambda word: [order.index(char) for char in word]) 506. Relative Ranks根据得分，返回排名。前三要用奖牌表示。原题1234Input: [5, 4, 3, 2, 1]Output: [&quot;Gold Medal&quot;, &quot;Silver Medal&quot;, &quot;Bronze Medal&quot;, &quot;4&quot;, &quot;5&quot;]Explanation: The first three athletes got the top three highest scores, so they got &quot;Gold Medal&quot;, &quot;Silver Medal&quot; and &quot;Bronze Medal&quot;. For the left two athletes, you just need to output their relative ranks according to their scores. 方法一：先生成一个排行榜单，再根据每个得分把排序映射上去。 12345def findRelativeRanks(self, nums): ranks = list(map(str,range(1, len(nums)+1))) ranks[:3] = ["Gold Medal", "Silver Medal", "Bronze Medal"] sorted_nums = sorted(nums, reverse=True) return [ranks[sorted_nums.index(num)] for num in nums] # slow 方法二：使用map映射。 1234567def findRelativeRanks(self, nums): ranks = list(map(str,range(1, len(nums)+1))) ranks[:3] = ["Gold Medal", "Silver Medal", "Bronze Medal"] sorted_nums = sorted(nums, reverse=True) # map_rank = &#123;num: ranks[i] for i, num in enumerate(sorted_nums)&#125; # return list(map(map_rank.get, nums)) return list(map(dict(zip(sorted_nums, ranks)).get, nums)) 532. K-diff Pairs in an Array找出差为k的不重复的成对元素的个数。原题1234Input: [3, 1, 4, 1, 5], k = 2Output: 2Explanation: There are two 2-diff pairs in the array, (1, 3) and (3, 5).Although we have two 1s in the input, we should only return the number of unique pairs. 方法一：Counter，一开始没想到，想sort或是set，然后实现不了。 12345678def findPairs(self, nums, k): from collections import Counter c = Counter(nums) res = 0 for num, count in c.items(): if (k == 0 and count &gt; 1) or (k &gt; 0 and num+k in c): res += 1 return res 961. N-Repeated Element in Size 2N Array找出2N长的数组中重复N次的数字，其它数字均只出现一次。原题12Input: [2,1,2,5,3,2]Output: 2 方法一：这题本意我看是哈希表，所以大部分答案都是Counter之类的，我看排行榜签名的Python选手也是这么用的，我是灵机一动一动动想出了一个数学方法。看上去迭代了两次数组，并使用了一些空间，但其实速度很快。 12def repeatedNTimes(self, A): return int((sum(A)-sum(set(A))) // (len(A)//2-1)) 967. Numbers With Same Consecutive Differences根据规则生成一组数组，数字长度为N，每两位的差为K。原题方法一：迭代生成，其实此题本是一道动态规划题，但由于解法不是，暂时归到数组里。 12345678910111213141516171819def numsSameConsecDiff(N, K): res = set(range(1, 10)) if N == 1: res.add(0) for _ in range(N-1): new_line = set() for digit in res: new_line.update(add_one_bit(digit, K)) res = new_line return list(res) def add_one_bit(digit, K): digits = [] units = digit % 10 if 0 &lt;= units + K &lt;= 9: digits.append(digit*10 + units + K) if 0 &lt;= units - K &lt;= 9: digits.append(digit*10 + units - K) return digits 561. Array Partition I将数组两两分成一组，累加每组的最小值，使之尽量大。原题1234Input: [1,4,3,2]Output: 4Explanation: n is 2, and the maximum sum of pairs is 4 = min(1, 2) + min(3, 4). 12def arrayPairSum(self, nums): return sum(sorted(nums)[::2]) 566. Reshape the Matrix改变矩阵的形状，如果元素超出或不足，返回原矩阵。原题123456789Input: nums = [[1,2], [3,4]]r = 1, c = 4Output: [[1,2,3,4]]Explanation:The row-traversing of nums is [1,2,3,4]. The new reshaped matrix is a 1 * 4 matrix, fill it row by row by using the previous list. 方法一：扁平化后重组。 123456def matrixReshape(self, nums, r, c): a = [x for row in nums for x in row] n = len(a) if r*c != n: return nums return [a[i*c:i*c+c] for i in range(r)] 方法二：使用itertools. 123456def matrixReshape(self, nums, r, c): if r*c != len(nums)*len(nums[0]): return nums from itertools import islice, chain it = chain(*nums) return [list(islice(it, c)) for _ in range(r)] 575. Distribute Candies给姐姐弟弟分糖，两人数量一样，保证姐姐的种类最多，求姐姐最多能分到多少种。原题123456Input: candies = [1,1,2,2,3,3]Output: 3Explanation:There are three different kinds of candies (1, 2 and 3), and two candies for each kind.Optimal distribution: The sister has candies [1,2,3] and the brother has candies [1,2,3], too. The sister has three different kinds of candies. 12def distributeCandies(self, candies): return min(len(candies)//2, len(set(candies))) 594. Longest Harmonious Subsequence最长的和谐子数组，即元素的最大值和最小值正好相差一的子数组，元素顺序无关，求最大子数组长度。原题123Input: [1,3,2,2,5,2,3,7]Output: 5Explanation: The longest harmonious subsequence is [3,2,2,2,3]. 方法一：开始想错了，后来发现子数组只能包含两个元素。 12345678def findLHS(self, nums): from collections import Counter res = 0 c = Counter(nums) for num, count in c.items(): sum_count = count+c[num+1] if c[num+1] else 0 res = max(res, sum_count) return res 方法二：one-liner. 1234def findLHS(self, nums): from collections import Counter c = Counter(nums) return max([count+c[num+1] for num, count in c.items() if num+1 in c] or [0])]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
        <tag>Algorithm</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode算法题整理（链表篇）LinkedList]]></title>
    <url>%2FLeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E9%93%BE%E8%A1%A8%E7%AF%87%EF%BC%89LinkedList%2F</url>
    <content type="text"><![CDATA[链表的定义1234class ListNode: def __init__(self, x): self.val = x self.next = None 2. Add Two Numbers两个链表相加123Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8Explanation: 342 + 465 = 807. 123456789101112131415def addTwoNumbers(l1, l2): l = head = ListNode(0) carry = 0 while l1 or l2 or carry: v1 = v2 = 0 if l1: v1 = l1.val l1 = l1.next if l2: v2 = l2.val l2 = l2.next carry, val = divmod(v1+v2+carry, 10) l.next = ListNode(val) l = l.next return head.next 21. Merge Two Sorted Lists合并两个有序链表。原题12Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 方法1：iteratively 迭代 12345678910def mergeTwoLists(l1, l2): l = head = ListNode(0) while l1 and l2: if l1.val &lt;= l2.val: l.next, l1 = l1, l1.next else: l.next, l2 = l2, l2.next l = l.next l.next = l1 or l2 return head.next 方法2：recursively 递归 12345678910def mergeTwoLists(l1, l2): # 判断是否存在None if not l1 or not l2: return l1 or l2 if l1.val &lt; l2.val: l1.next = mergeTwoLists(l1.next, l2) return l1 else: l2.next = mergeTwoLists(l1, l2.next) return l2 237. Delete Node in a Linked List在链表中删除节点。给定的节点不是尾节点。原题12Input: head = [4,5,1,9], node = 5Output: [4,1,9] 开始看到这题的思路是，要是能拿到父节点就好了，然后这道题需要别的思路，其关键在于复制 123def deleteNode(self, node): node.val = node.next.val # 4-&gt;1-&gt;1-&gt;9 node.next = nede.next.next # 4-&gt;1-&gt;9 141. Linked List Cycle判断一个链表是否有环。原题经典的一道题，看成两个人在赛跑，如果有环，快的人会和慢的人相遇 1234567def hasCycle(self, head): slow = fast = head: while fast and fast.next: slow, fast = slow.next, fast.next.next if fast is slow: return True return False 206. Reverse Linked List倒置一个链表。原题12Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULLOutput: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 方法一： iteratively 12345678def reverseList(head): prev = None while head: cur = head head = head.next cur.next = prev prev = cur return prev 方法二：使用一行赋值 12345def reverseList(self, head): prev = None while head: head.next, prev, head = prev, head, head.next return prev Python同时给多个变量赋值。 方法三：递归 123456def reverseList(self, head, prev=None): if not head: return prev cur, head.next = head.next, prev return self.reverseList(cur, head) 160. Intersection of Two Linked Lists两个链表求相交。原题123456def getIntersectionNode(self, headA, headB): p1, p2 = headA, headB while p1 is not p2: p1 = p1.next if p1 else headB p2 = p2.next if p2 else headA return p1 83. Remove Duplicates from Sorted List删除有序链表中重复的节点。原题12345678def delete_duplicates(head): root = head while head and head.next: if head.val == head.next.val: head.next = head.next.next else: head = head.next return root 142. Linked List Cycle II求链表中环的入口节点。原题 首先判断此链表是否有环。 然后在相交点和头结点一起走，一定会在入口相遇。 Consider the following linked list, where E is the cylce entry and X, the crossing point of fast and slow. H: distance from head to cycle entry E D: distance from E to X L: cycle length ​ _____ ​ / \ head_____H______E \ ​ \ / ​ X_____/ If fast and slow both start at head, when fast catches slow, slow has traveled H+D and fast 2(H+D). Assume fast has traveled n loops in the cycle, we have: 2H + 2D = H + D + L --&gt; H + D = nL --&gt; H = nL - D Thus if two pointers start from head and X, respectively, one first reaches E, the other also reaches E. In my solution, since fast starts at head.next, we need to move slow one step forward in the beginning of part 2 123456789101112131415class Solution(object): def detectCycle(self, head): fast = slow = head # 检测是否有环 while fast and fast.next: slow, fast = slow.next, fast.next.next if slow is fast: break else: return None # 找出入口节点 while head is not slow: head, slow = head.next, slow.next return head 138. Copy List with Random Pointer深拷贝一个复杂链表，链表多包含了一个随机指针。原题 Time-O(2n), Memory-O(n). 12345678910111213def copyRandomList(self, head): cp_map = &#123;&#125; m = n = head while m: cp_map[m] = RandomListNode(m.label) m = m.next while n: cp_map[n].next = cp_map.get(n.next) cp_map[n].random = cp_map.get(n.random) n = n.next return cp_map.get(head) Time-O(n), Memory-O(n). 这种方式是相当于把第一次迭代的过程委托给了defaultdict，通过创建一个默认的对象，再去修改它的label值。 1234567891011def copyRandomList(self, head): from collections import defaultdict cp = defaultdict(lambda: RandomListNode(0)) cp[None] = None n = head while n: cp[n].label = n.label cp[n].next = cp[n.next] cp[n].random = cp[n.random] n = n.next return cp[head] 203. Remove Linked List Elements删除链表中值为val的元素。原题方法一：遍历head并构建新的ListNode。 12345678def removeElements(self, head, val): l = res = ListNode(0) while head: if head.val != val: l.next = ListNode(head.val) l = l.next head = head.next return res.next 方法二：删除重复的节点。更喜欢这个方法。 12345678910def removeElements(self, head, val): l = ListNode(0) l.next = head res = l while l and l.next: if l.next.val == val: l.next = l.next.next else: l = l.next return res.next]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Python</tag>
        <tag>Algorithm</tag>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo搭建遇到的问题及优化]]></title>
    <url>%2Fhexo%E6%90%AD%E5%BB%BA%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[前言终于有了一个整理自己学习笔记的地方了，之前用过印象笔记，觉得它的markdown格式处理得不是很完美，复制粘贴出来总是格式不对。后来又用过jupyter_nootboke，但是不方便在其它客户端查看。折腾了半天终于弄好了期间遇到过不少坑，发现hexo有时候同一样的问题总是对应着几种不同的解决方法，在此整理一下以便之后遇到问题。 关于问题NexT这里使用了next主题，这个主题特别简洁，还有很多易用性的扩展，尤其侧边栏的快速定位，让我爱不释手。 头像不显示开始按照_config.yml中所说把avatar.gif放到blog-site/source/下，没有任何的作用。后来发现是主题的原因，放到themes/next/source/images/下就好了，默认的头像是正方形的，这里修改了一下代码把它改成圆形，文件位置在themes/next/source/css_common_components/sidebar/sidebar-author.styl 1234567891011121314.site-author-image &#123; display: block; margin: 0 auto; max-width: 96px; height: auto; border: 2px solid #333; padding: 2px; /* start*/ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px; box-shadow: inset 0 -1px 0 #333sf; /* end */&#125; 网页图标favicon.ico不显示这里也是因为Next的原因，把favicon.ico放到themes/next/source/images/下，然后修改_config.yml中favicon: /images/favicon.ico解决了问题。这里介绍一个很方便转换ico的网站favicon在线制作。 没有建立资源文件夹 设置post_asset_foler: true之后执行hexo new post_name后没有建立资源文件夹。搜索没有查到相关记录，后来想到之前next主题设置时，把配置文件拆分了出来，这样每次执行hexo clean/generate的时候在后面加了参数--config指定了配置文件。但是这样修改的文件对于hexo new post_name来说是没有修过的，所以要在source/_config.yml修改这项参数。 之后没有选择官方的标签插件是因为，在编辑markdown时无法看到预览效果所以安装npm install https://github.com/CodeFalling/hexo-asset-image --save，在文章中使用markdown语法引用![logo](&lt;title_name&gt;/a.png)使用。 选择官方的标签插件引用图片。 关于优化在右上角或者左上角实现fork me on github在这里选择喜欢的样式。这里选择的是 1&lt;a href="https://your-url" class="github-corner" aria-label="View source on Github"&gt;&lt;svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"&gt;&lt;path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"&gt;&lt;/path&gt;&lt;path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"&gt;&lt;/path&gt;&lt;path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;&lt;style&gt;.github-corner:hover .octo-arm&#123;animation:octocat-wave 560ms ease-in-out&#125;@keyframes octocat-wave&#123;0%,100%&#123;transform:rotate(0)&#125;20%,60%&#123;transform:rotate(-25deg)&#125;40%,80%&#123;transform:rotate(10deg)&#125;&#125;@media (max-width:500px)&#123;.github-corner:hover .octo-arm&#123;animation:none&#125;.github-corner .octo-arm&#123;animation:octocat-wave 560ms ease-in-out&#125;&#125;&lt;/style&gt; 将其粘贴到themes/next/layout/_layout.swig中，放在div class=&quot;headhand&quot;&gt;&lt;/div&gt;下面。 修改文章底部的那个带#号的标签修改模板/themes/next/layout/_macro/post.swig，搜索rel=&quot;tag&quot;&gt;#，将#换成&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt; 侧边栏社交小图标设置在配置文件搜索social_icons，把值换成喜欢的图标名字，这里列出了图标库 在网站底部加上访问量打开/themes/next/layout/_partials/footer.swig文件添加红框内的代码 1&lt;script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"&gt;&lt;/script&gt; 添加统计代码如下位置 12345&lt;div class="powered-by"&gt;&lt;i class="fa fa-user-md"&gt;&lt;/i&gt;&lt;span id="busuanzi_container_site_uv"&gt; 本站访客数:&lt;span id="busuanzi_value_site_uv"&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt; 网站底部字数统计根目录安装npm install hexo-wordcount --save然后再/themes/next/layout/_partials/footer.swig文件最后加上 1234&lt;div class=&quot;theme-info&quot;&gt; &lt;div class=&quot;powered-by&quot;&gt;&lt;/div&gt; &lt;span class=&quot;post-count&quot;&gt;博客全站共&#123;&#123; totalcount(site) &#125;&#125;字&lt;/span&gt;&lt;/div&gt; 添加顶部加载条_config.yml设置中pace:true 在文章底部增加版权信息在目录themes/next/layout/_macro/下添加my-copyright.swig: 123456789101112131415161718192021222324252627282930&#123;% if page.copyright %&#125;&lt;div class="my_post_copyright"&gt; &lt;script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"&gt;&lt;/script&gt; &lt;!-- JS库 sweetalert 可修改路径 --&gt; &lt;script src="https://cdn.bootcss.com/jquery/2.0.0/jquery.min.js"&gt;&lt;/script&gt; &lt;script src="https://unpkg.com/sweetalert/dist/sweetalert.min.js"&gt;&lt;/script&gt; &lt;p&gt;&lt;span&gt;本文标题:&lt;/span&gt;&lt;a href="&#123;&#123; url_for(page.path) &#125;&#125;"&gt;&#123;&#123; page.title &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;文章作者:&lt;/span&gt;&lt;a href="/" title="访问 &#123;&#123; theme.author &#125;&#125; 的个人博客"&gt;&#123;&#123; theme.author &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;发布时间:&lt;/span&gt;&#123;&#123; page.date.format("YYYY年MM月DD日 - HH:MM") &#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;span&gt;最后更新:&lt;/span&gt;&#123;&#123; page.updated.format("YYYY年MM月DD日 - HH:MM") &#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;span&gt;原始链接:&lt;/span&gt;&lt;a href="&#123;&#123; url_for(page.path) &#125;&#125;" title="&#123;&#123; page.title &#125;&#125;"&gt;&#123;&#123; page.permalink &#125;&#125;&lt;/a&gt; &lt;span class="copy-path" title="点击复制文章链接"&gt;&lt;i class="fa fa-clipboard" data-clipboard-text="&#123;&#123; page.permalink &#125;&#125;" aria-label="复制成功！"&gt;&lt;/i&gt;&lt;/span&gt; &lt;/p&gt; &lt;p&gt;&lt;span&gt;许可协议:&lt;/span&gt;&lt;i class="fa fa-creative-commons"&gt;&lt;/i&gt; &lt;a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)"&gt;署名-非商业性使用-禁止演绎 4.0 国际&lt;/a&gt; 转载请保留原文链接及作者。&lt;/p&gt; &lt;/div&gt;&lt;script&gt; var clipboard = new Clipboard('.fa-clipboard'); $(".fa-clipboard").click(function()&#123; clipboard.on('success', function()&#123; swal(&#123; title: "", text: '复制成功', icon: "success", showConfirmButton: true &#125;); &#125;); &#125;); &lt;/script&gt;&#123;% endif %&#125; 在目录themes/next/source/css/_common/components/post/下添加my-post-copyright.styl: 123456789101112131415161718192021222324252627282930313233343536373839404142434445.my_post_copyright &#123; width: 85%; max-width: 45em; margin: 2.8em auto 0; padding: 0.5em 1.0em; border: 1px solid #d3d3d3; font-size: 0.93rem; line-height: 1.6em; word-break: break-all; background: rgba(255,255,255,0.4);&#125;.my_post_copyright p&#123;margin:0;&#125;.my_post_copyright span &#123; display: inline-block; width: 5.2em; color: #b5b5b5; font-weight: bold;&#125;.my_post_copyright .raw &#123; margin-left: 1em; width: 5em;&#125;.my_post_copyright a &#123; color: #808080; border-bottom:0;&#125;.my_post_copyright a:hover &#123; color: #a3d2a3; text-decoration: underline;&#125;.my_post_copyright:hover .fa-clipboard &#123; color: #000;&#125;.my_post_copyright .post-url:hover &#123; font-weight: normal;&#125;.my_post_copyright .copy-path &#123; margin-left: 1em; width: 1em; +mobile()&#123;display:none;&#125;&#125;.my_post_copyright .copy-path:hover &#123; color: #808080; cursor: pointer;&#125; 修改/themes/next/layout/_macro/post.swig在如下位置 添加代码：(注意和之前的教程不一样，这里可能是next的更新了，所以要把代码放到外面，否则在wechat_subscriber未开启时会导致失效。) 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'my-copyright.swig' %&#125; &#123;% endif %&#125;&lt;/div&gt; 修改themes/next/source/css/_common/components/post/post.styl末尾增加一行1@import &quot;my-post-copyright&quot; 博文置顶替换node_modules/hexo-generator-index/lib/generator.js所有的代码为： 12345678910111213141516171819202122232425262728'use strict';var pagination = require('hexo-pagination');module.exports = function(locals)&#123; var config = this.config; var posts = locals.posts; posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义 if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排 else return b.top - a.top; // 否则按照top值降序排 &#125; else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233） return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; // 都没定义按照文章日期降序排 &#125;); var paginationDir = config.pagination_dir || 'page'; return pagination('', posts, &#123; perPage: config.index_generator.per_page, layout: ['index', 'archive'], format: paginationDir + '/%d/', data: &#123; __index: true &#125; &#125;);&#125;; 使用：在头部添加top 12345678---title: date: 2017-05-22 22:45:48tags: 技巧categories: 技巧copyright: truetop: 100--- 修改字体大小/themes/next/source/css/_variables/base.styl搜索font-size-base 设置阅读次数添加阅读量统计 添加搜索12local_search: enable: true SEO优化两个搜索引擎入口： 谷歌搜索引擎验证 百度搜索引擎验证 这里选择用下载文件的方式，将文件放到source/目录下，注意一点应该在文件前添加两行代码，防止hexo将其格式化 12layout: false--- 生成站点地图 sitemap 站点地图是一种文件，您可以通过该文件列出您网站上的网页，从而将您网站内容的组织架构告知Google和其他搜索引擎。Googlebot等搜索引擎网页抓取工具会读取此文件，以便更加智能地抓取您的网站。 12npm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save 更改配置 12345# 自动生成sitemapsitemap: path: sitemap.xmlbaidusitemap: path: baidusitemap.xml 使搜索引擎收录我们的博客 谷歌比较简单向谷歌站长工具提交sitemap 百度。参考Hexo插件之百度主动提交链接 网站自身优化给出站链接添加 “nofollow” 标签/themes/next/layout/_partials/footer.swig找到下面两行，分别在a标签中添加rel=&quot;texternal nofollow&quot;属性 同样在/themes/next/layout/_macor/sidebar.swig中添加这个属性 设置更改属性seo: true 缩短文章链接编辑配置文件permalink: :title.html 添加文章更新时间参考了hexo添加文章更新时间 首先找到/themes/next/layout/_macro/post.swig文件，在&lt;span class=&quot;post-time&quot;&gt;...&lt;/span&gt;后添加： 12345678&#123;%if post.updated and post.updated &gt; post.date%&#125; &lt;span class="post-updated"&gt; &amp;nbsp; | &amp;nbsp; &#123;&#123; __('Updated on') &#125;&#125; &lt;time itemprop="dateUpdated" datetime="&#123;&#123; moment(post.updated).format() &#125;&#125;" content="&#123;&#123; date(post.updated, config.date_format) &#125;&#125;"&gt; &#123;&#123; date(post.updated, config.date_format) &#125;&#125; &lt;/time&gt; &lt;/span&gt;&#123;% endif %&#125; 博主这里改了一下显式的文本，后面的语言配置没有配，如果想手动更改文章更新时间在文章前加上： 1updated: 2018-01-01 12:00:00 默认使用md的修改时间。 文章添加阴影效果找到文件themes/next/source/css/_custom/custom.styl，添加如下代码。 12345678// 主页文章添加阴影效果.post &#123; margin-top: 0px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5);&#125;]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
